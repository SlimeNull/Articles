<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>[C#] EleCho.Json: 便捷, 简单以及高速的 JSON 操作</title><url>https://slimenull.top/post/csharp-elechojson/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>算法</tag><tag>轮子</tag></tags><content type="html"> 便捷, 简单以及高速的 JSON 读写器. 同时以也可以使用实体类来操作 JSON 数据.
EleCho.Json 是我目前最新开发的开源 JSON 解析库, 它的代码是目前的我所能写出来最优的, 相比之前写过的 CHO.Json, EleCho.Json 是更加简单的, 并且更加灵活. 主要是追求较高速率, 不要求复杂特性的简易 JSON 操作, 例如最基本类型的转换.
开源仓库: SlimeNull/EleCho.Json
, 欢迎提交 Pull Request.
速度约为 Newtonsoft.Json 的 1.89 倍, System.Text.Json 的 7.92 倍, 你也可以在 TestConsole 项目中自己运行该测试
安装 EleCho.Json 你可以通过 NuGet 安装 EleCho.Json. NuGet: Install-Package EleCho.Json
或者在 Visual Studio 中, 使用 Nuget 包管理器安装 EleCho.Json.
JSON 对象 EleCho.Json 中, 所有的 JSON 数据, 包括数组, 字典, 字符串, 数字, 布尔值, null, 都能够直接去存储与操作值.
例如 JsonObject 是 JSON 对象, 用于存储键值对, 在 EleCho.Json, 它直接继承于 Dictionary&lt;string, object>, 它的值可以是任意类型的. 包括 JsonArray 也是继承于 List&lt;object>.
JsonObject jObj = new JsonObject(); // JSON 对象 (键值对存储) jObj.Add("some_key", "any_value"); // 使用字符串键设置值 jObj["some_key"] = new JsonString("Some string value"); // 或者使用 "this[...]" 和 IJsonData 设置 JsonArray jArr = new JsonArray(); // JSON 数组 (列表存储) jArr.Add("Any value"); // 添加任何 JSON 数据 jArr.Add(new JsonString("Anything")); // 或者使用 JsonString JsonString jStr = "QWQ"; // 使用隐式类型转换创建 JSON 字符串 JsonNumber jNum = 114514; // 床架 JSON 数字 (它使用 double 存储) JsonBoolean jBl = true; // 创建 JSON 逻辑值(布尔值) JsonNull = new JsonNull(); // JSON null, 或者使用 JsonData.Null // Read JSON data: string someStr = jObj["some_key"] as JsonString; // 从 JSON 对象中读取 JSON 字符串 int someNum = jObj["some_key_num"] as JsonNumber; // 从 JSON 对象中读取 JSON 数字 通过流操作 JSON 数据 EleCho.Json 提供了 JsonWriter 和 JsonReader 来实现 JSON 数据的写入和读取. 构造函数接受一个 Stream 或 TextWriter/TextReader.
将 JSON 数据写入到流
Stream stream; // 要写入的 Stream IJsonData someJsonData; JsonWriter jw = new JsonWriter(stream); jw.Write(someJsonData); 从流中读取 IJsonData:
Stream stream; // 要读取的 Stream JsonReader jr = new JsonReader(stream); // 实例化 JSON 读取器 IJsonData jsonData = jr.Read(); // 从流中读取一个完整的 JSON 数据 值与 JSON 数据的转换 从任意创建 JSON 数据
IJsonData jsonData = JsonData.FromValue(new() { Name = "SlimeNull", Age = 18, Description = "CSharper! love .NET (*/ω＼*)" }); 从 JSON 数据创建模型对象
class One { public string Name; public int Age; public string Description; // 在这里你也可以使用属性 } void LogicalCode() { JsonObject someJsonData; // 要处理的 JSON 数据 One model = JsonData.ToValue(typeof(One), someJsonData); } 序列化与反序列化 将对象序列化为 JSON 字符串
class One { public string Name; public int Age; public string Description; } void LogicalCode() { One model = new One() { Name = "SlimeNull", Age = 18, Description = "Some text" }; string jsonText = JsonSerializer.Serialize(model); } 从 JSON 字符串反序列化
class One { public string Name; public int Age; public string Description; } void LogicalCode() { string jsonTxt; One model = JsonSerializer.Deserialize&lt;One>(jsonTxt); } 从流中读取 JsonToken 从流中解析 JSON token
Stream stream; // 要读取的流 JsonParser jParser = new JsonParser(stream); jParser.PeekToken(); // 从流中读取一个 token, 但不变更当前的读取状态 jParser.ReadToken(); // 从流中读取一个 token, 并移动到下一个 token</content></entry><entry><title>[.NET] 关于 .NET 的基础资料</title><url>https://slimenull.top/post/dotnet-aboutdotnet/</url><categories/><tags><tag>.NET</tag><tag>参考</tag></tags><content type="html"> 初识 .NET, 关于 .NET 是什么, 它的不同版本, 基于它的语言, 以及 .NET 特性概述
什么是 .NET 从微软官网可以看到, .NET 是 免费，跨平台，开源用于构建所有应用的开发人员平台.
跨平台是指: .NET 可运行在多个平台上, 包括 Windows, Linux, Mac 等 开发人员平台是指: 开发人员可基于 .NET 开发应用程序
.NET 类似于 Java, 是运行程序的平台, 使用 .NET 可以运行基于 .NET 的应用程序
之所以使用 .NET 开发应用程序, 是因为它为开发者提供了强大的便利, 标准库, 相比较 C++ 来讲, 使用 .NET 开发应用程序更加便捷, 不需要太大的成本就可以开发一个不错的程序, 包括学生学习使用 .NET 开发程序也是非常方便简单的
.NET 的不同版本 截至 2022 年 3 月:
.NET 最早的版本, .NET Framework, 他运行在 Windows 平台, 并且内置于 Windows, 很多 Windows 程序也基于 .NET, 使用 .NET Framework 可以开发控制台程序, 桌面程序, 后端程序, 任何都可以. 由于 .NET Framework 是最早的版本, 所以就目前来讲, .NET Framework 包含最完善的功能支持.
.NET 跨平台版本, .NET Core, 它可以运行在 Windows, Linux 和 Mac 等平台, 正如其名, 他是 .NET 的核心, 也可以说是 .NET Framework 的阉割版. 例如 .NET Core 没有跨平台桌面开发的官方支持(但你可以使用第三方的框架), 并且许多依赖于 Windows 操作系统的功能, .NET Core 都没有内置(但是有其他实现).
.NET 的最新版本, .NET; 目前, 官方已经将开发中心转移到 .NET, 它抛弃了 Framework 或 Core 这样的后缀名称, 而是直接采用 &ldquo;.NET&rdquo; 作为它的名称. 值得一提的是, .NET 其实是 .NET Core 的最新版本, 目前, Windows 尚未内置 .NET, 还是如以前般内置 .NET Framework.
.NET 可以开发运行在 Windows 上的应用程序, 或者说, 他在常用的功能上并不比 .NET Framework 差, 而新的功能也大部分都侧重于 .NET, 但是一些冷门功能例如 AppDomain 还是仅仅可在 .NET Framework 上使用.
.NET Framework 至今仍然强大是因为之前官方一直是侧重于它的, 而近几年官方开始关注跨平台, 于是 .NET Framework 也停止了更新.
.NET 还有一套通用的编程接口规范, .NET Standard, 这不是一个 .NET 版本, 开发者开发的基于 .NET Standard 可以运行在任何遵循该套接口版本上, 包括 .NET Framework, .NET Core 以及 .NET
.NET Runtime .NET Runtime 指的是 .NET 运行时(也被译作 .NET 运行库), .NET 程序被编译为包含 .NET Runtime 可识别执行的 MSIL(Microsoft Intermediate Langauge, 微软中间语言), 然后在运行时由 .NET Runtime 负责解释执行.
.NET Runtime 在 Java 中相当于 jvm 的概念, 运行时负责也管理 .NET 对象, 垃圾回收, 程序通过 .NET Runtime 间接与系统接触, 于是便实现了一次编译, 处处执行(.NET Core).
基于 .NET 的语言 C# 是最常用的, 基于 .NET 的编程语言, 一种面向对象的, 拥有诸多特性的编程语言.
VB.NET 是较旧的, 已经停止更新了的, 基于 .NET 的编程语言, 它同样面向对象, 但是如今已经很少使用了.
F# 函数式的编程语言, 虽然大不适合日常的编程, 但是用起来还是比较舒服的
PowerShell, 跨平台的 Shell, 强类型, 基于 .NET, 功能强大且易于学习
.NET 特性 最长用与 .NET 作比较的就是 Java 了, 这里以 C# 为例, 说明 .NET 与 C# 特性并且与 Java 做简单比较
参考于: C#语言主要特性总结
原文内容经过纠正
简单 C# 中指针已经消失. 不安全的操作, 比方说直接内存操作不被允许了. C# 中 &ldquo;::&rdquo; 或 &ldquo;->&rdquo; 操作符是没用的. 因为它是基于 .NET 平台的, 它继承了自动内存管理和垃圾回收的特点. 原始数据类型可变的数据范围象 Integer, Floats 等. 整形数值 0 和 1 不再作为布尔值出现. C#中的布尔值是纯粹的 true 和 false 值而且没有更多的 &ldquo;=&rdquo; 操作符和 &ldquo;==&rdquo; 操作符错误. &ldquo;==&rdquo; 被用于进行比较操作而 &ldquo;=&rdquo; 被用做赋值操作. 现代 C# 建立在当前的潮流上, 对于创建相互兼容的, 可伸缩的, 健壮的应用程序来说是非常强大和简单的. C# 拥有内建的支持来将任何组件转换成一个 Web service, 运行在任何平台上的任何应用程序都可以通过互联网来使用这个服务. 面向对象的 C# 支持数据封装, 继承, 多态和接口(即 Java 中的 interface 关键字). int, float, double 在java中都不是对象, 但是 C# 引入和结构体(struct)来使原始数据类型变成对象 int i = 1; String a = i ToString(); 转换或者 Boxing 类型安全 在 C# 中我们不能进行不安全的类型转换象将 double 转换成 boolean. 值类型(常量类型)被初始化为零值而引用类型(对象和类被编译器自动初始化为零值. 数组类型下标从零开始而且进行越界检查. 类型溢出将被检查. 相互兼容性 C# 提供对 COM 和基于 Windows 的应用程序的原始的支持. 允许对原始指针的有限制的使用. 用户不再需要显式的实现 unkown 和其它 COM 界面, 这些功能已经内建. C# 允许用户将指针作为不安全的代码段来操作老的代码. VB.NET 和其它中间代码语言中的组件可以在 C# 中直接使用. 可伸缩性和可升级性 .NET 引入了程序集的概念, 它们通过其 &ldquo;手册&rdquo; 具有自描述的功能. 手册确立了零部件的标识, 版本, 语言和数字签名等. 程序集不需要在任何地方注册. 要扩展我们的程序, 我们只需要删除老的文件并用新的文件来升级它们. 不需要注册动态链接库. 升级软件组件的过程只是一个错误探测的任务. 对代码的修改能够影响现存的程序, C# 在语言中支持版本修改. 对界面和方法重载的支持使得复杂的程序框架能随着时间发展和进化. 其他 .NET 中的异步, 泛型, 以及类型信息的使用显然要比目前的 Java 简单使用的多, 例如 .NET 异步只需要使用 Task 即可完成便捷而又高性能的异步操作. 而泛型则是 .NET 运行时就支持的功能, 在 Java 中, 它们仅仅是类型擦除罢了. 至于运行获取类型信息, 也较其他语言多. (不过就目前来讲, C# 的反射速度大概慢于 Java 不到十倍)</content></entry><entry><title>[.NET] 关于 .NET 动态链接库的目标与依赖问题</title><url>https://slimenull.top/post/dotnet-aboutdlldependency/</url><categories/><tags><tag>.NET</tag><tag>笔记</tag><tag>干货</tag></tags><content type="html"> 关于 .NET 类库的目标, 多目标, 类库依赖的各种问题, 例如 .NET Framework 项目使用 .NET Framework 类库和 .NET Standard 类库有何不同, 类库如何处理依赖, 以及为何类库不可以跨目标等问题
.NET Framework .NET Framework 运行在 Windows 平台上, 很多程序集例如 System.Drawing 都是集成在 .NET Framework 的, 如果你使用这个程序集, 则不必再为它添加依赖, 因为 .NET Framework 已经包含了它.
如果你在 .NET Framework 中使用一些目标为 .NET Standard 的类库, 那么你需要注意, .NET Standard 没有对 .NET Framework 的特定优化, 倘若这个类库依赖于其他的类库, 那么你需要添加依赖, 如果是诸如 System.Drawing 这类 .NET Framework 本身就内置的库, 你也需要重复的安装该依赖, 即便它们的功能是一样的, 但是它们是不同的程序集.
这告诉我们, 在编写类库时, 要尽可能的照顾到 .NET Framework 的特性, 如果你使用 .NET Framework 的类库, 记得在你的类库目标(Target)中添加 .NET Framework 的目标. 这样在使用 .NET Framework 内置的标准库时, 用户就不需要重复安装依赖了.
.NET Core .NET Core 是 .NET 的跨平台版本, 它与 .NET Framework 截然不同, 包括标准库都是不一样的, 如前面的例子, 如果想在 .NET Core 中使用 System.Drawing, 你必须在 nuget 中安装这个包.
.NET Core 使用 .NET Standard 的类库是安全的, 不需要顾及那么多, 因为 .NET Standard 只能使用 nuget 包, 而不能使用 .NET Framework 的类库. .NET Core 也是相同的, 所以无论这个 .NET Standard 的类库引用了什么依赖, 使用了这个类库的 .NET Core 程序也不会安装依赖.
.NET .NET, 也就是诸如 .NET5, .NET6 这类近来 .NET 重点发展方向, 它其实是基于 .NET Core 的, 你可以将它理解为 .NET Core 的新版本.
如何选择目标 在编写程序时, 如果你打算使他运行在 Windows 上, 那么请一定要选择 .NET Framework 的目标, 如果你打算使他运行在 Linux 上, 那么请一定要选择 .NET Core 的目标. (如果运行你软件的客户同样是开发者, 那么你可也可以使用 .NET Core 或者 .NET, 总之它们是跨平台, Windows 上也是可以运行的, 只不过普通用户可能不大会安装环境, 所以使用 .NET Framework 可以简化用户操作.)
在编写类库时, 尽可能多的支持多个目标, 一般至少包含 .NET Framework 和 .NET Standard 的目标.</content></entry><entry><title>C# WinForm Graphics 闪屏与双缓冲</title><url>https://slimenull.top/post/csharp-winformsplashanddoublebuffered/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>WinForm</tag><tag>笔记</tag></tags><content type="html"> 简单介绍 C# WinForm 实现双缓冲的方法以及一些代码示例
GDI+ 是 C# 常用的绘图库, .NET Framework 内置, 只需添加 System.Drawing 的引用即可, 而 .NET Core 也可以使用 System.Drawing.Common 的 nuget 包来安装此库.
Graphics 一般网上常用的 Graphics 使用方法, 都会告诉你, 去订阅 Paint 事件, 然后再 Paint 事件的事件参数中获取 Graphics 对象, 进行绘制.
控件是如何绘制的? Paint 事件是 WinForm 中, 每一个控件进行绘制时引发的事件, 例如控件添加到窗体上时, 会进行绘制, 当控件内容改变时, 会重绘, 或者当你的窗口大小调整并且边框影响到这个控件的时候, 控件也会重绘, 而只要是绘制, 就会引发 Paint 事件.
Paint 事件一般发生在控件自身的内容绘制完毕后, 例如反编译 Button 的基类 ButtonBase 可发现, OnPaint 方法中, 最先是绘制按钮的逻辑, 最后是引发 Paint 事件的逻辑.
所以, 如果用户订阅了 Paint 事件, 并在 Paint 事件中加入自己的绘图逻辑, 那么自己所绘制的内容就能持久的显示在控件上(因为控件每一次绘制都会引发 Paint).
OnPaint 方法是一个可重写的, 定义在 Control 类中的方法, 他的默认实现是引发 Paint 事件, 在其他控件中, 一般会重写这个方法, 然后加入绘制自身的逻辑, 最后调用 base.OnPaint 引发 Paint 事件
闪屏问题是如何引起的? 事实上, Windows 的窗口绘制还分为 PaintBackground 和 Paint, 它们分别对应 WM_ERASEBKGND 和 WM_PAINT 消息, 作用是绘制(擦除)背景和绘制内容.
WM_ERASEBKGND 和 WM_PAINT 是 Windows 消息, 消息处理是 Windows 窗口的核心组成部分, Windows 窗口的一切活动都依赖于能引发各种行为的 Windows 消息, 包括鼠标移动, 点击, 窗口大小调整, 布局改变等等
如果一个控件频繁的重绘, 那么这两个逻辑会不断的引发, 如果不擦除背景, 那么在第二次绘制的时候, 上一次的内容还存在于窗口, 那么就会出现显示上的一些错误. 而频繁的调用这两个方法, 就会造成内容擦除(绘制背景时所有内容被擦除), 内容绘制(绘制内容时, 新的内容显示出来).
所以, 内容的频繁擦除与绘制, 造成了视觉上的闪屏.
AllPaintingInWmPaint WinForm 中, 部分控件是不引发 PaintBackground 的, 这些控件将所有的绘图逻辑都在 Paint 中处理, 但是尽管如此, 闪屏问题其实还是存在的, 因为只不过是把擦除内容的逻辑放在了不同的地方, 背景擦除还是存在的.
脱离控件事件进行绘图 刚刚我们提到, 直接在 Paint 事件中加入绘图逻辑, 我们的绘图逻辑就会自动执行, 但是如果频繁的刷新, 就会有闪屏现象, 如何解决这个?
Windows 窗口本来就是分离了 PaintBackground 和 Paint 的, 所以, 这方面我们无法改变, 既然如此, 我们是否可以脱离控件的 Paint 事件, 而是交由我们自己去控制绘制逻辑呢? 没错, 可以.
每一个控件都有一个 CreateGraphics 方法, 调用这个方法, 我们就可以获取一个可以在该控件上进行绘图的 Graphics 对象, 同时你也可以使用 Graphics.FromHwnd(控件.Handle) 来获取一个控件的 Graphics, 两者是等价的.
既然有了 Graphics, 那么我们就可以进行绘制了, 可以尝试添加一个按钮, 然后在这个按钮的 Click 事件订阅者中添加在窗口中绘图的逻辑, 这样当点击按钮时, 你的绘图逻辑就被执行了.
使用计时器循环更新控件 现在, 我们可以主动向控件中绘制内容了, 不妨… 试试做一个图片序列播放器? 假设我一个很短的视频, 每一帧都转为了图片, 存在了一个目录中, 那么通过 Graphics, 我们也可以将他绘制出来.
通过计时器(Timer), 我们可以定时执行我们想执行的代码, 尝试做一个借助计时器的图片序列播放器吧
Graphics.DrawImage 可以在绘图区域中绘制一个图片
避免绘制的内容被清除 即使我们现在已经可以主动向控件中绘制, 但是 WinForm 自身的绘制逻辑仍会对我们绘制的内容产生影响, 例如内容被 PaintBackground 清空, 解决方案就是, 我们可以在 Paint 事件中也使用我们的绘图逻辑.
为了方便, 我建议将绘图逻辑封装为方法, 然后使用的时候调用它, 在 Paint 事件中也是调用这个绘图逻辑.
主动绘制时引起的闪屏 假若我们绘制的不是图片, 而是一些线条和图形, 那么会如何? 如果这些都是会改变位置的, 在下一次绘制时, 和上一次是不同的, 那么, 该怎么办?
前面所说的图片序列播放器说的是绘制图片, 在绘制下一张图片的时候, 我们只需要把新的图片绘制上去, 之前的内容就被覆盖掉了, 固然不会有什么问题, 但是如果我们绘制的是可变化的几何, 事情就不一样了.
因为绘制的内容会变动, 所以还用这种方法的话, 那么在第二次绘制的时候, 第一次绘制的内容还在窗口上, 就产生了重合… 我们应该在第二次绘制之前, 先清空我们绘制的内容, 对吧? 等等, 有些熟悉… 这不就是 WinForm 引起闪屏的原因???
不慌, 接着往下看.
双缓冲 既然清空内容然后绘制内容会引起闪屏, 那我们干脆不清空, 直接把新的内容覆盖上去, 岂不美哉? 但是… 新的内容从哪来? 答案就是双缓冲.
双缓冲意思就是在后台分配一个绘图区域, 绘制的时候在这个后台的绘图区域上绘制, 绘制完毕后再拷贝到前台界面上, 因为期间涉及到前台的界面和后台的绘图区, 所以被称为双缓冲.
WinForm 虽然自带双缓冲, 但是对于我们的绘制不会起到任何作用, 即便我们通过更改窗口的 DoubleBuffered 属性
Bitmap 如果你搜索双缓冲的话, 我相信, 大部分答案都是使用 Bitmap, 虽然这个方法并不是最好的方法, 但是还是介绍一下罢.
Bitmap, 位图, 我们可以创建一个 Bitmap, 大小和我们的控件相同, 然后在绘制的时候, 在这个 Bitmap 上绘制, 绘制完毕之后, 把这个 Bitmap 通过 DrawImage 的形式将他绘制到控件上, 覆盖原有内容, 这样就避免了闪屏问题.
Graphics.FromImage 可以通过一个图像来创建 Graphics 对象, 使用该对象将在对应图片上绘图.
使用 Bitmap 的话, 如果缓冲区的大小不改变, 也没有什么不妥, 但是如果你的绘制区域可能频繁的调整大小, 那么你的内存可能会哭唧唧
BufferedGraphics BufferedGraphics 正如其名, 是缓冲了的 Graphics, 其官方介绍是这么介绍的: &lsquo;为双缓冲提供图形缓冲区&rsquo;.
官方文档 BufferedGraphics 类 (System.Drawing) | Microsoft Docs
BufferedGraphics类没有公共构造函数, 并且必须 BufferedGraphicsContext 使用其方法为应用程序域创建 Allocate. 可以使用 BufferedGraphicsManager 从静态属性 Current 中检索当前应用程序域的 BufferedGraphicsContext.
// 要进行操作的 Graphics, 例如控件 Graphics Graphics g; // 要分配的 BufferedGraphics 大小 int Width, Height; BufferedGraphicsContext context = BufferedGraphicsManager.Current; BufferedGraphics bufferedG = context.Allocate(g, new Rectangle(0, 0, Width, Height)); // 此时, 创建完毕的 bufferedG 可供使用 使用 BufferedGraphics 的 Graphics 获取用来绘图的缓冲区, 绘制完毕后使用其 Render 方法将内容输出到目标 Graphics. 此时, 缓冲区内的内容就会一次性输出到目标 Grahpics.
// 已经分配好的 BufferedGraphics BufferedGraphics bufferedG; Graphics g = bufferedG.Graphics; g.FillRectangle(Brushes.Purple, new Rectangle(50, 50, 200, 200)); bufferedG.Render(); 另外, BufferedGraphics 的核心是 使用内存 DC, 并且使用 Bitblt 直接拷贝绘图区域, 比 DrawImage 快些, 这也是推荐使用 BufferedGraphics 的原因
拓展知识 重写 OnPaintBackground OnPaintBackground 是 Control 的一个保护的, 可重写的方法, 其内部逻辑是对控件背景进行绘制, 除此之外, 他还支持一些简单的透明背景. 如果我们既使用双缓冲, 又在 OnPaintBackground 书写我们的绘图逻辑, 那么闪屏问题将永远不会出现.
因为闪屏问题就是因为绘制背景时内容被擦除, 可是绘制背景的就是我们的代码逻辑, 而我们所绘制的背景正是所需要绘制的内容, 于是内容也将不可能被清除掉.
OnPaintBackground 只会进行背景绘制, 不会引发任何事件, 所以在重写的方法内, 我们可以放心的把 base.OnPaintBackground(pevent) 删除掉
保证缓冲区与控件尺寸一致 你可以在控件尺寸更改时, 重新分配缓冲区, 使用 SizeChanged 事件, 或者干脆重写 OnSizeChanged, 在 base.OnSizeChanged(e) 之前就把缓冲区重新分配好, 这样也方便管理些
代码示例 简单使用 BufferedGraphics 封装一个自带 BufferedGraphics 属性的控件(继承 Control), DoubleBufferedControlBase
using System; using System.Drawing; using System.Windows.Forms; namespace NullLib.TickAnimation.WinForm { public abstract class DoubleBufferedControlBase : Control { readonly BufferedGraphicsContext context; private BufferedGraphics bufferedGraphics; // 缓冲区保护且只读 protected BufferedGraphics BufferedGraphics { get => bufferedGraphics; } public DoubleBufferedControlBase() : base() { // 创建控件时即分配缓冲区 context = BufferedGraphicsManager.Current; bufferedGraphics = context.Allocate(Graphics.FromHwnd(Handle), new Rectangle(Point.Empty, Size)); } // 当改变尺寸, 重新分配缓冲区 protected override void OnSizeChanged(EventArgs e) { if (bufferedGraphics != null) bufferedGraphics.Dispose(); bufferedGraphics = context.Allocate(Graphics.FromHwnd(Handle), new Rectangle(Point.Empty, Size)); base.OnSizeChanged(e); } } } 使用双缓冲绘制的三阶贝塞尔曲线编辑器控件 CubicBezierView
using System; using System.Drawing; using System.Windows.Forms; namespace NullLib.TickAnimation.WinForm { // 贝塞尔曲线编辑器抽象基类 public abstract class BezierViewBase : DoubleBufferedControlBase { public bool ControlHandleEnabled { get => controlHandleEnabled; set { if (controlHandleEnabled == value) return; controlHandleEnabled = value; Invalidate(); // 当是否允许使用控制手柄值改变时, 立即重绘 (此操作同时也会在窗体设计器中显现出) } } public int ControlHandleSize { get; set; } = 20; // 控制点手柄的大小 public Brush ControlHandleBrush { get; set; } = new SolidBrush(Color.FromArgb(196, 125, 208)); // 控制点手柄所用笔刷 public Pen ControlHandleStickPen { get; set; } = new Pen(Color.FromArgb(196, 125, 208), 3); // 控制点手柄与其他点连线的笔 public Pen CurvePen { get; set; } = new Pen(Color.Black, 5); // 画曲线所用笔 private bool controlHandleEnabled; protected override void OnSizeChanged(EventArgs e) { base.OnSizeChanged(e); Invalidate(); // 当尺寸改变时, 应立即重绘以适应改动 (因为图形是适配控件大小的) } protected PointF GetControlPointFromPixelPoint(Point p) // 将控制点坐标转换为屏幕坐标 { return new PointF(p.X / (float)Width, 1 - p.Y / (float)Height); } protected Point GetPixelPointFromControlPoint(PointF p) // 将屏幕坐标转换为控制点坐标 { return new Point((int)(p.X * Width), Height - (int)(p.Y * Height)); } protected Rectangle GetRectangleFromCenterPoint(Point p, int r) // 通过一个中心点, 半径, 计算一个圆的外界矩形 (用来绕某点填充圆形) { return new Rectangle(p.X - r, p.Y - r, r * 2 + 1, r * 2 + 1); } } public class CubicBezierView : BezierViewBase { public PointF ControlPoint1 { get; set; } = new PointF(0.25f, 0.75f); public PointF ControlPoint2 { get; set; } = new PointF(0.75f, 0.25f); void PaintCore() { Graphics g = BufferedGraphics.Graphics; g.Clear(BackColor); g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias; Point startPoint = new Point(0, Height - 1); Point endPoint = new Point(Width - 1, 0); Point cp1 = GetPixelPointFromControlPoint(ControlPoint1); // 获取控制点1的屏幕坐标 Point cp2 = GetPixelPointFromControlPoint(ControlPoint2); // 获取控制点2的屏幕坐标 if (ControlHandleEnabled) { g.DrawLine(ControlHandleStickPen, startPoint, cp1); g.DrawLine(ControlHandleStickPen, endPoint, cp2); g.DrawBezier(CurvePen, startPoint, cp1, cp2, endPoint); Rectangle handleRect1 = GetRectangleFromCenterPoint(cp1, ControlHandleSize / 2), handleRect2 = GetRectangleFromCenterPoint(cp2, ControlHandleSize / 2); g.FillEllipse(ControlHandleBrush, handleRect1); g.FillEllipse(ControlHandleBrush, handleRect2); } else { g.DrawBezier(CurvePen, startPoint, cp1, cp2, endPoint); } BufferedGraphics.Render(); } protected override void OnPaintBackground(PaintEventArgs e) { PaintCore(); // 将背景绘制的逻辑改为自己的绘图逻辑 } bool cp1Captured, cp2Captured; protected override void OnMouseDown(MouseEventArgs e) // 判断是否点击了手柄 { if (ControlHandleEnabled) { Point cp1 = GetPixelPointFromControlPoint(ControlPoint1); Point cp2 = GetPixelPointFromControlPoint(ControlPoint2); Rectangle handleRect1 = GetRectangleFromCenterPoint(cp1, ControlHandleSize / 2), handleRect2 = GetRectangleFromCenterPoint(cp2, ControlHandleSize / 2); if (handleRect1.Contains(e.Location)) { cp1Captured = true; } else if (handleRect2.Contains(e.Location)) { cp2Captured = true; } } base.OnMouseDown(e); } protected override void OnMouseMove(MouseEventArgs e) { if (ControlHandleEnabled) // 如果开启了控制手柄 { if (ClientRectangle.Contains(e.Location)) // 如果鼠标还在控件范围内 { if (cp1Captured) // 如果在编辑第一个手柄 { ControlPoint1 = GetControlPointFromPixelPoint(e.Location); // 设置控制点位置 Invalidate(); } else if (cp2Captured) { ControlPoint2 = GetControlPointFromPixelPoint(e.Location); Invalidate(); } } } base.OnMouseMove(e); } protected override void OnMouseUp(MouseEventArgs e) { cp1Captured = cp2Captured = false; // 清除手柄调整状态 base.OnMouseUp(e); } } }</content></entry><entry><title>C++ 获取键盘状态与操作窗口</title><url>https://slimenull.top/post/cpp-keystateandwindow/</url><categories/><tags><tag>C++</tag><tag>Win32</tag><tag>笔记</tag><tag>教程</tag></tags><content type="html"> 通过一个简单的快捷键移动窗口项目介绍 C++ 获取键盘状态与操作窗口的方式
使用 Win API, 可以非常简单的获取当前键盘的按下状态, 或者对窗口的移动操作. 接下来是一个简单的小程序, 程序判断快捷键是否按下, 如果按下, 则执行移动窗口的操作.
下面的内容是完整的程序代码, 拼合起来是可执行的
include 使用标准输入输出流需要包含 iostream 使用 Win API 需要包含 Windows.h
#include&lt;iostream>#include&lt;Windows.h> cmdline.h 是一个简易的命令行解析库, 其 GitHub 项目地址为: github.com/tanakh/cmdline
在本文章末同时也会附上一份 Windows 可用的 cmdline.h 源文件
变量与常量定义 const char APPNAME[] = "Null.WindowMoving.Cpp"; // 应用程序名 const wchar_t APPNAME_W[] = L"Null.WindowMoving.Cpp"; // 对应宽字符串 bool hotkeyDown = false; // 存储热键是否按下 HWND currentWindow; // 存储当前活动窗口 int windowStartPointX, windowStartPointY; // 窗口的起始位置 int mouseStartPointX, mouseStartPointY; // 鼠标的起始位置 1 HANDLE app_mutex; // 用于实现单例的 Mutex 句柄 简易日志 在窗口简单的输出一些内容.
void logMsg(std::string msg) { SYSTEMTIME systm; // 系统时间 GetLocalTime(&amp;systm); // 获取系统时间 char szCurrentDateTime[] = "0000-00-00 00:00.00"; // 定义字符串 sprintf_s(szCurrentDateTime, "%4d-%2d-%2d %2d:%2d.%2d", // 格式化时间 systm.wYear, systm.wMonth, systm.wDay, systm.wHour, systm.wMinute, systm.wSecond); std::cout &lt;&lt; szCurrentDateTime &lt;&lt; " @ " &lt;&lt; msg &lt;&lt; std::endl; // 输出内容 } 程序初始化 Mutex 可以用来实现进程单例, 使用 CreateMutex 函数创建一个命名了的 Mutex, 并使用 GetLastError 来检查是否已经存在同名 Mutex, 若存在则表示已经运行了一个进程, 当前进程退出即可.
/// &lt;summary> /// 初始化程序 /// &lt;/summary> /// &lt;returns>是否初始化成功&lt;/returns> bool initApp(int argc, char* argv[]) { std::cout &lt;&lt; "Null.WindowMoving" &lt;&lt; std::endl; app_mutex = CreateMutex(NULL, true, APPNAME_W); // 尝试创建 Mutex if (GetLastError() == ERROR_ALREADY_EXISTS) // 如果已经存在 Mutex, 即已经有程序存在 { logMsg("instance is already running"); return false; } return true; } 判断快捷键 通过 GetAsyncKeyState 可以获取一个按键的物理状态, 通过这个来判断快捷键是否按下.
void testHostkey() { bool valueBefore = hotkeyDown; // 保存旧值 hotkeyDown = (GetAsyncKeyState(VK_LWIN) &amp; GetAsyncKeyState(VK_LSHIFT)) != 0; // 判断是否同时按下左 Win 和左 Shift if (hotkeyDown != valueBefore) // 如果值变更了 { if (hotkeyDown) // 如果按下了快捷键 { currentWindow = GetForegroundWindow(); // 获取当前前台窗口 POINT mouseP; // 鼠标坐标 RECT rect; // 窗口边界 if (GetCursorPos(&amp;mouseP) &amp;&amp; GetWindowRect(currentWindow, &amp;rect)) // 获取鼠标坐标及窗口边界 { mouseStartPointX = mouseP.x; // 保存获取的信息 mouseStartPointY = mouseP.y; windowStartPointX = rect.left; windowStartPointY = rect.top; logMsg("hotkey down"); } else { hotkeyDown = false; // 获取失败, 则记为快捷键未按下 logMsg("hotkey down, but failed to get cursor position or window rect"); } } else { logMsg("hotkey up"); } } } 窗口移动 SetWindowPos 可以用来设置窗口的位置, 并且通过 flags 的指定来规定他的具体行为.
void processWindowMoving() { if (hotkeyDown) // 如果按下快捷键 { POINT currentMousePoint; // 当前鼠标坐标 GetCursorPos(&amp;currentMousePoint); // 获取当前鼠标坐标 int offsetX = currentMousePoint.x - mouseStartPointX, // 计算鼠标相对初始位置的偏移量 offsetY = currentMousePoint.y - mouseStartPointY; if (GetForegroundWindow() == currentWindow) { POINT newWindowPoint = { windowStartPointX + offsetX, windowStartPointY + offsetY }; // 计算新的窗口位置 SetWindowPos(currentWindow, 0, windowStartPointX + offsetX, windowStartPointY + offsetY, -1, -1, SWP_NOSIZE | SWP_NOOWNERZORDER | SWP_DEFERERASE | SWP_NOREDRAW | SWP_NOSENDCHANGING); // 设置窗口位置 } else { hotkeyDown = false; logMsg("foreground window changed, hotkeyDown changed to 'false'"); } } } 循环处理 程序需要不断的判断快捷键, 并且移动窗口, 所以需要有一个主循环
void loopProcessing() { while (true) // 循环判断快捷键以及处理窗口移动 { testHostkey(); processWindowMoving(); Sleep(1); // sleep 1 防止 CPU 占用过高 } } 入口点 入口点中, 初始化程序, 如果初始化失败, 则返回 -1, 如果成功就执行主循环.
int main(int argc, char* argv[]) { if (!initApp(argc, argv)) return -1; loopProcessing(); }</content></entry><entry><title>PHP 的安装概述</title><url>https://slimenull.top/post/php-install/</url><categories/><tags><tag>PHP</tag><tag>教程</tag><tag>笔记</tag></tags><content type="html"> 基本介绍 PHP 在 Windows 中的安装, 配置, 以及基本使用
下载 php 并解压到任意安装目录 设置环境变量 PHPRC 为安装目录 下载 在 Windows 中, php 是不需要安装的, 直接下载并解压到任意安装目录即可
配置文件 php.ini 是 php 的配置文件, 默认 php 会在系统中寻找, C:\Windows, 但是通过设置 PHPRC 环境变量, 可以使 php 从指定的目录加载 php 文件 默认 php.ini 文件是不存在的, 但是 php 提供了默认的 php.ini-development 和 php.ini-production, 它们分别是用于开发和发布的 php 配置文件, 用户只需要拷贝它们并重命名为 php.ini 即可直接使用
php.ini 内指定了哪些插件是启用的, 默认提供的配置文件中已经写好了这些, 并注释掉了. 用户只需要取消注释对应内容即可.
事实上, 如果 php 不加载配置文件, 也是可以运行的
环境变量 PHPRC 环境变量的值需要是 php 的安装目录, 该目录下应存在 php 的可执行文件以及 php 的配置文件 php.ini (如果没有, 则在系统中寻找)</content></entry><entry><title>[C#] 在 WinForm 中实现过渡动画</title><url>https://slimenull.top/post/csharp-winformtransformanim/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>WinForm</tag></tags><content type="html"> 使用 NullLib.TickAnimation 在 WinForm 中实现过渡动画, 数字值, 点, 尺寸, 矩形区域, 或者是颜色
NullLib.TickAnimation 用于实现对一个对象的属性(Property), 以指定的计时函数, 在一定时间内从一个值, 平滑的过渡到另一个值. NullLib.TickAnimation.Drawing 基于 NullLib.TickAnimation, 并提供了关于绘画类型的过渡动画, 例如 点, 尺寸, 矩形区域, 颜色
例如你可以使用它将一个 WinForm 窗体的 Bounds 从一个值过渡到另一个值以实现窗体位置与尺寸的过渡动画. 下面是一个简单示例:
快速开始 首先, 创建一个 WinForm 项目用于测试, 向主窗体中添加一个按钮, 并为按钮的点击事件添加事件处理器
在解决方案管理器中右击项目, 选择 &ldquo;管理 nuget 程序包&rdquo;, 然后安装 NullLib.TickAnimation.Drawing (它会自动安装依赖项 NullLib.TickAnimation)
转到主窗体的代码, 在 using 部分添加 using NullLib.TickAnimation, 这样我们就可以直接使用关于动画的一些类了
编辑刚刚添加的按钮的点击事件处理器代码, 添加以下内容:
Rectangle workingArea = Screen.PrimaryScreen.WorkingArea; // 获取主屏幕的工作区矩形 DrawingTickAnimator animator = new DrawingTickAnimator(new SineTicker(), this, nameof(Bounds)); // 创建动画控制器实例 animator.SetPropertySetter((setAction) => Invoke(setAction)); // 解决窗体程序的跨线程资源访问问题 animator.SetTickDelay(1); // 在每一帧后进行 1ms 的延时 animator.Animate(workingArea, 200); // 进行动画, 时间是 200ms 运行程序, 点击按钮, 查看效果
本库已在 GitHub 开源, github.com/SlimeNull/NullLib.TickAnimation
基本原理 在 NullLib.TickAnimator 中, ITickAnimator 是最基本的, 用于运行动画的接口, 它依赖于 ITicker 来提供计时函数, ITIcker 可表示运动曲线, 不同的类有不同的特征, 例如使用 BackTicker 的 ITickAnimator 进行动画时将具有回弹效果, 使用 BounceTicker 的 ITickAnimator 进行动画时将具有弹跳效果.
其中的技术细节, 可参考 CSS3 过渡中的 timing-function, WPF 窗体程序中的 EasingFunction. 另外, 也推荐对贝塞尔曲线作基本了解, 这样, 你可以通过库中提供的 CubicBezierTicker 来创建自定义的三次贝塞尔曲线计时函数, 进而实现自定义动画效果.
推荐的在线三次贝塞尔曲线编辑工具: Cubic-Bezier
类型 - ITicker ITicker 是动画计时函数, 它分为两种, 贝塞尔曲线函数以及原生函数, 其中贝塞尔曲线是可以由用户指定控制点从而控制曲线形状的, 原生函数是一些定义好的, 遵循 ITicker 接口的函数
贝塞尔曲线函数: 分两种, 三次贝塞尔曲线(CubicBezierTicker)与二次贝塞尔曲线(QuadraticBezierTicker), 你可以手动指定控制点, 也可以使用默认提供的一些曲线, 例如 Ease, EaseIn, EaseOut, EaseInOut, InSine, OutSine 等.
指定 EaseInOut 的方式是: 指定 CubicBezierCurve.Ease 与 EasingMode.EaseInOut, 同理, 指定 InOutBack 的方式是: CubicBezierCurve.Back 与 EasingMode.EaseInOut, 需要知道的是, 这些曲线都是源自于 CSS3 内置曲线(Ease, EaseIn, EaseOut, EaseInOut, Linear) 以及 Microsoft Edge 浏览器调试工具中的预设曲线(InSIne, OutSine, InOutSine, InBack, OutBack, &hellip;&hellip;)
原生函数: 它们都是从 WPF 中移植过来的, 例如 BounceTicker, 它来自 WPF 中的 BounceEase, 并且与它算法完全一致, 关于它们的使用, 我建议查阅 WPF 动画缓动函数的相关文档.
最简单的, 使用 BackTicker 函数就是直接实例化一个对象, 在这里需要提到的是, 关于 BackTicker 实例的属性默认值也是与 WPF 一致的, 虽然 BackTicker 和 CubicBezierCurve.Back 都是表示带有回弹效果的曲线, 但是两者并不相等, 贝塞尔曲线函数和原生函数是截然不同的.
关于 ITicker 的更多信息, 我建议查阅源码, 或者在 Visual Studio 中使用对象浏览器概览所有类型.
- ITickAnimator ITickAnimator 是驱动动画的最主要的类, 默认包含的 TickAnimator 中支持 double float int 三种数字类型的动画处理, 它其中还包括了对于动画同时进行时的中断处理, 当然, 如果你要使用针对于绘画的动画处理, 例如点, 尺寸, 矩形区域, 颜色这类, 可以使用 DrawingTickAnimator (nuget包: NullLib.TickAnimator.Drawing, 命名空间: NullLib.TickAnimator)
TickAnimator 的动画处理中包含这样一点: 当一个动画还未结束就启动另一个动画, 那么第一个动画会自动停止以保证不会造成冲突, 这是因为一个 TickAnimator 应该针对于唯一一个属性, 但针对同一个属性的两个动画同时启动, 将会造成严重的冲突问题. (这里需要提一下, 如果你要同时对一个控件进行位置过渡和尺寸过渡, 我不推荐你为 Location 和 Size 属性分别创建一个 ITickAnimator 实例, WinForm 的内部实现问题仍然会导致冲突, 更安全的做法是为 Bounds 属性创建 ITickAnimator 并且使用针对 Rectangle 的过渡)
- TickAnimationProc TickAnimationProc 是 NullLib.TickAnimation 中对于动画驱动的最核心部分, 它提供了最为基本的动画实现方式, 通过指定 ITicker(计时函数), Fucn&lt;double, T>(tick picker用于从动画进度中取得对应类型的值), TimeSpan(动画的时间间隔), Func&lt;T, bool>(动画每一帧的回调函数, 返回值表示动画是否应该继续进行), 这四个参数来运行最基本的动画. 但是一般的不推荐使用这个, 因为其中没有像 TickAnimator 的互斥措施.
- TickAnimatorBase TickAnimator 的基类, 其中包含了 TickAnimator 基础功能的实现, 例如对于值过渡的方法封装
自定义类型 如果你要自定义 ITicker 实现类或者 ITickAnimator 实现类, 则需要遵守下面的一些规范:
对于 ITicker 的实现, 必须保证对于方法 CalcTick(double x), x 从 0 到 1 时, 返回值也是从 0 到 1, 即: CalcTick(0) 应该返回 0, CalcTick(1) 应该返回 1.
并且, 如果你要创建更高阶的贝塞尔曲线函数, 建议继承 BezierTickerBase, 如果你要创建一些遵循 WPF 原生过渡函数规则的自定义函数, 必须继承 FuncTickerBase 并在字类中重写 CalcInTick(double x) 方法.
对于 ITickAnimator 的实现, 推荐的方式是直接继承 TickAnimator, 并且在实现 Animate 和 SyncAnimate 方法时, 应该通过调用 TickAnimatorBase 的 Animate 和 SyncAnimate 方法来实现动画, 而获取对应属性的当前值, 不应该使用 prop.GetValue 方法, 而是使用 TickAnimatorBase 的 GetPropertyValue 方法. 下面是 TickAnimator 中 double 的动画实现:
public Task Animate(float start, float end, int dur) { double diff = end - start; return Animate((t) => (float)(start + diff * t), TimeSpan.FromMilliseconds(dur)); // 内部调用基类 TickAnimatorBase 的方法 } public Task Animate(double end, int dur) => Animate(GetPropertyValue&lt;double>(), end, dur); // 从当前值开始执行动画, 按照规 public ITickAnimator&lt;double> SyncAnimate(double start, double end, int dur) // 范, 使用 GetPropertyValue 方法 { double diff = end - start; SyncAnimate((t) => (double)(start + diff * t), TimeSpan.FromMilliseconds(dur)); // SyncAnimate 也一样 return this; } public ITickAnimator&lt;double> SyncAnimate(double end, int dur) => SyncAnimate(GetPropertyValue&lt;double>(), end, dur); // 一致</content></entry><entry><title>[Web] JS MouseDown 事件与判断鼠标是否在某个元素中</title><url>https://slimenull.top/post/web-testmouseinelement/</url><categories/><tags><tag>Web</tag><tag>JavaScript</tag></tags><content type="html"> 监听全局鼠标按下事件, 并通过判断对应元素是否包含 e.target 来实现检查鼠标是否在某个元素内
创建事件监听器: 对于创建全局的事件监听器(EventListener), 我们可以使用 document 对象.
document.addEventListener("mousedown", function(e){ // e 参数为鼠标按下的事件, 具体有什么成员, 可以在浏览器调试器里面直接 console.log(e) 查看 // 这里写逻辑代码 }); 判断鼠标是否位于某个元素上: 对于事件监听器中的事件参数, 有一个 path 包含了鼠标事件的路径, 第一个元素为点击的最内层元素, 最后一个元素则是 window, 倒数第二个是 document. 并且, 还有一个成员 target 表示触发事件的最内层元素, 与 path 的第一个元素相同.
一个 DOM 节点, 可以通过其 contains 方法来判断它是否包含一个元素, 也就是判断这个元素是否位于它自己内部, 如果这个元素是它自己, 同样是返回 true
document.addEventListener("mousedown", function(e){ // 例如我们要判断鼠标是否点击了 div#mydiv let ele = document.querySelector("div#mydiv"); let inele = ele.contains(e.target); console.log(inele ? "点击了 div#mydiv" : "没有点击 div#mydiv"); }); 另一种方式 还有另外一种比较麻烦的方法, 就是去判断这个鼠标的位置是否在元素显示区域的内部, 这个的话, 我可以明确的告诉你, 很多时候行不通&hellip; 网上虽然有很多示例代码, 但是这种方法有很大局限性, 例如你是一个 fixed 元素套了一个 absolute 元素, 你还得去进行大量的运算, 有时候还根本算不出来, 所以使用上面的通过 DOM 节点去判断是否包含, 最为妥当</content></entry><entry><title>[C#] 使用 NAudio 实现音频可视化</title><url>https://slimenull.top/post/csharp-audiovisualizer/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>NAudio</tag><tag>音频</tag><tag>笔记</tag></tags><content type="html"> 捕捉声卡输出, 处理采样, 进行傅里叶变换, 将数据作为曲线绘制在窗口上.
预览: 最初版本:更新: 捕捉声卡输出: 实现音频可视化, 第一步就是获得音频采样, 这里我们选择使用计算机正在播放的音频作为采样源进行处理:
NAudio 中, 可以借助 WasapiLoopbackCapture 来进行捕捉:
WasapiLoopbackCapture cap = new WasapiLoopbackCapture(); cap.DataAvailable += (sender, e) => // 录制数据可用时触发此事件, 参数中包含音频数据 { float[] allSamples = Enumerable // 提取数据中的采样 .Range(0, e.BytesRecorded / 4) // 除以四是因为, 缓冲区内每 4 个字节构成一个浮点数, 一个浮点数是一个采样 .Select(i => BitConverter.ToSingle(e.Buffer, i * 4)) // 转换为 float .ToArray(); // 转换为数组 // 获取采样后, 在这里进行详细处理 } cap.StartRecording(); // 开始录制 分离左右通道: 获取完采样后, 我们还需要对采样进行一点小处理, 因为捕获的数据是分通道的, 一般是左右声道:
// 设定我们已经将刚刚的采样保存到了变量 AllSamples 中, 类型为 float[] int channelCount = cap.WaveFormat.Channels; // WasapiLoopbackCapture 的 WaveFormat 指定了当前声音的波形格式, 其中包含就通道数 float[][] channelSamples = Enumerable .Range(0, channelCount) .Select(channel => Enumerable .Range(0, AllSamples.Length / channelCount) .Select(i => AllSamples[channel + i * channelCount]) .ToArray()) .ToArray(); 取通道平均值 将采样分为一个个通道的采样后, 我们可以将其合并, 取平均值, 以便于绘制:
// 设定我们已经将分开了的采样保存到了变量 ChannelSamples 中, 类型为 float[][] // 例如通道数为2, 那么左声道的采样为 ChannelSamples[0], 右声道为 ChannelSamples[1] float[] averageSamples = Enumerable .Range(0, AllSamples.Length / channelCount) .Select(index => Enumerable .Range(0, channelCount) .Select(channel => ChannelSamples[channel][index]) .Average()) .ToArray(); 绘制时域图象: 处理刚刚的采样后, 你可以直接将其作为数据绘制到窗口中, 这即是时域图象, 这里使用最简单的折线绘制.
// 设定 g 为窗口的 Graphics 对象, windowHeight 为窗口的显示区域高度 // 设定通道采样平均值为 AverageSamples, 类型为 float[] Point[] points = AverageSamples .Select((v, i) => new Point(i, windowHeight - v)) .ToArray(); // 将数据转换为一个个的坐标点 g.DrawLines(Pens.Black, points); // 连接这些点, 画线 傅里叶变换: NAudio 中还提供了快速傅里叶变换的方法, 通过傅里叶变换, 可以将时域数据转换为频域数据, 也就是我们所说的频谱
// 我们将对 AverageSamples 进行傅里叶变换, 得到一个复数数组 // 因为对于快速傅里叶变换算法, 需要数据长度为 2 的 n 次方, 这里进行 float log = Math.Ceiling(Math.Log(AverageSamples.Length, 2)); // 取对数并向上取整 int newLen = (int)Math.Pow(2, log); // 计算新长度 float[] filledSamples = new float[newLen]; Array.Copy(AverageSamples, filledSamples, AverageSamples.Length); // 拷贝到新数组 Complex[] complexSrc = filledSamples .Select(v => new Complex(){ X = v }) // 将采样转换为复数 .ToArray(); FastFourierTransform(false, log, complexSrc); // 进行傅里叶变换 // 变换之后, complexSrc 则已经被处理过, 其中存储了频域信息 分析频域信息: 对于傅里叶变换的频域信息, 需要稍加处理才可以方便的使用, 首先是提取有用的信息:
// NAudio 的傅里叶变换结果中, 似乎不存在直流分量(这使我们的处理更加方便了), 但它也是有共轭什么的(也就是数据左右对称, 只有一半是有用的) // 仍然使用刚刚的 complexSrc 作为变换结果, 它的类型是 Complex[] Complex[] halfData = complexSrc .Take(complexSrc.Length / 2) .ToArray(); // 一半的数据 float[] dftData = halfData .Select(v => Math.Sqrt(v.X * v.X + v.Y * v.Y)) // 取复数的模 .ToArray(); // 将复数结果转换为我们所需要的频率幅度 // 其实, 到这里你完全可以把这些数据绘制到窗口上, 这已经算是频域图象了, 但是对于音乐可视化来讲, 某些频率的数据我们完全不需要 // 例如 10000Hz 的频率, 我们完全没必要去绘制它, 取 最小频率 ~ 2500Hz 足矣 // 对于变换结果, 每两个数据之间所差的频率计算公式为 采样率/采样数, 那么我们要取的个数也可以由 2500 / (采样率 / 采样数) 来得出 int count = 2500 / (cap.WaveFormat.SampleRate / filledSamples.Length); float[] finalData = dftData.Take(count).ToArray(); 绘制频域图象: 得到上面分析后的 finalData 后, 我们就可以直接绘制出来了, 这次使用柔和的曲线绘制
// 设定 g 为窗口的 Graphics 对象, height 为窗口高度 PointF[] points = finalData .Select((v, i) => new PointF(i, height - v)) .ToArray(); g.DrawCurve(Pens.Purple, points); // Graphics 可以直接绘制曲线 更优的绘制: 上面的时域和频域图象, 我们都是一股脑的将数据的索引作为 X 坐标, 窗口高度减去数据值作为 Y 坐标, 有两个突出的问题:
数据可能无法填满窗口的宽度或者超出窗口的宽度范围 数据太大时, 也会导致绘制的线条超出窗口高度 第一个问题好解决, 直接使索引所占数据长度的百分比恰好等于 X 坐标相对于窗口宽度的百分比即可: $$ x = index \div dataLength * windowWidth $$ 对于第二个问题, 有两个解决方案, 一是直接为数据加权重, 例如统一乘 0.5, 使数据减小一节, 二就是套一个函数, 例如 log 函数, 毕竟 log 函数在较高自变量的情况下, 因变量的变化趋势越来越小, 我们只需要对这个 log 函数进行稍加处理, 就可以直接应用到数据变换数据上, 使其不超出窗口绘图区域
另外, 我们也可以平滑频谱显示(指动画变换), 它的原理大概是这样:
例如这次进行傅里叶变换的结果是: {0, 100, 50},
下一次傅里叶变换的结果是: {100, 0, 0},
可以得出, 增量为: {100, -100, -50},
在更新变换结果时, 我们不再直接将新的结果替换旧的结果, 而是在旧的结果的基础上, 加上增量×权重
例如权重是 0.5 时, 那么实际增量是: {50, -50, -25},
那么实际新的值是: {50, 50, 25},
如果下一次变换的结果还是 {100, 0, 0}, 那我们再次从 {50, 50, 25} 向新值逼近, 权重仍然是 0.5, 那么实际增量是: {25, -25, -12.5},
注意到了吗? 这次的增量是上次增量的一半, 这正好是一个减速运动, 而且新值与旧值的差越大, 变化的就越快, 而它们会不断重合, 因而速度不断变慢, 形成减速运动的频谱图.
更多内容: 更多关于 NAudio 的使用, 可以看这篇文章: [C#] NAudio 的各种常见使用方式 播放 录制 转码 音频可视化
项目已开源: 关于本文章涉及的大部分内容, 均在 github.com/SlimeNull/AudioTest
仓库中的 Null.AudioVisualizer 项目中有写. (注释妥当了)
其实音频可视化我老早就想做了, 但是本人数学不是非常的好, 不过最后总算是坚持下来了, 弄出来了啊, 心情老激动了
求个赞, 求个评论~</content></entry><entry><title>音频, 采样, 采样率, 样本大小, 样本编码</title><url>https://slimenull.top/post/sth-aboutaudio/</url><categories/><tags><tag>音频</tag><tag>基础</tag></tags><content type="html"> 音波: 首先是初中物理知识, 声音是物体的振动造成的, 所以从时间上看, 这个物体的位置不断变动, 下面这个图象, 就是音波了
采样: 因为计算机无法存储整个音波, 只能存储音波上一个个的点, 而这一个个的点, 就是采样:
采样率: 采样率就是采样的密集程度, 如果太过密集, 那么占用的存储空间就会大很多, 但如果采样率小了, 那么这些采样与原波形的形状就有所不同了.
样本大小: 样本大小表示计算机应该用多大的存储空间来存储一个样本, 有 8bit, 16bit, 32bit, 常用的是 16bit 和32bit, 样本大小还决定了这个样本能表示的值的范围, 例如 16 bit 的样本只能表示 -32768 到 32767 之间的整数, 如果音频的某个部分超出了这个范围, 那么显然这个采样就不精准了, 如下图, 波峰处就出现了误差.
样本编码 样本编码指计算机用什么样的格式来存储这个样本, 对于 8bit, 16bit 的样本, 一般是用整数, 对于 32bit 的样本, 则是用浮点数更多.</content></entry><entry><title>[C#] NAudio 各种常见使用方式 播放 录制 转码 音频可视化</title><url>https://slimenull.top/post/csharp-naudio/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>NAudio</tag><tag>音频</tag></tags><content type="html"> 这绝对是非常清晰的, 关于 NAudio 使用方式的中文文章
概述 在 NAudio 中, 常用类型有 WaveIn, WaveOut, WaveStream, WaveFileWriter, WaveFileReader, AudioFileReader 以及接口: IWaveProvider, ISampleProvider, IWaveIn, IWavePlayer
WaveIn 表示波形输入, 继承了 IWaveIn, 例如麦克风输入, 或者计算机正在播放的音频流. WaveOut 表示波形输出, 继承了 IWavePlayer, 用来播放波形音乐, 以 IWaveProvider 作为播放源播放音频, 通过拓展方法也支持以 ISampleProvider 作为播放源播放音频 WaveStream 表示波形流, 它继承了 IWaveProvider, 可以用来作为播放源. WaveFileReader 继承了 WaveStream, 用来读取波形文件 WaveFileWriter 继承了Stream, 用来写入文件, 常用于保存音频录制的数据. AudioFileReader 通用的音频文件读取器, 可以读取波形文件, 也可以读取其他类型的音频文件例如 Aiff, MP3 IWaveProvider 波形提供者, 上面已经提到, 是音频播放的提供者, 通过拓展方法可以转换为 ISampleProvider ISampleProvider 采样提供者, 上面已经提到, 通过拓展方法可以作为 WaveOut 的播放源 播放音频 常用的播放音频方式有两种, 播放波形音乐, 以及播放 MP3 音乐
播放波形音乐:
// NAudio 中, 通过 WaveFileReader 来读取波形数据, 在实例化时, 你可以指定文件名或者是输入流, 这意味着你可以读取内存流中的音频数据 // 但是需要注意的是, 不可以读取来自网络流的音频, 因为网络流不可以进行 Seek 操作. // 此处, 假设 ms 为一个 MemoryStream, 内存有音频数据. WaveFileReader reader = new WaveFileReader(ms); WaveOut wout = new WaveOut(); wout.Init(reader); // 通过 IWaveProvider 为音频输出初始化 wout.Play(); // 至此, wout 将从指定的 reader 中提供的数据进行播放 播放 MP3 音乐:
// 播放 MP3 音乐其实与播放波形音乐没有太大区别, 只不过将 WaveFileReader 换成了 Mp3FileReader 罢了 // 另外, 也可以使用通用的 Reader, MediaFoundationReader, 它既可以读取波形音乐, 也可以读取 MP3 // 此处, 假设 ms 为一个 MemoryStream, 内存有音频数据. Mp3FileReader reader = new Mp3FileReader(ms); WaveOut wout = new WaveOut(); wout.Init(reader); wout.Play(); 音频录制 录制麦克风输入
// 借助 WaveIn 类, 我们可以轻易的捕获麦克风输入, 在每一次录制到数据时, 将数据写入到文件或其他流, 这就实现了保存录音 // 在保存波形文件时需要借助 WaveFileWriter, 当然, 如果你想保存为其他格式, 也可以使用其它的 Writer, 例如 CurWaveFileWriter 以及 // AiffFileWriter, 美中不足的是没有直接写入到 MP3 的 FileWriter // 需要注意的是, 如果你是用的桌面程序, 那么你可以直接使用 WaveIn, 其回调基于 Windows 消息, 所以无法在控制台应用中使用 WaveIn // 如果要在控制台应用中实现录音, 只需要使用 WaveInEvent, 它的回调基于事件而不是 Windows 消息, 所以可以通用 WaveIn cap = new WaveIn(); // cap, capture WaveFileWriter writer = new WaveFileWriter(); cap.DataAvailable += (s, args) => writer.Write(args.Buffer, 0, args.BytesRecorded); // 订阅事件 cap.StartRecording(); // 开始录制 // 结束录制时: cap.StopRecording(); // 停止录制 writer.Close(); // 关闭 FileWriter, 保存数据 // 另外, 除了使用 WaveIn, 你还可以使用 WasapiCapture, 它与 WaveIn 的使用方式是一致的, 可以用来录制麦克风 // Wasapi 全称 Windows Audio Session Application Programming Interface (Windows音频会话应用编程接口) // 具体 WaveIn, WaveInEvent, WasapiCapture 的性能, 笔者还没有测试过, 但估计不会有太大差异. // 提示: WasapiCapture 和 WasapiLoopbackCapture 位于 NAudio.Wave 命名空间下 录制声卡输出
// 录制声卡输出, 也就是录制计算机正在播放的声音, 借助 WasapiLoopbackCapture 即可简单实现, 使用方式与 WasapiCapture 无异 WasapiLoopbackCapture cap = new WasapiLoopbackCapture(); WaveFileWriter writer = new WaveFileWriter(); cap.DataAvailable += (s, args) => writer.Write(args.Buffer, 0, args.BytesRecorded); cap.StartRecording(); 高级应用 获取计算机实时播放音量大小
// 其实这个是基于刚刚的录制声卡输出的, 录制时的回调中, Buffer, BytesRecorded 指定了此次录制的数据 (缓冲区和数据长度) // 而这些数据, 其实是计算机对声音的采样(Sample), 具体的采样格式可以查看 WasapiLoopbackCapture 实例的 WaveForamt // 波形格式中的 Encoding 与 BitsPerSample 是我们所需要的. 一般默认的 Encoding 是 IeeeFloat, 也就是每一个采样都是 // 一个浮点数, 而 BitsPerSample 也就是 32 了. 通过 BitConverter.ToSingle() 我们可以从缓冲区中取得浮点数 // 遍历, 每 32 位一个浮点数, 最终取最大值, 这就是我们所需要的音量了 float volume; WasapiLoopbackCapture cap = new WasapiLoopbackCapture(); cap.DataAvailable += (s, args) => volume = Enumerable .Range(0, args.BytesRecorded / 4) // 每一个采样的位置 .Select(i => BitConverter.ToSingle(args.Buffer, i * 4)) // 获取每一个采样 .Aggregate((v1, v2) => v1 > v2 ? v1 : v2); // 找到值最大的采样 实现音乐可视化
// 既然我们已经知道了, 那些数据都是一个个的采样, 自然也可以通过它们来绘制频谱, 只需要进行快速傅里叶变换即可 // 而且有意思的是, NAudio 也为我们准备好了快速傅里叶变换的方法, 位于 NAudio.Dsp 命名空间下 // 提示: 进行傅里叶变换所需要的复数(Complex)类也位于 NAudio.Dsp 命名空间, 它有两个字段, X(实部) 与 Y(虚部) // 下面给出在 IeeeFloat 格式下的音乐可视化的简单示例: WasapiLoopbackCapture cap = new WasapiLoopbackCapture(); cap.DataAvailable += (s, args) => { float[] samples = Enumerable .Range(0, args.BytesRecorded / 4) .Select(i => BitConverter.ToSingle(args.Buffer, i * 4)) .ToArray(); // 获取采样 int log = (int)Math.Ceiling(Math.Log(samples.Length, 2)); float[] filledSamples = new float[(int)Math.Pow(2, log)]; Array.Copy(samples, filledSamples, samples.Length); // 填充数据 int sampleRate = (s as WasapiLoopbackCapture).WaveFormat.SampleRate; // 获取采样率 Complex[] complexSrc = filledSamples.Select(v => new Complex(){ X = v }).ToArray(); // 转换为复数 FastFourierTransform.FFT(false, log, complexSrc); // 进行傅里叶变换 double[] result = complexSrc.Select(v => Math.Sqrt(v.X * v.X + v.Y * v.Y)).ToArray(); // 取得结果 }; 音频格式转换
// 对于 Wave, CueWave, Aiff, 这些格式都有其对应的 FileWriter, 我们可以直接调用其 Writer 的 Create***File 来 // 从 IWaveProvider 创建对应格式的文件. 对于 MP3 这类没有 FileWriter 的格式, 可以调用 MediaFoundationEncoder // 例如一个文件, "./Disconnected.mp3", 我们要将它转换为 wav 格式, 只需要使用下面的代码, CurWave 与 Aiff 同理 using (Mp3FileReader reader = new Mp3FileReader("./Disconnected.mp3")) WaveFileWriter.CreateWaveFile("./Disconnected.wav", reader); // 从 IWaveProvider 创建 MP3 文件, 假如一个 WaveFileReader 为 src MediaFoundationEncoder.EncodeToMp3(src, "./NewMp3.mp3"); 提示 对于刚刚所说的音频录制, 采样的格式有一点需要注意, 将数据转换为一个 float 数组后, 其中还需要区分音频通道, 例如一般音乐是双通道, WaveFormat 的 Channel 为 2, 那么在 float 数组中, 每两个采样为一组, 一组采样中每一个采样都是一个通道在当前时间内的采样.
以双通道距离, 下图中, 采样数据中每一个圆圈都表示一个 float 值, 那么每两个采样时间点相同, 而各个通道的采样就是每一组中每一个采样
所以对于我们刚刚进行的音乐可视化, 严格意义上来讲, 还需要区分通道
对于采样的大小, BitsPerSample, 可以是 8, 16, 32, 其中 8 和 16 都是整数存储采样, 32 是浮点数存储采样.
另外, 对于音乐可视化部分的傅里叶变换结果, 我们只需要其中一部分, 取前 256 个足矣. (我也不知道它这个运算结果是如何分布的)
示例 本文提到的部分内容在 github.com/SlimeNull/AudioTest
仓库中有示例, 例如音频可视化, 音频录制, 以及其他零星的示例
如有错误, 还请指出</content></entry><entry><title>在 Y 分钟内学会 Python</title><url>https://slimenull.top/post/man-learnpythoninyminutes/</url><categories/><tags><tag>Python</tag><tag>教程</tag></tags><content type="html"> 快速学习 Python. 本文是翻译文章, 没有对原文进行过多的更改
这是翻译, 原文地址: Learn Python in Y Minutes
在 90 年代初, Python 由 Guido van Rossum 创造, 现在, 它是最受欢迎的编程语言之一. 因其简明的语法, 我爱上了它. 语法基本上是可以执行的伪代码.
提示: 这篇文章适用于 Python 3, 如果你想要学习旧版 Python 2.7, 单击这里
# 单行注释以 '#' 作为开头 """多行注释可以使用三个双引号 并且经常用与书写文档 """ #################################################### ## 1. 原始数据类型和操作符 #################################################### # 你可以使用数字 3 # 等同于 3 # 数学运算也是你希望使用的形式 1 + 1 # 结果是 2 8 - 1 # 结果是 7 10 * 2 # 结果是 20 35 / 5 # 结果是 7.0 # 正负数的整除都会向下取整 5 // 3 # 结果是 1 -5 // 3 # 结果是 -2 5.0 // 3.0 # 结果是 1.0 # 在浮点运算中也同样生效 -5.0 // 3.0 # 结果是 -2.0 # 除法的运算结果始终是浮点数 10.0 / 3 # 结果是 3.3333333333333335 # 取模运算 7 % 3 # 结果是 1 # i % j 结果的符号与 j 相同, 这与 C 语言不同 -7 % 3 # 结果是 2 # 幂运算 (x**y, x的y次方) 2 ** 3 # 结果是 8 # 用括号来强制优先运算 1 + 3 * 2 # 结果是 7 (1 + 3) * 2 # 结果是 8 # 布尔值是基本数据类型 True # 值为 真(true) False # 值为 假(false) # 使用 not 来进行非运算 not True # 结果是 假 not False # 结果是 真 # 布尔值操作符: # 提示, 'and' 和 'or' 是区分大小写的 True and False # 结果是 假 False or True # 结果是 真 # True 和 False 事实上也等同于 1 和 0, 只不过是使用了不同的关键字 True + True # 结果是 2 True * 8 # 结果是 8 False - 5 # 结果是 -5 # 比较运算符会检查 True 和 False 的数字值 0 == False # 结果是 真 1 == True # 结果是 真 2 == True # 结果是 假 -5 != False # 结果是 真 # 对整数使用布尔逻辑操作符, 则会将它们转换为布尔值以求值，但返回未转换的值 # 不要把 bool(ints) 和 位运算 and/or 搞混了 bool(0) # 返回 假 bool(4) # 返回 真 bool(-6) # 返回 真 0 and 2 # 返回 0 -5 or 0 # 返回 -5 # 运算符 '等同于' 是 == 1 == 1 # 返回 真 2 == 1 # 返回 假 # 运算符 '不等于' 是 != 1 != 1 # 返回 假 2 != 1 # 返回 真 # 更多比较运算符 1 &lt; 10 # 返回 真 1 > 10 # 返回 假 2 &lt;= 2 # 返回真 2 >= 2 # 返回真 # 检查一个值是否在指定范围内 1 &lt; 2 and 2 &lt; 3 # 返回 真 1 &lt; 3 and 3 &lt; 2 # 返回 假 # 连接起来, 这样看起来会更好看些 1 &lt; 2 &lt; 3 # 返回 真 2 &lt; 3 &lt; 2 # 返回 假 # (is 与 ==) is 将会检查两个变量是否引用了同一个对象, 但是 == 检查 # 两个对象是否指向了相同的值 a = [1, 2, 3, 4] # 使 a 指向一个新的列表, [1, 2, 3, 4] b = a # 使 b 指向 a 所指向的对象 b is a # 返回 真, a 和 b 引用的是同一个对象 b == a # 返回 真, a 和 b 的对象是相等的 b = [1, 2, 3, 4] # 使 b 指向一个新的列表, [1, 2, 3, 4] b is a # 返回 假, a 与 b 并不引用同一个对象 b == a # 返回 真, a 和 b 的对象使相等的 # 字符串可以使用 双引号 " 或 单引号 ' 来创建 "这是一个字符串" '这也是一个字符串' # 字符串可以相加 "Hello " + "world!" # 返回 "Hello world!" "Hello " "world!" # 等同于 "Hello world!" # 字符串可以用作一个字符列表 "Hello world!"[0] # 返回 'H' # 你可以获取字符串的长度: len("这是一个字符串") # 返回 7 # 你可以使用 f-字符串 或 格式化字符串 来对字符串文本进行格式化 (在 Python 3.6 或更高版本) name = "小红" f"她说她的名字是{name}." # 返回 "她说她的名字是小红." # 你可以基本的将 Python 表达式放到括号内, 然后它就会被输出到字符串中. f"{name}是{len(name)}字符长." # 返回 "小红是两个字符长" # None 是一个对象 None # 返回 None # 不要使用等同于运算符 '==' 来比较对象和 None # 使用 'is' 来代替. 这个会检查对象标识是否相同. "etc" is None # 返回 假 None is None # 返回 真 # None, 0, 以及空的字符串/列表/字典/元组, 都计算为 假 bool(0) # => 假 bool('') # => 假 bool([]) # => 假 bool({}) # => 假 bool(()) # => 假 #################################################### ## 2. 变量和集合 #################################################### # Python 有一个 print 函数, 用于标准输出 print("我是Python, 很高兴见到你!") # => 我是Python, 很高兴见到你! # 默认的, print 函数还会在结尾输出一个换行符 # 使用可选参数 'end' 来改变末尾的字符串. print("Hello, world", end="!") # => Hello, world! # 输出后没有换行 # 从控制台获取输入数据的简单方式: input_string_var = input("Enter some data:") # 以字符串的形式返回输入数据 # Python 中没有变量的声明, 只有赋值. # 命名规范是使用小写以及下划线, 就像这样: lower_case_with_underscores some_var = 5 some_var # => 5 # 访问一个没有生命的变量是错误的 # 查看控制流来获取更多异常捕捉信息 some_unknown_var # 这是一个一个未定义的变量, 运行时将抛出 NameError 异常 # if 也可用作一个表达式 # 等同于 C 语言中的 '?:' 三元运算符 "yay" if 0 > 1 else "nay!" # => "nay" # 列表可以存储一个序列, 可以这样定义: li = [] # 你可以为其指定初始值 other_li = [4, 5, 6] # 使用 append 方法在列表的末尾添加一些什么东西 li.append(1) # 现在 li 的值是 [1] li.append(2) # 现在 li 的值是 [1, 2] li.append(4) # 现在 li 的值是 [1, 2, 4] li.append(3) # 现在 li 的值是 [1, 2, 4, 3] # 使用 pop 方法从列表的末尾移除元素 li.pop() # 返回 3, 并且现在 li 的值是 [1, 2, 4] # 重新将它放回去 li.append(3) # 现在 li 又变成 [1, 2, 4, 3] 了 # 像访问数组一样访问一个列表 li[0] # => 1 # 访问列表的最后一个元素 li[-1] # => 3 # 如果索引超出界限, 那么会抛出 IndexError 异常 li[4] # 抛出 IndexError 异常 # 你可以使用切片语法来查看一个范围内的元素 # 起始索引包含在内, 但结束索引不包含在内 # (对于数学类型来讲, 它是一个 闭/开 区间) li[1:3] # 返回从索引1到3的一个列表 => [2, 4] li[2:] # 返回从索引2开始的列表 => [4, 3] li[:3] # 返回从开始到索引3的列表 => [1, 2, 4] li[::2] # 返回一个每两个元素选择一个的列表 => [1, 4] li[::-1] # 返回反向排列的列表 => [3, 4, 2, 1] # 使用任意组合来实现高级切片 # li[起始:结束:步长] # 使用切片来创建一个单层的深度拷贝 li2 = li[:] # 使用 "del" 来删除任意元素 del li[2] # 现在 li 的值是 [1, 2, 3] # 删除第一个匹配值的元素 li.remove(2) # 现在 li 的值是 [1, 3] li.remove(2) # 抛出 ValueError 异常, 2 并不在这个列表中 # 在指定索引处插入元素, 列表.insert(索引, 元素) li.insert(1, 2) # 现在 li 的值又是 [1, 2, 3] 了 # 获取第一个匹配元素的索引 li.index(2) # => 1 li.index(4) # 抛出 ValueError 异常, 4 不在这个列表中 # 你可以将列表相加 # 提示: values 和 other_li 的值不会被修改 li + other_li # => [1, 2, 3, 4, 5, 6] # 使用 "extend()" 连接列表, extend 的意思是拓展 li.extend(other_li) # 现在 li 的值是 [1, 2, 3, 4, 5, 6] # 使用 "in" 检查元素是否存在于列表中 1 in li # => True # 使用 "len()" 检查列表的长度 len(li) # => 6 # 元组与列表相像, 但是不可更改 tup = (1, 2, 3) tup[0] # => 1 tup[0] = 3 # 抛出一个 TypeError # 提示, 长度为一的元组的最后一个元素必须有一个逗号跟随, 但是 # 其他长度的元组, 尽管是0, 也不需要 type((1)) # => &lt;class 'int'> type((1,)) # => &lt;class 'tuple'> type(()) # => &lt;class 'tuple'> # 大多数的列表操作符都可以在元组上使用 len(tup) # => 3 tup + (4, 5, 6) # => (1, 2, 3, 4, 5, 6) tup[:2] # => (1, 2) 2 in tup # => True # 你可以将元组(或者列表)解包为变量 a, b, c = (1, 2, 3) # 现在, a 是 1, b 是 2, c 是 3 # 你还可以使用拓展解包 a, *b, c = (1, 2, 3, 4) # 现在, a 是 1, b 是 [2, 3], c 是 4 # 默认情况下, 即便你忽略括号, 也会创建一个元组 d, e, f = 4, 5, 6 # 元组 4, 5, 6 被解包为变量 d, e, f # 变量值分别如下: d = 4, e = 5 以及 f = 6 # 那么看看交换两个值是多么的简单 e, d = d, e # 字典用于存储从键到值的映射 empty_dict = {} # 创建了一个空字典 # 下面是一个带有初始值的字典 filled_dict = {"one": 1, "two": 2, "three": 3} # 提示: 字典的键必须是不可变的类型. 这是为了确保 # 键能够转换为用于快速查询的常量哈希值. # 不可变类型包含整数, 浮点数, 字符串, 元组 invalid_dict = {[1, 2, 3]: "123"} # 抛出 TypeError: unhashable type: 'list' 异常. (类型错误: 无法进行哈希化的类型: '列表') valid_dict = {(1, 2, 3): [1, 2, 3]} # 然而, 值可以是任何类型 # 使用 [] 来查询值 filled_dict["one"] # => 1 # 使用 "keys()" 来获取所有的键并作为一个可迭代对象返回. 我们需要在 list() 中将调用结果转换 # 为一个列表. 这个稍后再讲. 提示 - 在 Python 低于 3.7 的版本中 # 字典键索引的顺序是无法保证的. 你的结果可能不与下面的例子完全相等. 然而, 在 Python 3.7 中, 字典 # 元素会保持它们被插入到字典的顺序 list(filled_dict.keys()) # => ["three", "two", "one"] 在低于 3.7 的 Python 版本中 list(filled_dict.keys()) # => ["one", "two", "three"] 在 3.7 或更高的 Python 版本中 # 使用 "values()" 来获取所有的值并作为可迭代对象返回. 同样, 我们需要将其在 # list() 中转换, 以取出这个可迭代对象的值. 提示 - 和上面键的顺序是一样的 list(filled_dict.values()) # => [3, 2, 1] 在低于 3.7 的 Python 版本中 list(filled_dict.values()) # => [1, 2, 3] 在 3.7 或更高的 Python 版本中 # 使用 "in" 来检查键是否在字典中 "one" in filled_dict # => True 1 in filled_dict # => False # 通过不存在的键来查找字典, 会抛出 KeyError 异常 filled_dict["four"] # KeyError # 使用 "get()" 方法来避免 KeyError 异常 filled_dict.get("one") # => 1 filled_dict.get("four") # => None # 这个方法支持当找不到值时返回指定的默认值 filled_dict.get("one", 4) # => 1 filled_dict.get("four", 4) # => 4 # "setdefault()" 只有在给定键不存在的时候将值插入到字典 filled_dict.setdefault("five", 5) # filled_dict["five"] 被设置为了 5 filled_dict.setdefault("five", 6) # filled_dict["five"] 仍然是 5 # 向字典中添加内容 filled_dict.update({"four": 4}) # => {"one": 1, "two": 2, "three": 3, "four": 4} filled_dict["four"] = 4 # 向字典中添加的另一种方式 # 自 Python 3.5 以来, 你还可以使用拓展解包选项 {'a': 1, **{'b': 2}} # => {'a': 1, 'b': 2} {'a': 1, **{'a': 2}} # => {'a': 2} # 集合用来存储 ... 额, 集合 empty_set = set() # 空集合 # 用一组值来初始化一个集合, 嗯, 看起来有点像字典, 抱歉 some_set = {1, 1, 2, 2, 3, 4} # some_set 现在的值是 {1, 2, 3, 4} # 与字典中的键相似, 集合的元素必须是不可变的 invalid_set = {[1], 1} # => 抛出一个 TypeError: unhashable type: 'list' (类型错误: 无法进行哈希化的类型: '列表') valid_set = {(1,), 1} # 向集合中添加一个或多个条目 filled_set = some_set filled_set.add(5) # filled_set 现在是 {1, 2, 3, 4, 5} # 集合是不包含重复元素的 filled_set.add(5) # 还是与之前一样 {1, 2, 3, 4, 5} # 使用 &amp; 取交集 other_set = {3, 4, 5, 6} filled_set &amp; other_set # => {3, 4, 5} # 使用 | 取并集 filled_set | other_set # => {1, 2, 3, 4, 5, 6} # 使用 - 取差集 {1, 2, 3, 4} - {2, 3, 5} # => {1, 4} # 使用 ^ 取对称差集 {1, 2, 3, 4} - {2, 3, 5} # => {1, 4, 5} # 检查左侧的集合是否是右侧集合的超集 {1, 2} >= {1, 2, 3} # => False # 检查左侧的集合是否是右侧集合的子集 {1, 2} &lt;= {1, 2, 3} # => True # 使用 in 来检查是否存在于集合中 2 in filled_set # => True 10 in filled_set # => False # 生成一个单层的深层副本 filled_set = some_set.copy() # filled_set 是 {1, 2, 3, 4, 5} filled_set is some_set # => False #################################################### ## 3. 控制流和可迭代对象 #################################################### # 首先我们声明一个变量 some_var = 5 # 这是一个 if 语句, 缩进在 Python 中非常重要 # 约定语法是使用四个空格, 而不是水平制表符(tab) # 这个将会打印 "some_var 比 10 小" if some_var > 10: print("some_var 比 10 大") elif some_var &lt; 10: # 这个 elif 语句是可选的 print("some_var 比 10 小") else: # 这个也是可选的 print("some_var 与 10 相等") """ for 语句用来循环遍历列表 将会打印: 狗是哺乳动物 猫是哺乳动物 老鼠是哺乳动物 """ for animal in ["狗", "猫", "老鼠"]: # 你可以使用 format() 来插入格式化字符串 print("{}是哺乳动物".format(animal)) """ "range(数字)" 返回一个数字的可迭代对象 从0到给定数字 将会打印: 0 1 2 3 """ for i in range(4): print(i) """ "range(较小的数, 较大的数)" 返回一个数字的可迭代对象 从较小的数字到较大的数字 将会打印: 4 5 6 7 """ for i in range(4, 8): print(i) """ "range(较小的数, 较大的数, 步长)" 返回一个数字的可迭代对象 从较小的数到较大的数, 以步长未每次增长的值 如果步长没有指定, 默认值则是 1 将会打印: 4 6 """ for i in range(4, 8, 2): print(i) """ 循环一个列表, 并且同时检索列表中每一个条目的索引和值 将会打印: 0 狗 1 猫 2 老鼠 """ animals = ["狗", "猫", "老鼠"] for i, value in enumerate(animals): print(i, value) """ while 循环将一直进行到条件不再满足为止 将会打印: 0 1 2 3 """ x = 0 while x &lt; 4: print(x) x += 1 # x = x + 1 的简写 # 使用 try/except 语句块来处理异常 try: # 使用 "raise" 来抛出异常 raise IndexError("这是一个索引错误") except IndexError as e: pass # pass 只是一个占位符(不进行任何操作). 通常你需要在这里对异常进行处理 except (TypeError, NameError): pass # 如果需要, 你可以同时处理多个异常. else: # try/except 语句块的可选语句. 必须在所有 except 语句块的后面 print("一切正常!") # 仅在 try 语句内没有任何异常时运行 finally: # 在任何情况下都会执行 print("我们可以在这里进行资源清理") # 你可以使用 with 语句代替 try/finally 来清理资源 with open("我的文件.txt") as f: for line in f: print(line) # 向文件中写入内容 contents = {"aa": 12, "bb": 21} with open("我的文件1.txt", "w+") as file: file.write(str(content)) # 向文件中写入字符串 with open("我的文件2.txt", "w+") as file: file.write(json.dumps(content)) # 向文件中写入一个对象 # 从文件中读取 with open("我的文件1.txt", "r+") as file: contents = file.read() # 从文件中读取一个字符串 print(contents) # 打印: {"aa", 12, "bb": 21} with open("我的文件2.txt", "r+") as file: contents = json.load(file) # 从文件中读取一个json对象 print(contents) # print: {"aa": 12, "bb": 21} # Python 提供了一个叫做 Iterable(可迭代的) 的基本抽象 # 一个可迭代对象是一个可视为序列的对象 # range 函数返回的对象就是一个可迭代对象 filled_dict = {"one": 1, "two": 2, "three": 3} our_iterable = filled_dict.keys() print(our_iterable) # => dict_keys(['one', 'two', 'three']). 这是一个实现了 Iterable 接口的对象 # 我们可以检索它 for i in our_iterable: print(i) # 打印 one, two, three # 然而, 我们不可以通过索引来找到元素 our_iterable[1] # 抛出 TypeError 异常 # 一个可迭代对象即为能够创建迭代器的对象 our_iterator = iter(our_iterable) # 迭代器是一个能够记住当前通过它迭代状态的对象 # 我们可以通过 "next()" 来获取下一个对象 next(our_iterator) # => "one" # 它会保持我们遍历的状态 next(our_iterator) # => "two" next(our_iterator) # => "three" # 在迭代器已经返回完所有的数据后, 将会抛出 StopIteration 异常 next(our_iterator) # 抛出 StopIteration 异常 # 我们也可以检索它, 事实上, "for" 语句就是隐式的执行了这个操作 our_iterator = iter(our_iterable) for i in iterator: print(i) # 你可以通过调用 list() 来获取可迭代对象或迭代器的所有元素. list(our_iterable) # => 返回 ["one", "two", "three"] list(our_iterator) # => 返回 [] 因为迭代状态已经被保存下来 #################################################### ## 4. 函数 #################################################### # 使用 "def" 来创建一个新的函数 def add(x, y): print("x 是 {}以及 y is {}".format(x, y)) return x + y # 调用带参数的函数 add(5, 6) # => 输出 "x 是 5 以及 y 是 6", 并返回 11 # 调用函数的另一种方式是带有关键字参数 add(y=6, x=5) # 关键字参数可以在任何顺序下正常运行 # 你可以定义接受数量可变的位置参数的函数 def varargs(*args): return args varargs(1, 2, 3) # => (1, 2, 3) # 同样, 你可以定义接受数量可变的关键字参数的函数 def keyword_args(**kwargs): return kwargs # 来调用一下, 然后看看会发生什么 keyword_args(big="foot", loch="ness") # => {"big": "foot", "loch": "ness"} # 只要你想, 你也可以同时使用它们两个 def all_the_args(*args, **kwargs): print(args) print(kwargs) """ all_the_args(1, 2, a=3, b=4) 将会打印: (1, 2) {"a": 3, "b": 4} """ # 在调用函数时, 你可以做相反的 args/kwargs! # 使用 * 来拓展元组, 以及使用 ** 来拓展 kwargs. args = (1, 2, 3, 4) kwargs = {"a": 3, "b": 4} all_the_args(*args) # 等同于 all_the_args(1, 2, 3, 4) all_the_args(**kwargs) # 等同于 all_the_args(a=3, b=4) all_the_args(*args, **kwargs) # 等同于 all_the_args(1, 2, 3, 4, a=3, b=4) # 返回多个值(通过赋值元组) def swap(x, y): return y, x # 通过没有括号的元组来返回多个值 # (提示: 括号虽然没有写, 但是也可以添加上) x = 1 y = 2 x, y = swap(x, y) # => x = 2, y = 1 # (x, y) = swap(x,y) # 同样, 括号虽没有写, 但是也可以添加上 # 函数作用域 x = 5 def set_x(num): # 局部变量 x 与全局变量 x 是不同的 x = num # => 43 print(x) # => 43 def set_global_x(num): global x print(x) # => 5 x = num # => 全局变量 x 现在被设置为 6 了 print(x) # => 6 set_x(43) set_global_x(6) # Python 支持本地函数 def create_adder(x): def adder(y): return x + y return adder add_10 = create_adder(10) add_10(3) # => 13 # 也支持匿名函数 (lambda x: x > 2)(3) # => True (lambda x, y: x ** 2 + y ** 2)(2, 1) # => 5 # 下面是一些内置的高阶函数 list(map(add_10, [1, 2, 3])) # => [11, 12, 13] list(map(max, [1, 2, 3], [4, 2, 1])) # => [4, 2, 3] list(filter(lambda x: x > 5, [3, 4, 5, 6, 7])) # => [6, 7] # 你可以使用列表推导式来实现优秀的映射与过滤 # 列表推导式存储可嵌套的列表以输出 [add_10(i) for i in [1, 2, 3]] # => [11, 12, 13] [x for x in [3, 4, 5, 6, 7] if x > 5] # => [6, 7] # 同样, 你可以构建集合和字典推导式 {x for x in 'abcddeef' if x not in 'abc'} # => {'d', 'e', 'f'} {x: x ** 2 for x in range(5)} # => {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} #################################################### ## 5. 模块 #################################################### # 导入模块, 调用模块中的函数 import math print(math.sqrt(16)) # => 返回4.0 # 你可以从模块中获取指定的函数 from math import ceil, floor print(ceil(3.7)) # => 4.0 print(floor(4.7)) # => 3.0 # 你可以从模块中导入所有函数 # 警告: 不推荐这么做 from math import * # 你可以在导入模块时, 为其起一个别名 import math as m math.sqrt(16) == m.sqrt(16) # => True # Python 模块只是普通的 Python 文件. 你 # 可以编写你自己的模块, 然后导入它们. 模块 # 的名字与文件名是相同的 # 你可以查找模块内定义的函数和属性 import math dir(math) # 如果有一个名为 math.py 的 Python 脚本与 # 当前脚本在同一个目录下, 那么这个文件将会 # 代替 Python 内建模块以加载. # 这是因为本地目录有比 Python 的内建库更高 # 的优先级. #################################################### ## 6. 类 #################################################### # 使用 "class" 语句来创建一个类 class Human: # 类的属性. 将在类的所有实例中共享 species = "SlimeNull" # 基本的初始化器, 这个将会在类实例化时调用 # 提示, 双前置和后置下划线表示 Python 使用 # 的对象或属性, 但是它们存在于用户控制的命名 # 空间. 方法(或者是对象, 属性) 像 __init__, __str__, # __repr__ 等等, 被称为特殊方法(有时也成为魔法方法) # 你不应该创建你自己的, 与它们重名的成员 def __init__(self, name): # 将参数赋值给实例的 name 属性 self.name = name # 初始化属性 self._age = 0 # 实例的方法. 所有的方法都需要使用 "self" 作为第一个参数 def say(self, msg): print("{name}: {message}".format(name=self.name, message=msg)) # 实例的另一个方法 def sing(self): return '哟... 哟... 麦克风检查... one... one two...' # 类的方法, 所有的实例都能够访问 # 它们被调用时, 调用它的类将作为调用的第一个参数 @classmethod def get_species(cls): return cls.species; # 静态方法在调用时, 不会有类或实例的引用传入 @staticmethod def grunt(): return "*咕噜咕噜*" # 属性就像一个获取器(getter) # 它将这个方法 age() 作为一个同名的, 只读的属性返回 # 但是, 在 Python 中不需要写繁琐的获取器和设置器(setter) @property def age(self): return self._age # 这个将允许属性被设置 @age.setter def age(self, age): self._age = age # 这个将允许属性被删除 @age.deleter def age(self): del self._age # 当 Python 解释器读取源文件并执行时 # __name__ 会确保这个代码块在模块中 # 是作为主程序执行的 if __name__ == '__main__': # 实例化类 i = Human(name="小明") i.say("嗨~") j = Human("小红") j.say("你好哇~") # i 和 j 是类型 Human 的实例, 换句话说, 他们都是 Human 对象 # 调用类的方法 i.say(i.get_species()) # => "小明: SlimeNull" # 更改共享属性 Human.species = "Little Wu♂ Fairy" i.say(i.get_species()) # => "小明: Little Wu♂ Fairy" j.say(j.get_species()) # => "小红: Little Wu♂ Fairy" # 调用静态方法 print(Human.grunt()) # => "*咕噜咕噜*" # 静态方法也可以通过实例来调用 print(i.grunt()) # => "*咕噜咕噜*" # 为这个实例更新属性 i.age = 42 # 获取属性 i.say(i.age) # => "小明: 42" j.say(j.age) # => "小红: 0" # 删除属性 del i.age # i.age # => 将会抛出 AttributeError 异常 #################################################### ## 6.1 继承 #################################################### # 继承允许定义的新的子类从父类继承 # 方法与变量 # 使用上面定义的 Human 类作为基类(父类), 我们可以定义 # 一个子类, Superhero, 它将继承 Human 类的变量, 例如 # "species", "name", 以及 "age", 方法也是如此, 例如 # "sing" 与 "grunt". 但同时它也可以有自己的特殊属性. # 你可以将上面的类存储到它们自己的文件中来采用模块化文件的优点 # 命名为, human.py # 从别的文件中导入函数, 需要使用下面的格式 # from "没有后缀的文件名" import "函数或者类" from human import Human # 在类型定义处以参数的形式指定父类 class Superhero(Human): # 如果字类仅仅是从父类继承所有定义, 且没有 # 任何更改, 你可以只在这里写一个 "pass" 关键字 (别的不需要写) # 但在我们这种情况下, pass 就要被注释掉以为 Superhero 类创建 # 它特有的内容 # pass # 字类可以覆盖父类的属性 species = "Superhuman" # 字类会自动的从父类继承构造函数, 包括 # 它的参数, 但是也可以定义另外的参数, 或者定义 # 然后覆盖它的方法, 例如这个类的构造函数 # 这个构造函数从 Human 类继承了 "name" 参数并且 # 添加了 "superpower" 和 "movie" 参数 def __init__(self, name, movie=False, superpowers = ["力大无穷", "金刚不坏之身"]): # 添加额外的类型属性 self.fictional = True self.movie = movie # 注意可变的默认值, 因为它们默认是共享的 self.superpowers = superpowers # "super" 函数使你可以访问被字类重写了的 # 父类的方法, 在这里, 我们要使用 "__init__" # 这将会调用父类的构造函数 super().__init__(name) # 覆盖 sing 方法 def sing(self): return "Dun, dun, DUN!" # 添加附加的实例方法 def boast(self): for power in self.superpowers: print("我有{pow}的能力!".format(pow=power)) if __name__ == '__main__': sup = Superhero(name="蒂克") # 实例类型检查 if isinstance(sup, Human): print("我是人类") if type(sup) is Superhero: print("我是一个超级英雄") # 通过使用 getattr() 和 super() 来获取方法解析搜索顺序 # 这个属性是动态的, 并且可以被更新 print(Superhero.__mro__) # => (&lt;class '__main__.Superhero'>, # => &lt;class 'human.Human'>, &lt;class 'object'>) # 通过它自己的类型属性来调用父类的方法 print(sup.get_species()) # => Superhuman # 调用被重写了的方法 print(sup.sing()) # => Dun, dun, DUN! # 调用 Human 的方法 sup.say("勺子?") # => 蒂克: 勺子? # 调用仅存在于 Superhero 中的方法 sup.boast() # => 我有力大无穷的能力! # => 我有金刚不坏之身的能力! # 继承的类型属性 sup.age = 32 print(sup.age) # => 32 # 仅在 Superhero 中存在的属性 print('我能获得奥斯卡奖吗?' + str(sup.movie)) #################################################### ## 6.2 多重继承 #################################################### # 另一个类的定义 # bat.py class Bat: species = '贝蒂' def __init__(self, can_fly=True): self.fly = can_fly # 这个类也有一个说的方法 def say(self, msg): msg = '... ... ...' return msg # 并且它也有自己的方法 def sonar(self): return '))) ... (((' if __name__ == '__main__': b = Bat() print(b.say('你好')) print(b.fly) # 然后现在另一个类型定义继承自 Superhero 和 Bat # superhero.py from superhero import Superhero from bat import Bat # 定义 Batman 并同时继承 Superhero 和 Bat class Batman(Superhero, Bat): def __init__(self, *args, **kwargs): # 继承属性通常需要 super # super(Batman, self).__init__(*args, **kwargs) # 然而在这里处理多继承, 所以 super() # 仅仅适用于 MRO 列表的下一个基类 # 所以, 我们需要为所有父类显式的调用 __init__ # *args 和 **kwargs 允许使用非常简洁的方式传递所有参数, # 每一个父类都 "给洋葱剥一层皮" Superhero.__init__(self, 'anonymous', movie=True, superpowers=['Wealthy'], *args, **kwargs) Bat.__init__(self, *args, can_fly=False, **kwargs) # 覆盖相同名称的属性的值 self.name = "悲伤的阿弗莱克" def sing(self): return "呐 呐 呐 呐 呐 蝙蝠侠!" if __name__ == '__main__': sup = Batman() # 通过使用 getattr() 和 super() 来获取方法解析搜索顺序 # 这个属性是动态的, 并且可以被更新 print(Batman.__mro__) # => (&lt;class '__main__.Batman'>, # => &lt;class 'superhero.Superhero'>, # => &lt;class 'human.Human'>, # => &lt;class 'bat.Bat'>, &lt;class 'object'>) # 通过它自己的类型属性来调用父类的方法 print(sup.get_species()) # => Superhuman # 调用被重写了的方法 print(sup.sing()) # => 呐 呐 呐 呐 呐 蝙蝠侠! # 调用 Human 的方法, 原因是继承问题 sup.say('我同意') # => 悲伤的阿弗莱克: 我同意 # 调用存在于第二个祖先的方法 print(sup.sonar()) # => ))) ... ((( # 继承了的类型属性 sup.age = 100 print(sup.age) # => 100 # 从第二个祖先继承的默认值被重写了的属性 print('我能飞吗?' + str(sup.fly)) # => 我能飞吗? 不能 #################################################### ## 7. 高级 #################################################### # 生成器可以帮助你写一些更简便的代码 (偷懒) def double_numbers(iterable): for i in iterable: yield i + i # 生成器是 高效内存 的, 因为它们只加载需要的数据 # 处理可迭代对象的下一个值, 这使他们可以在非常大 # 的值域上执行操作. # 提示: `range` 在 Python3 中取代了 `xrange` for i in double_numbers(range(1, 900000000)): # `range` 是一个生成器 print(i) if (i > 30): break # 就像你能创建列表推导式一样, 你也可以创建 # 生成器推导式 values = (-x for x in [1,2,3,4,5]) for x in values: print(x) # 打印 -1 -2 -3 -4 -5 到 控制台/终端 # 你也可以将生成器推导式转换为一个列表 values = (-x for x in [1,2,3,4,5]) gen_to_list = list(values) print(gen_to_list) # => [-1, -2, -3, -4, -5] # 装饰器 # 在这个例子中, `beg` 与 `say` 交换. 如果 say_please 是 True, 那么它 # 将会改变返回的消息 from functools import wraps def beg(target_function): @wraps(target_function) def wrapper(*args, **kwargs): msg, say_please = target_function(*args, **kwargs) if say_please: return "{}{}".format(msg, "求你了, 我很穷 :(") return msg return wrapper @beg def say(say_please=False): msg = "能为我买瓶啤酒吗?" return msg, say_please print(say()) # 能为我买瓶啤酒吗? print(say(say_please=True)) # 能为我买瓶啤酒吗? 求你了, 我很穷 :(</content></entry><entry><title>[Web] 25行 CSS 代码实现轮播图</title><url>https://slimenull.top/post/web-simplecarousel/</url><categories/><tags><tag>HTML</tag><tag>CSS</tag><tag>JS</tag><tag>笔记</tag></tags><content type="html"> 不是最漂亮但是一定简单的通用轮播图示例
效果 准备好的几张图片, 它们的路径是: &ldquo;img/1.jpg&rdquo;, &ldquo;img/2.jpg&rdquo;, &ldquo;img/3.jpg&rdquo;, &ldquo;img/4.jpg&rdquo;, &ldquo;img/5.jpg&rdquo;, &ldquo;img/6.jpg&rdquo;
代码 最基本的 HTML 代码:
&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Test&lt;/title> &lt;link rel="stylesheet" href="css/index.css" /> &lt;!--引入样式表--> &lt;script src="js/index.js">&lt;/script> &lt;!--引入JS脚本, 脚本用来切换图--> &lt;/head> &lt;body> &lt;div id="test" class="slider"> &lt;img id="img1" src="img/1.jpg" class="current"> &lt;img id="img2" src="img/2.jpg"> &lt;img id="img3" src="img/3.jpg"> &lt;/div> &lt;button onclick="setCurrent(0)">1&lt;/button> &lt;!--在这里, onClick调用的是用于设置当前图片的方法, 传入参数为图片节点的索引--> &lt;button onclick="setCurrent(1)">2&lt;/button> &lt;button onclick="setCurrent(2)">3&lt;/button> &lt;button onclick="setCurrent(3)">4&lt;/button> &lt;button onclick="setCurrent(4)">5&lt;/button> &lt;button onclick="setCurrent(5)">6&lt;/button> &lt;/body> &lt;/html> 引入的样式表:
.slider { /* 指定轮播图容器尺寸, 相对定位, 隐藏溢出内容 */ width: 750px; height: 450px; position: relative; overflow: hidden; } .slider img { /* 指定每一个图片的尺寸, 过渡时间, 绝对定位 */ width: 100%; height: 100%; transition: all 0.5s; position: absolute; } .slider img { /* 指定所有图片水平位移-100% */ transform: translateX(-100%); } .slider img.current { /* 指定带有current类的图片不进行水平移动 */ transform: translateX(0); } .slider img.current~img{ /* 指定位于带有current类的图片之后的所有图片水平位移为100% */ transform: translateX(100%); } .slider img.current, /* 指定带有current或last类的图片置顶 */ .slider img.last{ z-index: 999; } 引入的JavaScript:
function getImages() { return document.getElementById("test").querySelectorAll("img"); // 搜找该页面下轮播图容器中的所有img } function getCurrent() { return document.getElementById("test").querySelector("img.current"); // 搜找该页面下轮播图容器中当前展示的img } function setCurrent(index) { var imgs = getImages(); var cur = getCurrent(); imgs.forEach(v => v.className = ""); // 清空所有图片的类名 cur.className = "last"; // 设置当前展示的图片的类名为 "last", 意为: "上一次展示的图片" imgs[index].className = "current"; // 设置要设置的图片的类名为 "current" } 原理 图片集为一个序列, 当前展示的图片在中间, 展示图片之前的图片则是在左边, 而之后的图片则是在右边.
任意设置一个图片为当前展示的图片(即设置类名为current), 那么该图片将移动到中间. 而其它的图片, 自然也会移动到它两边.
由于滑动时, 需要显示将要展示的图片, 以及将要隐藏的图片, 所以这两张图片需要置顶, 否则, 进行多张图片的切换时, 将由于默认层级关系而导致异常, 故设置 .current 与 .last 的 z-index 为 999.</content></entry><entry><title>[C#] C# 与 Java 的一些差异, 快速了解 Java 的基础知识</title><url>https://slimenull.top/post/sth-csharpandjava/</url><categories/><tags/><content type="html"> C# 与 Java 各有长处, 通过这篇文章, 了解 C# 与 Java 的重要差异, 借助 C# 知识, 学习 Java
1. 数据类型 在 C# 中, 基本的数据类型都有别名, 例如字符串 String, 可以简写为 string, Int32 可以简写为 int, 但是在 Java 中, 不存在这些. 使用字符串, 必须要首字母大写, 使用布尔值必须要用 boolean.
在 C# 中, String 数据基本数据类型, 而在 Java 中, 严格来讲, 它不属于基本数据类型. Java 中的基本数据类型更像是 C# 中的值类型, 只有 int, char, boolean 这些直接存储的数据类型才是基本数据类型.
String str = "这是一个字符串"; // 正确 在 C# 中, int 就是 int, 它与其他复杂的数据类型例如 StringBuilder 差异并不大, 但是在 Java 中, int, char, boolean 这类基本数据类型不可以作为泛型参数来使用, 例如你不能创建一个存储 int 的 List, 如果要创建存储 int 的 List, 你需要使用 int 的包装类 Integer, 创建 ArrayList&lt;Integer>.
var v = new ArrayList&lt;int>(); // 错误 var v = new ArrayList&lt;Integer>(); // 正确 Java 不存在值类型, 只有基本数据类型和引用对象类型, 两者用法不同.
Java 的基本数据类型不存在成员, 例如在 C# 中, int 有静态常量 MaxValue, 但是 Java 中的 int 没有, 如果要获取整数的最大值, 需要使用 int 的包装类 Integer
int v = int.MAX_VALUE; // 错误 int v = Integer.MAX_VALUE; // 正确 Java 中比较字符串是否相等需要使用实例方法 String.equals(String), 在 C# 中直接使用等于号 &lsquo;==&rsquo; 比较即可. 当然, 如果要比较引用是否相同(比较内存地址), 在 C# 中可以使用 object.ReferenceEquals(object, object)
String a = "qwq"; String b = new Scanner(System.in).nextLine(); System.out.println("输入的字符串与 'qwq' 相等: " + a.equals(b).toString()); 2. 枚举 在 C# 中, 枚举是特殊的值类型, 本质是 int, 定义起来非常简单, 在 Java 中, 如果要自定义每一个枚举成员所对应的 int 值, 则定义起来非常繁琐: public enum ColumnAlignment { Left(1), Right(2); private int value; private ColumnAlignment(int value) { this.value = value; } public int value(){ return this.value; } } 3. Linq 与 Stream 在 C# 中, 对于可迭代对象的批量处理, 我们经常使用 Linq, 但是在 Java 中, 是不支持拓展函数的, 所以自然无法实现 Linq 这类方便的操作类, Stream 勉强可以作为 Linq 的替代品, 例如与 Linq 中 Select 方法对应的 Stream.map: // C#: List&lt;string> strs = new int[]{1,2,3,4,5,6,7,8,9,0}.Select(v => v.ToString()).ToList(); // Java: List&lt;String> strs = Arrays.stream(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}).map(v -> v.toString()).collect(Collectors.toList()); 不过在实际使用中, 由于 Java 区分 int 和 Integer, 所以会有诸多不便, 但大多都有解决方案, 所以 Java 只是会让人感到有些抓狂罢了.
4. Lambda: 匿名函数, 这绝对是最舒服的东西之一了, 在使用 Linq 的时候肯定无时无刻使用 lambda 的.
在 C# 中, lambda 表达式的操作符是: =>, 而 Java 中是 -> 在 C# 中, lambda 可以使用委托来存储 Action action = () => { Console.WriteLine("F**k you, world"); }; 在 Java 中, 需要使用接口来存储委托 interface Action{ void execute(); // 方法名随意 } Action action = () -> { System.out.println("F**k you, world"); } 5. 泛型 这绝对是 Java 中最让人不爽的地方了.
你无法创建泛型数组 static &lt;T> T[] createArray(int len){ return new T[len]; // 会报错, '类型参数 T 无法直接实例化' } 你无法判断一个对象是否是某个泛型类型 static &lt;T> boolean isType(Object obj){ return obj instanceof T; // 会报错 // 同样, T.class 也是不可用的 } 你无法在使用如下重载: public class Test&lt;T> { void Action(List&lt;T> list){}; void Action(List&lt;Integer> list){}; // 会报错:两个方法具有同样的擦除 }</content></entry><entry><title>[C#] 计算 MD5 SHA1 SHA256 SHA384 SHA512 CRC32</title><url>https://slimenull.top/post/csharp-calchash/</url><categories/><tags/><content type="html"> 借助 System.Security.Cryptography 命名空间内的类进行计算
直接贴代码了, 复制即可用, 源码部分来自网络.
如果要计算字符串的 MD5 值, 直接 Encoding.UTF8.GetBytes() 然后就可以了
using System; using System.IO; using System.Linq; namespace NullLib.HashCalc { public class HashHelper { public static string CalcMd5x32(byte[] bytValue) { return CalcMd5x32(new MemoryStream(bytValue)); } public static string CalcMd5x16(byte[] bytValue) { return CalcMd5x16(new MemoryStream(bytValue)); } public static string CalcShax1(byte[] bytValue) { return CalcShax1(new MemoryStream(bytValue)); } public static string CalcShax256(byte[] bytValue) { return CalcShax256(new MemoryStream(bytValue)); } public static string CalcShax384(byte[] bytValue) { return CalcShax384(new MemoryStream(bytValue)); } public static string CalcShax512(byte[] bytValue) { return CalcShax512(new MemoryStream(bytValue)); } public static string CalcMd5x32(Stream stream) { var MD5CSP = new System.Security.Cryptography.MD5CryptoServiceProvider(); byte[] bytHash = MD5CSP.ComputeHash(stream); MD5CSP.Clear(); string sHash = BytesToHex(bytHash); return sHash; } public static string CalcMd5x16(Stream stream) { return CalcMd5x32(stream).Substring(8, 16); } public static string CalcShax1(Stream stream) { var SHA1CSP = new System.Security.Cryptography.SHA1CryptoServiceProvider(); byte[] bytHash = SHA1CSP.ComputeHash(stream); SHA1CSP.Clear(); string sHash = BytesToHex(bytHash); return sHash; } public static string CalcShax256(Stream stream) { var SHA256CSP = new System.Security.Cryptography.SHA256CryptoServiceProvider(); byte[] bytHash = SHA256CSP.ComputeHash(stream); SHA256CSP.Clear(); string sHash = BytesToHex(bytHash); return sHash; } public static string CalcShax384(Stream stream) { var SHA384CSP = new System.Security.Cryptography.SHA384CryptoServiceProvider(); byte[] bytHash = SHA384CSP.ComputeHash(stream); SHA384CSP.Clear(); string sHash = BytesToHex(bytHash); return sHash; } public static string CalcShax512(Stream stream) { var SHA512CSP = new System.Security.Cryptography.SHA512CryptoServiceProvider(); byte[] bytHash = SHA512CSP.ComputeHash(stream); SHA512CSP.Clear(); string sHash = BytesToHex(bytHash); return sHash; } public static string CalcCrcx32(Stream stream) { Crc32 calculator = new Crc32(); byte[] buffer = calculator.ComputeHash(stream); calculator.Clear(); //将字节数组转换成十六进制的字符串形式 string sHash = BytesToHex(buffer); return sHash; } private static string BytesToHex(byte[] array) { return string.Join(null, array.Select(v => Convert.ToString(v, 16).PadLeft(2, '0'))); } /// &lt;summary> /// 提供 CRC32 算法的实现 /// &lt;/summary> private class Crc32 : System.Security.Cryptography.HashAlgorithm { public const uint DefaultPolynomial = 0xedb88320; public const uint DefaultSeed = 0xffffffff; private uint hash; private uint seed; private uint[] table; private static uint[] defaultTable; public Crc32() { table = InitializeTable(DefaultPolynomial); seed = DefaultSeed; Initialize(); } public Crc32(uint polynomial, uint seed) { table = InitializeTable(polynomial); this.seed = seed; Initialize(); } public override void Initialize() { hash = seed; } protected override void HashCore(byte[] buffer, int start, int length) { hash = CalculateHash(table, hash, buffer, start, length); } protected override byte[] HashFinal() { byte[] hashBuffer = uintToBigEndianBytes(~hash); this.HashValue = hashBuffer; return hashBuffer; } public static uint Compute(byte[] buffer) { return ~CalculateHash(InitializeTable(DefaultPolynomial), DefaultSeed, buffer, 0, buffer.Length); } public static uint Compute(uint seed, byte[] buffer) { return ~CalculateHash(InitializeTable(DefaultPolynomial), seed, buffer, 0, buffer.Length); } public static uint Compute(uint polynomial, uint seed, byte[] buffer) { return ~CalculateHash(InitializeTable(polynomial), seed, buffer, 0, buffer.Length); } private static uint[] InitializeTable(uint polynomial) { if (polynomial == DefaultPolynomial &amp;&amp; defaultTable != null) { return defaultTable; } uint[] createTable = new uint[256]; for (int i = 0; i &lt; 256; i++) { uint entry = (uint)i; for (int j = 0; j &lt; 8; j++) { if ((entry &amp; 1) == 1) entry = (entry >> 1) ^ polynomial; else entry = entry >> 1; } createTable[i] = entry; } if (polynomial == DefaultPolynomial) { defaultTable = createTable; } return createTable; } private static uint CalculateHash(uint[] table, uint seed, byte[] buffer, int start, int size) { uint crc = seed; for (int i = start; i &lt; size; i++) { unchecked { crc = (crc >> 8) ^ table[buffer[i] ^ crc &amp; 0xff]; } } return crc; } private byte[] uintToBigEndianBytes(uint x) { return new byte[] { (byte)((x >> 24) &amp; 0xff), (byte)((x >> 16) &amp; 0xff), (byte)((x >> 8) &amp; 0xff), (byte)(x &amp; 0xff) }; } } } }</content></entry><entry><title>[C#] 关于 Linq 拓展函数对迭代对象进行更改不生效的问题</title><url>https://slimenull.top/post/error-dotnet-linqnochange/</url><categories/><tags/><content type="html"> 在使用 Enumerable.Select 时, 发现在回调函数中对迭代对象进行更改, 不会生效, 甚至这个 Select 语句根本不会正常执行
偶然发现, 在使用 Linq 的 Select 方法时, 如果对被迭代对象进行更改, 那么这个更改是不会生效的
// 定义我们自己要用的类型 class QWQ { public int qwq; public string awa; public QWQ(){} public QWQ(int qwq){this.qwq=qwq;} } // 用来执行的方法 static void LinqExTest() { List&lt;QWQ> qwqs = Enumerable.Range(0, 10).Select(v => new QWQ(v)).ToList(); // 在迭代的同时, 对原对象进行更改: qwqs.Select(v => v.awa = v.qwq.ToString()); // 打印对象 Console.WriteLine(string.Join("\n", qwqs.Select(v => $"qwq:{v.qwq}, awa:{v.awa}"))); } 最终执行效果是:
qwq:0, awa: qwq:1, awa: qwq:2, awa: qwq:3, awa: qwq:4, awa: qwq:5, awa: qwq:6, awa: qwq:7, awa: qwq:8, awa: qwq:9, awa: 显然, 对原对象的更改没有生效! 即便是改为通过索引来访问, 也是不彳亍:
qwqs.Select((v, i) => qwqs[i].awa = v.qwq.ToString()); qwq:0, awa: qwq:1, awa: qwq:2, awa: qwq:3, awa: qwq:4, awa: qwq:5, awa: qwq:6, awa: qwq:7, awa: qwq:8, awa: qwq:9, awa: 但是如果将 Select 语句改为 foreach 语句, 则会成功运行:
foreach(var v in qwqs) v.awa = v.qwq.ToString(); qwq:0, awa:0 qwq:1, awa:1 qwq:2, awa:2 qwq:3, awa:3 qwq:4, awa:4 qwq:5, awa:5 qwq:6, awa:6 qwq:7, awa:7 qwq:8, awa:8 qwq:9, awa:9</content></entry><entry><title>[C#] 二进制, 十进制, 十六进制, 进制转换</title><url>https://slimenull.top/post/csharp-bindigithexconvert/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag></tags><content type="html"> C# 的各个进制互相转换 格式化字符串, Convert类
在源码中: C# 中允许在代码中使用 0x 开头的十六进制数字, 以及 0b 开头的二进制数字来表示一个整数. 下面的语法是合理的.
int a = 123; int b = 0xFF; int c = 0b10010; 从数字转换 将一个数字转换为某进制的字符串, 有两种方式:
// 第一种: 使用 Convert 类. 可转换为 二进制 八进制 十进制 十六进制 Convert.ToString(10, 2); // 二进制, 返回 "1010" Convert.ToString(10, 8); // 八进制, 返回 "12" Convert.ToString(10, 10); // 十进制, 返回 "10" Convert.ToString(10, 16); // 十六进制, 返回 "a" // 第二种: 使用对象的 ToString() 方法. 只能转换为 十六进制 10.ToString("x"); // 返回 "a" 10.ToString("X"); // 返回 "A" 10.ToString("x2"); // 返回 "0a" 10.ToString("X2"); // 返回 "0A" // 第三种: 使用 String 的静态方法 Format, 只能转换为 十六进制 string.Format("{0:x}", 10) // 返回 "a" string.Format("{0:X}", 10) // 返回 "A" string.Format("{0:x2}", 10) // 返回 "0a", 即填充至宽2 string.Format("{0:X2}", 10) // 返回 "0A", 同样填充 从字符串转换 将字符串转换为对应的数据, 有两种方式
// 第一种: 使用 Convert类. 可转换 二进制 八进制 十进制 十六进制, 这里以 int 为例 Convert.ToInt32("1010", 2); // 二进制, 返回 10 Convert.ToInt32("12", 8); // 八进制, 返回 10 Convert.ToInt32("10", 10); // 十进制, 返回 10 Convert.ToInt32("A", 16); // 十六进制, 返回 10 // 第二种: 使用对应数据类型的 Parse 方法, 只支持 十六进制, 这里以 int 为例 int.Parse("A", NumberStyles.HexNumber); // 返回 10 从字符数组转换 最常用的就是将字符数组转换为十六进制字符串了, Linq 可以帮到我们许多
byte[] array; // 假定这个数组有值 // 第一种: 对应上面的 Convert 类静态方法, 也是个人比较推荐的 string.Join(null, array.Select(v => Convert.ToString(v, 16).PadLeft(2, '0'))); // 返回小写的 // 第二种: 对应格式化方法 string.Join(null, array.Select(v => v.ToString("X2"))); // 第三种: 对应 String 静态 Format 方法 string.Join(null, array.Select(v => string.Format("{0:X2}", v)));</content></entry><entry><title>[Java] 变量与表达式</title><url>https://slimenull.top/post/java-variableandexpr/</url><categories/><tags><tag>Java</tag><tag>教程</tag><tag>笔记</tag></tags><content type="html"> Java 编程的基础知识, 变量, 表达式
你已经学会输出 Hello world 了, 那么现在, 我们来学习关于变量的知识
基本数据类型 在 Java 中, 有 8 种基本的数据类型:
名称 描述 byte 即字节, 是计算机中最小的存储单位, 平常说的兆, 其实指的就是兆字节, 内存占用大小也当然是1byte short 即短整型, 一个比较小的, 用于存储整数的类型, 内存占用 2byte int 全称是integer, 即整数, 有时也称int32, 因为它占用 4byte, 即32bit long 即长整型, 存储比较大的整数, 占用的空间是int的两倍, 8byte float 即浮点数, 用来存储小数, 占用空间大小是4byte double 即双精度浮点数, 也用来存储小数, 精度是float的两倍, 占用空间大小是float的两倍, 8byte boolean 即布尔类型, 它的值只有两种情况, 真(true) 或 假(false), 占用空间大小是1byte char 字符类型, 用来存储单个字符, 因为Java中字符类型存储Unicode字符, 所以它占用2byte的空间 还有一种常用类型, 是 String, 即字符串.
定义变量 定义变量, 语法很简单, 只需要指定类型与名称即可:
类型 名称; // 示例 : int num; 如果需要在定义变量的时候就为它赋值, 则可以使用下面的语法:
类型 名称 = 初始值; // 示例 : int num = 114514; 使用数据 在程序中, 我们要使用的数据无非是变量和常量两种, 因为变量的值可以被更改, 所以它的名字才是 &lsquo;变&rsquo;量. 而不能够被更改的, 就是常量. 两者的用法是一样的.
System.out.println("Hello world"); // 在这个示例中, 我们输出了一个 "Hello world", 这个值显然是无法因程序的语句而变更的, 所以称之为常量 int num = 114514; System.out.println(num); // 在这个示例中, 我们定义了一个类型为整数的变量, 并为其赋值 114514, 一般的我们不会这样直接将一个定义的变量直接输出, 而是根据一些运算, 得出一些数据, 然后再输出, 这些数据是可变的, 不是固定的, 即, 变量 int num = 114000; num = num + 514; System.out.println(num); // 这个示例中, 最终输出的是 114514, 而这个值是经过运算得来的, num 发生了变化, 即, 变量. 你可以直接用 println 输出一个 Hello world, 也可以先定义一个字符串, 赋值为 Hello world, 然后输出这个变量, 两者的执行效果是没有区别的, 也就是刚刚说的, 两者用法是一样的.
运算符 Java 里面有一些运算符, 例如加减乘除啥的, 这是算术运算符, 它们的作用也简单, 正如其名. 不同的数据类型, 对于同一运算符, 执行效果是不同的, 例如, 两个整数相加, 结果就是这两个数字相加的结果. 但如果是两个字符串相加, 那么结果就是这两个字符串拼接的结果.
1 + 1, "Hello world!" + " - The first program by Null", 3 + 0.14
运算符有优先级之说, 例如数学中的先算乘除, 后算加减, 这就是运算符的优先级. 同时, 括号的优先级是很高的, 优于乘除
而事实上, 也有其它的运算符, 例如括号本质上也是运算符, 不过这个我们以后会学到, 这里暂且不作说明.
表达式 数据通过运算符相连, 就是表达式. 例如 1+1, "test"+" program", 1+2+3. 表达式有返回值, 即, 表达式的运算结果, 例如几个字符串用加号相连, 最终的返回值就是这几个字符串连接起来的结果.
易错点: 有些同学会犯一些弱智的错误. 它们可能会这么写:
int a = 114514; System.out.println("a 的值是:" a); 看出哪里错了吗? 上述代码中, 一个字符串和一个整数并列, 却没有使用任何运算符相连! 这是错误的! 完完全全的错误!
如果你想打印 "a 的值是", 后跟变量a的值, 请使用加号把它们连接起来! 因为这样, 它们才能进行运算, 最终得到一个值, 然后打印到控制台.</content></entry><entry><title>PowerShell 快速入门, 基本语法, 常用类型, 函数, .NET 互操作</title><url>https://slimenull.top/post/pwsh-getstarted/</url><categories/><tags><tag>.NET</tag><tag>PowerShell</tag><tag>教程</tag><tag>笔记</tag></tags><content type="html"> PowerShell, 比 cmd 强大一万倍的 shell, 并且完美支持 .NET 互操作, 用来测试一些小功能最恰当不过
开始之前, 我们认定你已经有一定的编程基础, 熟悉 .NET 中的类型与对象.
此文章对于 .NET 开发者来说更简单哦!
在 PowerShell 中, 几乎一切都是对象. 与 CMD 有很大不同. PowerShell 是强类型的, 它基于 .NET, 故, PowerShell 可以近乎完美的调用 .NET 的标准库.
0. 准备工作 - 官方文档 既然要学新东西, 肯定要会查阅官方文档才彳亍呀! 本文章参阅官方文档, 并使用更简单的语言讲述给读者, 在每一部分都会有推荐的官方文档链接目录, 点击即可跳转.
MSDocs PowerShell : 如何使用 PowerShell 官方文档
MSDocs PowerShell : PowerShell 是什么
MSDocs PowerShell : 关于主题 (涵盖有关 PowerShell 的一系列概念)
另外, 在文档的中文页面的左侧索引部分, 你无法看到所有的内容, 例如 Reference 分类, 其中包含了非常多的 &lsquo;隐藏&rsquo; 内容, 只有你切换到英文页面才可以看到它们.
至于如何切换页面语言, 也简单, 只需要将地址栏中的 &lsquo;zh-cn&rsquo; 改为 &rsquo;en-us&rsquo; 即可, 同理, 如果某个页面你看不懂, 想要切换到中文, 可以将 &rsquo;en-us&rsquo; 改为 &lsquo;zh-cn&rsquo;, 不过需要注意的是, 部分页面是没有提供中文翻译的.
为了方便, 本文涉及到的所有文档链接均为英文直链, 如需访问中文页面, 请自行修改链接地址.
- 启动 PowerShell PowerShell 同 CMD 一样有许多启动方式, 准备好开始了吗? 那么开始吧!
按下 &ldquo;Win&rdquo; + &ldquo;R&rdquo; 打开 &lsquo;运行&rsquo; 窗口, 键入 &lsquo;PowerShell&rsquo; 并确认.
按 &ldquo;Win&rdquo; + X, 然后按 &lsquo;I&rsquo;, 或者按 &lsquo;A&rsquo;(以管理员身份运行).
在桌面或资源管理器, 不选中任何条目, 按住 Shift, 右击背景, 在弹出的菜单中选择 &lsquo;在此处启动 PowerShell&rsquo;.
在资源管理器中, 在地址栏输入 &lsquo;PowerShell&rsquo; 并按 Enter 键确认.
接下来, 出现的蓝底白字的控制台页面就是 PowerShell 的主程序了! 在其中输入指令(代码)可以运行一些东西.
1. 基本语法 - 标准输出 让我们从一个 &lsquo;hello world&rsquo; 的输出开始吧, 与 CMD, Bash 一样, 使用 echo 指令是可以输出内容的.
echo "Hello World!" 输出:
Hello World! - 获取帮助: 执行以下指令来获取关于 echo 的帮助内容.
Get-Help echo 输出:
NAME Write-Output SYNTAX Write-Output [-InputObject] &lt;psobject[]> [-NoEnumerate] [&lt;CommonParameters>] ALIASES write echo REMARKS Get-Help cannot find the Help files for this cmdlet on this computer. It is displaying only partial help. -- To download and install Help files for the module that includes this cmdlet, use Update-Help. -- To view the Help topic for this cmdlet online, type: "Get-Help Write-Output -Online" or go to https://go.microsoft.com/fwlink/?LinkID=113427. 看到结果, 你懂了吧, echo 实际上是 Write-Output 的别名, 同时也可以用 write 来执行.
另外, PowerShell 的指令是不区分大小写的, 所以 Write-Output 与 wRITE-oUTPUT 是一样执行效果的
- 定义变量 PowerShell 官方文档 : 关于变量
定义变量的方式与 Bash 差不多, 都是用 $ 开头, 后跟变量名
$var = 123 echo $var 输出:
123 - 固定常量 PowerShell 中有一些常量, 不可被赋值 (如果对其赋值, 不会产生任何作用, 且不会抛出异常)
常量名 类型 值 $null object null $true bool true $false bool false 如果访问一些未定义的变量, 返回的值同样是 null
- 类型概念 PowerShell 是强类型的. 例如刚刚我们定义的变量, 其实就是一个 int 变量. 示例:
$a = 123 $b = 321 $c = $a + $b echo $c 输出:
444 数字支持运算, 所以理所当然的可以进行运算.
- 表达式与指令 刚刚我们所用的 echo 指令, 同时可以说是一个表达式. 而刚刚我们进行加法运算时, 所使用的 &lsquo;$a + $b&rsquo; 通用
我没猜错的话, 在刚刚的变量部分, 也同样有人这么执行:
$a = 123 $b = 321 echo $a + $b 然后结果就是, 输出了
$a + $b 而解决办法就是, 为这个表达式加上括号, 优先运算这个表达式, 于是就正常了, 或者你可以直接 echo 一个表达式:
echo (123+321) 输出
444 - 运算符 刚刚我们从尝试了加法运算, 同时在 PowerShell 中, 也是支持减法, 乘法, 除法的, 除此之外还有小于, 大于, 等于, 大于等于, 小于等于:
echo (1 -lt 10) 输出:
True 运算符 描述 -eq 等于 -ne 不等于 -lt 小于 -gt 大于 -le 小于等于 -ge 大于等于 2. 流程控制: - 基本判断 MSDocs PowerShell : 关于 If
判断的话, 毋庸置疑是 if 语句. 当然, 无非是 &lsquo;if&rsquo; &rsquo;else&rsquo; &rsquo;else if&rsquo;
在 PowerShell 中, if 语句的语法可以是这样:
if (exp) { statement block } elseif { statement block } else { statement block } # 示例 : $randint = (New-Object Random).Next() # 生成一个随机数, 并赋值给 randint 变量 if ($randint -eq 114514) { echo "嗯哼哼哼啊啊啊啊啊啊啊啊" } elseif ($randint -gt 114514) { echo "吔屎了你, 梁非凡!" } else { echo "听不见! 就这点声音还想开军舰!?" } 没错, PowerShell 中, &rsquo;else if&rsquo; 的话是不允许带空格的. 并且需要注意的是, 这个大括号不允许省略.
- 循环语句 for 循环
MSDocs PowerShell : 关于 For
for (exp; exp; exp) { statement block } # 示例 : for ($i = 0; $i -lt 10; $i++) { echo $i } for ($i = 1; $i -lt 10; $i++) { for ($j = 1; $j -le $i; $j++) { [Console]::Write(("{0}x{1}={2}`t" -f ($j, $i, $i * $j))) # 不换行输出 } [Console]::WriteLine() # 换行 } foreach 循环
MSDocs PowerShell : 关于 Foreach
foreach ($var in enumerable object) { statement block } # 示例 : foreach ($num in @(1..5)) { echo $num } while 循环
MSDocs PowerShell : 关于 While
while (exp) { statement block } 打破循环:
MSDocs PowerShell : 关于 Break
# 在 for 中打破循环 : for ($i = 0; $i -lt 10; $i++) { if ($i -eq 5) { break } echo $i } # 在 foreach 语句中打破循环 : foreach ($i in @(1..10)) { if ($i -eq 5) { break } echo $i } # 在 while 语句中打破循环 : $i = 0 while ($true) { if ($i -eq 5) { break } echo $i $i++ } 3. 常用类型 - 对象数组 MSDocs PowerShell : 关于数组
MSDocs PowerShell : 关于数组的各项须知内容
在 PowerShell 中, 当然也存在数组, 通过以下方式来创建:
# 语法 1: $var = @(element 1, element 2, element 3, ...., element n) # 示例: $array = @(1, 3, 4, 5) # 语法 2: $var = start..end # 示例: $array = @(1..5) # 生成的数组等同于: @(1, 2, 3, 4, 5) # 提示, @() 是可以省略的. 不过如果要创建空数组, 不可省略 数组的访问, 与其他大多数编程语言一致, 通过中括号就可以:
echo @(1..4)[2] # 输出 3 $array = @(1..4) $array[2] = 114514 echo $array[2] # 输出 114514 PowerShell 的数组还支持获取多个值, 它返回一个新的数组:
$array = @(1..4) $array2 = $array[0, 2] echo $array2[0] # 输出 1 echo $array2[1] # 输出 3 添加元素, 可以用 &lsquo;+=&rsquo; 运算符, 但注意, 不推荐这么做, 因为每为数组添加元素, 实际上都是重新创建了新的数组, 如果需要更灵活的数组, 请使用 泛型List
$array = @(1..4) $array += 114514 echo $array[4] # 输出 114514 如果获取数组元素值时, 索引超出界限, 不会抛出异常, 会返回 null:
$array = @(1..4) echo $array[114514] # 不会有任何输出, 因为值是null 如果对一个不是数组的变量使用索引操作符, 则会抛出异常:
$test = $null $test[0] # 抛出异常 两个数组相加, 返回数组连接后的结果:
$array1 = @(1..3) $array2 = @(3..1) echo ($array1 + $array2) 输出:
1 2 3 3 2 1 使用 -contains 操作符来判断数组是否包含某元素:
$array = @(1..4) echo ($array -contains 2) # 输出 True 在 PowerShell 的数组中, -eq 操作符将对所有元素进行判断, 即, 遍历内容, 逐一进行 -eq 运算, 如若有任何元素运算返回 True, 则表达式返回真.
$array = @(1..4) echo ($array -eq 3) # 返回 True 如果判断一个变量(可能是数组)为空, 请不要将这个变量放在左侧:
$array -eq $null # 不要这样使用 $null -eq $array # 正确的使用方式 使用 Count 来获取一个数组的长度, 但注意, 如果一个变量值为null, 同样可以使用 count 来获取长度, 它返回 0:
$array = @(1..4) echo $array.Count # 返回 4 echo $null.Count # 返回 0 你也可以通过 Length 来获取一个数组的长度, 它与 Count 用法一样, 并且如果是 $null, 同样返回 0.
- 哈希表 MSDocs PowerShell : 关于哈希表
MSDocs PowerShell : 关于哈希表的一些注意事项
哈希表, 即 HashTable. 在 PowerShell 中这样创建 HashTable:
$table = @{ key = value key = value } # 示例 : $table = @{} # 创建空表 $table = @{ # 创建有初始值的表, 下面的示例将使用这个表 "NullSlime" = 100 "MoYuro" = 96 "Muchen" = 94 "KingHans" = 88 } 访问哈希表, 通过索引运算符, 指定键:
# 使用刚刚创建的 table echo $table["MoYuro"] # 输出 96 $table["MoYuro"] = 97 echo $table["MoYuro"] # 输出 97 向表中添加键值对, 使用 Add 方法:
$table.Add(key, value) # 示例 : $table.Add("KunLong", 76) 删除表中的某个键值对, 使用 Remove 方法:
$table.Remove(key) # 示例 : $table.Remove("KingHans") 哈希表和数组一样支持选择多个值, 只需要在索引运算符中指定多个键:
$table[key1, key2, ... , key n] $table[(key1, key2, ... , key n)] $table[@(key1, key2, ... , key n)] # 示例 : $values = $table["NullSlime", "MoYuro"] # 返回一个数组 echo $values[0] # 输出 100 echo $values[1] # 输出 96 通过 Keys 与 Values 来获取这个哈希表的所有键以及值
$keys = $tables.Keys # 返回哈希表的所有键 $values = $tables.Values # 返回哈希表的所有值 可以通过对哈希表的枚举器来进行循环哈希表的每一个键值对:
foreach ($pair in $table.GetEnumerator()) { echo ("{0}: {1}" -f ($pair.Key, $pair.Value)) } 当通过foreach对哈希表进行迭代时, 不可以对哈希表进行删减:
4. 脚本函数 - 关于函数 PowerShell 官方文档 : 关于函数
PowerShell 中定义函数很简单, 它的本质是脚本块(ScriptBlock):
function name(parameters) { statement block } # 示例 : function myFunc($a, $b) { echo ($a + $b) } 调用 PowerShell 中定义的函数, 语法如下:
name argv1 argv2 argv3 .... argv n # 示例 : myFunc 114000 514 # 输出 114514 如果要获取这个函数的对象引用 可以这样:
$function:name # 示例 : echo $function:myFunc 输出:
param($a, $b) echo ($a + $b) 通过函数的对象引用, 可以使用 Invoke 来调用:
$function:name.Invoke(parameters) # 示例 : $function:myFunc.Invoke(114000, 514) # 输出 114514 删除一个一定义的函数, 可以使用 del 语句:
del function:name # 示例 : del function:myFunc echo $function:myFunc # 由于函数已删除, 所以不会有任何输出 函数可以有返回值, 只需要使用 return 语句:
function myFunc($a, $b) { return $a + $b; } $result = myFunc 114000 514 echo $result # 输出 114514 5. 面向对象 - 使用对象 肯定会有人执行这个指令:
echo Hello World! 虽然仅仅少了一对双引号, 但是, 它表示的意思其实跟之前我们写的完全不一样. 如果不加双引号, 那么在这个指令中, Hello 和 World! 会被认为是两个参数! 或者准确来说, 是两个对象!
这条没有加双引号的指令, 输出结果是:
Hello World! 另外, 命令的输出同样也是一个个对象, 执行下面的指令:
1+1 输出
2 - .NET 互操作 事实上, PowerShell 中的对象都是 .NET 对象. 并且我们可以进行 .NET 对象中所支持的操作. 执行下面的指令:
(1+1).GetType() 输出:
IsPublic IsSerial Name BaseType -------- -------- ---- -------- True True Int32 System.ValueType 这熟悉的命名空间, 可不就是 .NET 吗?
试试以下指令:
(echo 123).GetType() 输出:
IsPublic IsSerial Name BaseType -------- -------- ---- -------- True True Int32 System.ValueType 好家伙, 原来 echo 直接就是把这个对象输出出来对吧!
而事实上, 一个表达式的运算结果(返回值), 是会打印到控制台的, 这点与 Python 一样.
所以如果你执行一个 &lsquo;1+1&rsquo;, 这个表达式的运算结果是 2, 则 2 会被打印到控制台.
1+1 # 输出 2 如果你不希望一个语句的返回值被打印到控制台, 可以在首部添加 [void], 它表示将语句的返回值强制转换为 void 以保证没有输出
[void](1+1) # 没有输出 使用 New-Object 可以创建一个对象, 指定 .NET 对象的全名即可创建:
$random = New-Object System.Random $randint = $random.Next() # 调用 System.Random 对象的 Next 方法 echo $randint # 输出一个随机的数字 如果需要带参数的创建 .NET 对象, 直接在 New-Object 语句后添加参数数组即可:
$str = New-Object String ('草', 20) # 生草 echo $str # 返回 '草草草草草草草草草草草草草草草草草草草草' PowerShell 中的强制类型转换是这样使用的:
[类型]对象 # 示例 : $numArray = [int[]](1..4) # 将 object[] 转换为 int[] 调用 .NET 类的静态方法, 使用下面的语法:
[类的全名]::方法名(参数) # 示例 : [Console]::WriteLine("Hello world!") # 输出 Hello world 访问字段, 也是一样的
$ansi = [System.Text.Encoding]::Default 如果要使用某个命名空间, 使用下面的语句:
using namespace System.Text $ansi = [Encoding]::Default 值得高兴的是, 通过调用 .NET 的组件, 你甚至可以在 PowerShell 中创建 UI 窗体, 下面是一个简单的示例代码:
Add-Type -AssemblyName System.Windows.Forms Add-Type -AssemblyName System.Drawing $form = New-Object System.Windows.Forms.Form $form.Text = 'Select a Computer' $form.Size = New-Object System.Drawing.Size(300,200) $form.StartPosition = 'CenterScreen' $okButton = New-Object System.Windows.Forms.Button $okButton.Anchor = [System.Windows.Forms.AnchorStyles]::Bottom -bor [System.Windows.Forms.AnchorStyles]::Right $okButton.Location = New-Object System.Drawing.Point(75,120) $okButton.Size = New-Object System.Drawing.Size(75,23) $okButton.Text = 'OK' $okButton.DialogResult = [System.Windows.Forms.DialogResult]::OK $form.AcceptButton = $okButton $form.Controls.Add($okButton) $cancelButton = New-Object System.Windows.Forms.Button $cancelButton.Anchor = [System.Windows.Forms.AnchorStyles]::Bottom -bor [System.Windows.Forms.AnchorStyles]::Right $cancelButton.Location = New-Object System.Drawing.Point(150,120) $cancelButton.Size = New-Object System.Drawing.Size(75,23) $cancelButton.Text = 'Cancel' $cancelButton.DialogResult = [System.Windows.Forms.DialogResult]::Cancel $form.CancelButton = $cancelButton $form.Controls.Add($cancelButton) $label = New-Object System.Windows.Forms.Label $label.Anchor = [System.Windows.Forms.AnchorStyles]::Top -bor [System.Windows.Forms.AnchorStyles]::Left $label.Location = New-Object System.Drawing.Point(10,20) $label.Size = New-Object System.Drawing.Size(280,20) $label.Text = 'Please select a computer:' $form.Controls.Add($label) $listBox = New-Object System.Windows.Forms.ListBox $listBox.Anchor = [System.Windows.Forms.AnchorStyles]::Top -bor [System.Windows.Forms.AnchorStyles]::Left -bor [System.Windows.Forms.AnchorStyles]::Bottom -bor [System.Windows.Forms.AnchorStyles]::Right $listBox.Location = New-Object System.Drawing.Point(10,40) $listBox.Size = New-Object System.Drawing.Size(260,20) $listBox.Height = 80 [void] $listBox.Items.Add('atl-dc-001') [void] $listBox.Items.Add('atl-dc-002') [void] $listBox.Items.Add('atl-dc-003') [void] $listBox.Items.Add('atl-dc-004') [void] $listBox.Items.Add('atl-dc-005') [void] $listBox.Items.Add('atl-dc-006') [void] $listBox.Items.Add('atl-dc-007') $form.Controls.Add($listBox) $form.Topmost = $true $result = $form.ShowDialog() if ($result -eq [System.Windows.Forms.DialogResult]::OK) { $x = $listBox.SelectedItem [System.Windows.Forms.MessageBox]::Show("你选择了:" + $x.ToString()) } else { [System.Windows.Forms.MessageBox]::Show("你没有选择任何条目") }</content></entry><entry><title>[C#] WPF TextBox 在 PreviewDragEnter 中指定 Effect 且指定 Handled 为 true, 仍然无法正常实现拖拽操作.</title><url>https://slimenull.top/post/error-dotnet-wpf-dragdrop/</url><categories/><tags><tag>.NET</tag><tag>WPF</tag><tag>踩坑记录</tag></tags><content type="html"> DragEnter, DragOver, Drop 三个事件都需要进行处理才可以的
在开始之前, 请先阅读这篇文章: [C#] WPF Preview 事件与普通事件的区别
我们知道, 某些控件会对事件进行处理, 导致部分事件我们无法正常使用, 对于 TextBox, 显而易见的是关于拖拽的事件完全不能正常使用. 因而我们需要使用 Preview 事件.
对于一套拖拽操作, 有以下过程:
用户拖拽数据进入控件 (DragEnter) 用户拖拽数据在控件上移动 (DragOver) 用户拖拽数据在控件上松开鼠标 (Drop) 对于一个控件, 必须指定这个控件的 AllowDrop 属性为 true, 这个控件才可以接受拖拽操作
对于上述 3 个事件:
DragEnter 中, 我们需要写的是判断拖拽的数据的类型, 并设定拖拽效果(DragDropEffects), 指定是否已经处理当前事件(Handled) DragOver 中, 与 DragEnter 中一致. 所以这两个事件, 可以通过同一个方法来进行订阅 Drop 中, 应该写对数据的处理, 例如将数据添加到界面中 注意! 在 DragEnter 和 DragOver 中, 必须指定 DragDropEffects 才表示允许拖拽. 如果不对 Effects 进行赋值, 那么 Drop 方法将不会被触发.
相信看完上面的内容, 你已经可以解决你的问题了, 如果无法解决问题, 请在下方评论, 我会继续完善这篇文章</content></entry><entry><title>[.NET] WPF Preview 事件与普通事件的区别.</title><url>https://slimenull.top/post/dotnet-wpfpreviewevents/</url><categories/><tags><tag>.NET</tag><tag>WPF</tag><tag>笔记</tag></tags><content type="html"> Preview 事件是一个特殊的事件, 它只能在控件的预览状态下触发, 在 preview 事件中, 控件的默认处理是还没有执行的
很多文章都提到了冒泡事件和隧穿事件, 我是没有去测试过这两个的, 但是有一个非常非常重要的点很多人都忽略了.
已预处理事件的控件 在 WPF 中, 部分控件已经对某些事件进行了处理, 例如一个 Button, 它提供了 Click 事件, 而 Click 的本质是 MouseDown 和 MouseUp, 因而, Button 的 MouseDown 和 MouseUp 事件是没办法正常使用的&hellip;
如果需要使用它们, 你得使用 PreviewMouseDown 和 PreviewMouseUp.
同样, 有很多控件都是这样的, 例如 TextBox, 一个支持输入文本的控件, 同样还支持拖拽事件, 你可以向其中拖拽文本, 但是你不可以向其中拖拽图片, 这也是因为 TextBox 对拖拽事件进行了处理.
也正因为如此, 即便你 TextBox 的 DragEnter 事件中指定了允许拖拽, 你也是不可以进行拖拽的! 因为 WPF 已经对这个事件进行处理了, 我们的逻辑不会起作用.</content></entry><entry><title>[Python] 巧用! 局域网传输文件! 还可以这么玩!!!</title><url>https://slimenull.top/post/python-filetransfer/</url><categories/><tags><tag>Python</tag><tag>经验</tag><tag>笔记</tag></tags><content type="html"> 之前&hellip; 我知道了 Python 有着内置的网络库, 甚至可以直接用来原地开一个 http 服务器!
最近&hellip; 频繁的需要在局域网内传输大文件&hellip; 用 U 盘当然可以, 但完全没必要,,, 太浪费了 也试着用 Python 的套接字来手动将文件数据发送到另一台机器, 然后另一台机器也用 Python 套接字来接收, 并直接写入到文件&hellip; 好吧我知道很麻烦没错
然后&hellip; 我突然想起&hellip; Python 开那个 HTTP 服务器可不就能直接用来分享文件啊卧槽?
于是&hellip;
python -m http.server 成功了&hellip; 而且速度不赖~</content></entry><entry><title>[.NET] 拓展库, 开源库, nuget库收集. (长期更新)</title><url>https://slimenull.top/post/sth-usefulnugets/</url><categories/><tags><tag>.NET</tag><tag>轮子</tag><tag>笔记</tag></tags><content type="html"> 一些有意思的开源库, 可以在这里收集下来, 如果感兴趣, 可以试试下面的库
名称 标签 描述 Newtonsoft.Json JSON分析, 文本处理 非常流行的JSON操作库, 教程也能够轻松在网上找到, 速度也很不错, 是 ASP.NET 中 Json 序列化反序列化的默认使用方式 NAudio 音频处理, 录音, 播放音频 流行而又强大的音频操作库, 支持音频播放, 录制, 转码, 以及音频可视化, NAudio 各种使用方式
, NAudio 实现音频可视化
Costura.Fody 程序打包 仅需安装这个库, 即可直接使所有需要的程序集内嵌入你的程序, 实现单文件程序 System.CommandLine 命令行参数分析 微软官方推出的命令行分析, 截止到目前, 已经有了预发布版本 PropertyChanged.Fody 自动处理 安装这个库后, 所有继承 INotifyPropertyChanged 接口的类都将自动添加通知属性变更的逻辑 WinApi Win32 C# 的 WinApi 封装, 涵盖的方面非常广, 项目地址是: github.com/prasannavl/WinApi
, 下面有很多使用示例 ConsoleGUI 控制台应用 适用于控制台程序的界面库, 能够实现控制台上的各种 UI 控件, 例如文本框, TabControl, 可滚动的文本框, 输入框, 消息框, 还有各种布局方式供使用 Html Agility Pack HTML解析 非常方便的HTML解析库, 支持通过XPath来查找节点 System.Drawing.Common 图像处理 你可能会发现 .NET Core 不内置 System.Drawing 程序集 ,那么安装这个吧, 这个是由微软官方发布的功能等同于 System.Drawing 的库 FiddlerCore 著名抓包神器 Fiddler 的核心 这个在 nuget.org 中搜索不到, 但他存在, 只是被隐藏了, 你可以访问 nuget.org/packages/FiddlerCore
查看他的信息, 通过 nuget 控制台来手动安装它 NullLib.TickAnimation 动画 这个严格来说, 只是对属性按照一定时间函数设置值, 但这正是关键帧动画, 例如通过这个, 你可以实现自动从 0 设置 1, 中间有无数过渡值, 而且可以指定时间函数, 跟前端的贝塞尔曲线一样, 所以很推荐用这个来实现 WinForm 程序的动画实现. 项目地址: github.com/SlimeNull/NullLib.TickAnimation
, 其中包含了完整的中文使用文档. NullLib.ConsoleEx 控制台操作拓展 支持你在读取用户输入时就获取用户的输入内容, 并且支持字符的过滤, 移动输入内容到任意位置等功能; 或者测量一段文本在控制台中的显示长度(中文, 日文等字符为2, 字母数字为1之类的) NullLib.CommandLine 命令行工具 如果你在开发一个服务端程序, 并且想要使用户能在服务端运行时可以通过输入命令行来实现特定操作, 这个是非常方便的 NullLib.PhantomTank 幻影坦克 好耶! 是幻影坦克! 来试试用这个库来快捷生成幻影坦克图片吧! EleCho.Json JSON 简单方便与快捷的第三方 JSON 库, 支持弱类型操作 如果你知道有意思的库, 在评论下留下它的名字, 我们一起完善这个收集.</content></entry><entry><title>[踩坑记录] .NET Core, Delegate.BeginInvoke, PlatformNotSupportedException</title><url>https://slimenull.top/post/error-dotnet-delegatebegininvoke/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>踩坑记录</tag><tag>异步</tag></tags><content type="html"> .NET Core 不支持委托的 BeginInvoke 方法, 使用别的方法, 例如 Task 来替代它!
首先是&hellip; 报了一堆 &ldquo;平台不支持的&rdquo; 错误.
堆栈显示也看不出来是哪里的问题, 但我看到了 Threading 这玩意儿&hellip;:
最后通过 &ldquo;死亡断点&rdquo; 发现是这里出的问题, 这是一个异步操作的回调函数.
进一步调试, 发现是这里, 这里又会 Invoke 一个事件:
好家伙, 又是一个事件&hellip; 然后我看了看订阅了这个事件的地方&hellip;
乍一看,,,, 没啥毛病! 但问题确实出在这里! (我实在是太菜了) 最后&hellip; 我思考了下, 我在 Invoke 调用的委托里面, 整了异步的操作&hellip;&hellip; 于是我试着将 BeginInvoke 换成 Invoke, 然后&hellip;. 问题解决了!!!
后来又双叒叕遇到了这个问题,,, 然后仔细搜索了下资料. 懂了. 原来 .NET Core 不支持委托的 BeginInvoke 方法. 而事件的本质就是多播委托!</content></entry><entry><title>[WPF] Matrix Transform, 矩阵变换. 最最最基础的原理解释.</title><url>https://slimenull.top/post/dotnet-wpfmatrix/</url><categories/><tags><tag>WPF</tag><tag>矩阵变换</tag><tag>基础</tag></tags><content type="html"> 乘以一个坐标其实就是以这个坐标为基, 缩放原图形
关于向量: 1. 向量的基 在计算机科学中, 向量, Vector, 通常这么表示: $$ \left[ \begin{array}{cc} x\ y \end{array} \right] $$ 向量有两个 &ldquo;基&rdquo;, $\overline{i}$, 即 $\overrightarrow{1, 0}$, $\overline{j}$, 即 $\overrightarrow{0, 1}$
向量可以看作这些基乘以一组数的结果, 即: $\overline{v} = \overline{i} \times a + \overline{j} \times b$, 例如 $[1, 3]$, 就是: $$ \overline{i} \times 1 + \overline{j} \times 3 = [1, 0] \times 1 + [0, 1] \times 3 = [1, 0] + [0, 3] = [1, 3] $$
2. 改变向量的基 当改变向量的基时, 由于向量是一组数与基的乘法, 所以向量也会随之变化.
例如我们设定两个基为它们顺时针旋转90°后的结果, 即: $\overline i = [0, -1], \overline j = [1, 0]$, 那么 [1, 3] 就变成了: $$ \overline i \times 1 + \overline j \times 3 = [0, -1] \times 1 + [1, 0] \times 3 = [0, -1] + [3, 0] =[3, -1] $$ 你会发现, 这个向量也随之改变了, 而且恰好是顺时针旋转90°
3. 矩阵的乘法: 在计算机科学中, 向量如此表示: $$ \left[ \begin{array}{c} x\y \end{array} \right] $$ 如果是两个向量, 则是这样, 竖着的, 是一个向量: $$ \left[ \begin{array}{c} x_1, &amp; x_2\ y_1, &amp; y_2 \end{array} \right] $$ 而, 我们刚刚进行的乘法, 其实也是矩阵乘法, 即: $$ \left[ \begin{array}{c} 0, &amp; -1\ 1, &amp; 0 \end{array} \right] \times \left[ \begin{array}{c} 1\ 3 \end{array} \right]= \left[ \begin{array}{c} 3 \ -1 \end{array} \right] $$
矩阵变换 在 WPF 中, 一个矩阵(Matrix)有以下属性: M11, M12, M21, M22, OffsetX, OffsetY.
其中, M11, M12, M21, M22 表示缩放旋转矩阵: $$ \left[ \begin{array}{c} M11, &amp; M12 \ M21, &amp; M22 \end{array} \right] $$ 它们的默认值是: $$ \left[ \begin{array}{c} 1, &amp; 0 \ 0, &amp; 1 \end{array} \right] $$ 而进行矩阵变换, 也就是将源图形的每一个点, 与这个矩阵相乘, 最终得到另一些点, 构成一个新的图形.
而与默认的这个矩阵相乘, 形状不会有任何变化.
这个矩阵的 M11 和 M21 值, 可以理解为 $\overline i$, M12 和 M22 可以理解为 $\overline j$, 之前我们提到, 如果变化这两个基的值, 那么最终向量也会发生变化, 而当我们将刚刚旋转 90° 后的 $\overline i$ 和 $\overline j$ 拿出来直接代入, 也可以发现, 图形直接旋转了 90°.
矩阵的基本原理就是矩阵的乘法, 但即便你不理解矩阵的乘法, 去改变 Matrix 中的两个基值, 形状也将跟随基值发生改变.
而 OffsetX 和 OffsetY, 这两个指定了这两个图形的平移, OffsetX 水平偏移量, OffsetY 垂直偏移量.
0. 参考内容: 哔哩哔哩 3Blue1Brown 线性代数
理解矩阵乘法 - 阮一峰的网络日志
矩阵乘法 - endl</content></entry><entry><title>[干货] 一篇文章完全搞懂面向对象基本概念</title><url>https://slimenull.top/post/sth-objective/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>基础</tag><tag>干货</tag></tags><content type="html"> 类 对象 示例 行为 属性, 用最通俗移动的语言来讲述面向对象
今天我一个朋友, 突然问我, 在程序入口所用的类中, 为什么字段需要加static&hellip;
好家伙, 一听就是没懂啥是面向对象! 我也看了网上的一大堆东西, 啊说啥继承, 多态, 反正我是菜鸟的时候是没听懂这些东西, 后来还是我自己摸索出来的 (嘤嘤嘤QAQ)
好的, 我们使用 C# 来做演示, 大概了解一下类的最基本概念. 来整一个, 数组拓展.
演示代码片: public class ArrayHelper { public int[] Source; // 字段 public static int InsCount = 0; public Arrayhelper() // 构造函数 { this.Source = new int[]{}; InsCount++; } public ArrayHelper(int[] arr) // 有参数的构造函数 { this.Source = arr; InsCount++; } ~ ArrayHelper() // 析构函数 { InsCount--; } public void ResetInsCount() { InsCount = 0; } public int GetSum() // 方法 { int sum = 0; foreach (var i in Source) sum += i; return sum; } public int GetAverage() // 方法 { return GetSum() / Source.Length; } } 1. 基本概念 1. 啥是对象: 对象, 它的英文是 object, 咱也不懂为啥它被翻译成这种有歧义的词, 没错, 它跟 &lsquo;情人&rsquo; 没有任何关系. 意思接近为: &ldquo;物体&rdquo;, &ldquo;事物&rdquo;, 下面的句子中, &lsquo;对象&rsquo; 一词是最接近编程中的 &lsquo;对象&rsquo; 的.
你要帮助的对象是谁? 我们本次整改所针对的对象, 是厂里干部遇事却不作为的事件. 生活中一切东西都可成为对象, 例如一台电脑, 可以说是一个对象, 它有一些成员(字段, 属性, 方法), 例如所装载的硬件. 而对象都有自身的行为(方法), 例如, 汽车, 有点火这个行为.
2. 编程中的类: 编程中的类, 我们可以理解为模板, 或者生产机器, 通过它我们可以创建一个对象(类的实例化). 一个类产生的对象, 就是这个类的实例.
ArrayHelper helper = new ArrayHelper(); // 实例化 ArrayHelper, helper 就是我们示例化产生的对象 3. 构造函数: 构造函数, 就是这个类在构造对象的时候会调用的函数, 例如刚刚 new ArrayHelper() 的时候, 必定会调用类中的这一片代码:
public Arrayhelper() // 构造函数 { this.Source = new int[]{}; } 我们可以声明多个构造函数, 以使用不同的方式来创建对象.
public ArrayHelper(int[] arr) // 有参数的构造函数 { this.Source = arr; } 让我们来使用下这个带参数的构造函数:
int[] myArray = new int[] {1, 2, 3}; ArrayHelper helper = new ArrayHelper(myArray); 4. 对象的字段 在我们的实例代码中, 类中有写一个 int[] 类型的 Source 字段. 我们也说过, 类就好比一个模板. 当一个对象创建后, 它就拥有这个字段
当我们实例化之后, 我们就可以通过实例, 来访问新生成的对象的成员:
ArrayHelper helper = new ArrayHelper(); Console.WriteLine(helper.Source); // 将 helper 的 Source 成员打印出来 这个成员, 是对象所拥有的, 而不是类本身所拥有的, 所以, 下面的代码是错误的:
Console.WriteLine(ArrayHelper.Source); // 会报错, 因为成员是对象的. 每一个对象都有自己独自的成员, 所以, 不同实例的成员, 值是一定相不同的.
5. 对象的方法 在我们的示例代码中, 类中有写一个返回值为 int 的 GetSum 方法, 同字段一样, 每个对象都有自己独自的方法, 所以调用后, 返回值是不一定相同的.
下面是演示:
int[] array1 = new[] {1, 2, 3}; int[] array2 = new[] {1, 2, 3, 4, 5}; ArrayHelper helper1 = new ArrayHelper(array1); ArrayHelper helper2 = new ArrayHelper(array2); Console.WriteLine(helper1.GetSum()); // 结果是6 Console.WriteLine(helper2.GetSum()); // 结果是15 同样, 属于对象的方法, 是不能通过类名来调用的, 以下代码是错误的:
Console.WriteLine(ArrayHelper.GetSum()); // 报错, 因为成员是对象的 6. 类的字段: 类也是可以有成员的, 它们独属于某个对象, 它们属于这个类. 这种成员, 被称为静态成员. 例如我们示例代码中的 InsCount 字段.
静态成员是可以被所有实例所访问的, 例如构造函数里面我们指定了为 InsCount 的值增加1, 这就意味着, 我们每实例化一个对象, 这个类的 InsCount 的值都将增加1;
访问类的静态成员, 需要通过类名来访问, 毕竟这个静态成员是属于这个类的. 不可以用实例名来访问, 因为不独属于任何一个实例.
正确示例:
Console.WriteLine(ArrayHelper.InsCount); // 打印类的 InsCount 字段 错误示例:
ArrayHelper helper = new ArrayHelper(); Console.WriteLine(helper.InsCount); // 报错, 因为成员属于类而不是对象 7. 类的方法: 静态方法, 同静态字段一样, 属于整个类, 所有对象可访问, 只能通过类名而无法通过对象名来访问.
例如我们的示例代码中的 ResetInsCount 函数.
正确示例:
ArrayHelper.ResetInsCount(); 错误示例:
ArrayHelper helper = new ArrayHelper(); helper.ResetInsCount(); 8. 析构函数: 析构函数与构造函数相对应, 析构函数将在对象被释放的时候执行, 例如我们代码片中的析构函数:
~ ArrayHelper() { InsCount--; } 即, 每当一个对象被释放, InsCount 的值都会减少1. 配合构造函数来看, 造成的结果就是, InsCount 字段将始终与当前的实例数量保持一致.
9. this 关键字: 有时候啊, 你可能写函数的参数名, 写了个跟成员一模一样的名字, 结果你想给实例成员赋值的时候, 发现实际上确是给方法的参数赋值了.
在一个类的非静态方法中, 想要访问实例的成员, 你可以用 this 来修饰以避免歧义.
下面是使用了 this 关键字的示例代码
public class TestObj { int value; public void SetValue(int value) { this.value = value; } public int GetValue() { return this.value; } } 10. 成员访问限制: 成员有访问限制, 常用的有 公共的(public), 私有的(private), 受保护的(protected), 如果不写修饰符, 那么默认访问限制就是private, 这个我得用一个比较长的代码片来演示了.
修饰符 特征 public 公有的, 无论谁都可以访问 internal 内部的, 位于同一程序集的可以进行访问 protected 受保护的, 除了这个类的成员, 子类也可以进行访问 private 私有的, 仅有这个类的成员可以访问 using System; namespace Null.Tutorial { class TestObj{ { static int insCount = 0; // 没有写访问限制修饰符, 但是默认是private public int[] Source; public TestObj(int[] source) { this.Source = source; insCount++; } ~TestObj() { insCount--; } public int GetSum() { int sum = 0; foreach(var i in Source) sum += i; return sum; } public static int GetInstanceCount() { return insCount; } } class Program { public static void Main(string[] args) { int[] myArr = new int[] {1, 2, 3}; TestObj objIns = new TestObj(myArr); Console.WriteLine(objIns.insCount); // 报错, 因为在类之外访问私有成员 Console.WriteLine(objIns.GetSum()); // 正常访问, 因为是public Console.WriteLine(TestObj.GetInstanceCount()); // 正常访问, 因为是public } } } 11. 属性语法糖 C# 还支持属性这种东西. 其实是语法糖. 属性类似于字段, 举个例子, 你就懂了.
class TestObj { int field3, field4, field5, field6; public int Field1 { get; set; } public int Field2 { get; private set; } public int Field3 => field3 public int Field4 { get => field4; set => field4 = value; } public int Field5 { get { return field5; } set { field5 = value; } } public int Field6 { get => field6; } } 上面的代码中, Field1 ~ Field5 都是属性.
Field1 是开放(public)获取值与设置值的属性, 用法跟字段一致. Field2 是开放(public)获取值, 但设置值是私有的(private)属性, 即, 在类外面可以直接获取值, 但无法设置. Field3 对应私有字段 field3, 它的获取权限是 public, 设置权限是 private Field4 对应私有字段 field4, 获取权限是 public, 设置权限是 private Field5 是属性的完整写法, 其中包含 get 访问器与 set 访问器, 在没有指定个别访问修饰符时, 它们的权限与整个属性的权限一致. Field6 是与私有字段 field6 相对应的, 没有指定 set 访问器的属性, 这意味着它只支持获取值, 不允许设置值, 但是类之内的成员可以直接通过对 field6 进行设置来实现更改属性值. 12. 对象引用 C# 和 Java 中, 有值类型和引用类型, 事实上, 一个 &ldquo;存储&rdquo; 对象的字段, 它包含的是这个对象的引用. 这个的话, C++ 程序员肯定熟悉的一批, 可不就是指针嘛.
Object obj = new Object(); // 创建一个对象, 并使用 obj 字段来存储对象引用 Console.WriteLine(obj); // 通过这个对象引用, 可以直接对对象进行操作. obj = null; 最后一句, 对 obj 字段赋值 null, 肯定会有人以为, 执行完之后, 我们刚刚创建的对象就嗝屁了, 但其实是, 仅仅是这个字段的值为null了.
引用类型的字段就像一个指针, 它有自己的值, 这个值表示对象的内存地址(也有可能是句柄啥的), 总之有这个引用, 就能够找到对象所在的位置. 而给这个字段赋值为null, 也就是改变了这个指针的方向, 让它指向 0x0000, 但事实上对象还存在着.
但是呢, .NET 和 JVM 都有着 GC(Garbage Collection), 即垃圾回收机制. 有一个个步骤来回收这些没用的对象, 到最终, 这些不被引用的托管对象(即被运行时管理的对象)都会被销毁.
还有一个好玩的例子:
int[] myArray = new int[] {1, 2, 3}; int[] another = myArray; another[0] = 100; Console.WriteLine(myArray[0]); // 结果是100 其原理就是, myArray 为最开始创建的数组的对象引用, 我们又将这个引用赋值给 another, 那么 another 跟 myArray 的值一样, 指向我们最开始创建的对象. 即, 通过 another来对数组更改, 其实跟通过 myArray 来更改无异. 因为它们表示同一个对象.
13. 非托管对象 注意, 对象的内存是非常大的, 所以如果不好好管理, 很容易造成内存泄漏. 但对于 .NET 和 Java, 这个问题小了一点, 因为大部分类型都可以被 GC 给清理掉.
但是, 还是存在一些非托管对象的, 例如用户自己分配的内存, 以及 MemoryStream 之类的, 这些内存不会被 GC 清理掉, 用户需要自己管理, 一般这种包含非托管内存的类都会继承 IDisposable 接口, 用户可以调用它们的 Dispose 方法来清理掉这个对象的非托管内存.
2. 一些基本认知: 1. 静态与非静态成员访问: 1. 非静态成员可直接访问静态成员: 这个的话, 稍微想想就能理解. 例如一个厂子里刚造出一辆车, 这个车一看就知道是哪个牌子的, 所以可以轻易的找到这个厂子, 也就是说使用这个厂子里的零配件也是非常简单的, 即非静态成员(实例的成员)可直接访问静态成员(类的成员).
2. 静态成员无法直接访问为静态成员: 同样是汽车的例子, 这个车已经离开厂子了, 如果厂子要查看这个车的一些零配件损坏程度, 肯定是不大方便的, 因为你不知道这个车在哪, 即静态成员(类的成员)无法直接访问非静态成员(实例成员).
3. 通过对象引用来访问非静态成员: 静态成员来访问非静态成员, 肯定有办法访问, 例如这辆车在离开厂子前留下个联系方式, 这样厂子就可以找到这辆车. 下面的代码片是一个例子, 必须有对象引用才可以对其操作.
public class TestObj { static List&lt;TestObj> instances = new List&lt;TestObj>(); private SelfValue = 0; public TestObj() { instances.Add(this); } public int Value => SelfValue; public static ResetAllInstanceValue() { foreach (var ins in instances) instances.SelfValue = 0; } } 喏, 这就是静态方法操作实例成员的示例. 只要你有这个对象的引用, 就可以对这个对象进行操作</content></entry><entry><title>[Web] 子元素设置高度为100%, 却没有与父元素对齐高度.</title><url>https://slimenull.top/post/error-web-wtfsubheight/</url><categories/><tags><tag>Web</tag><tag>HTML</tag><tag>CSS</tag></tags><content type="html"> 如果父元素没有明确的高度, 那么子元素是无法相对父元素来明确高度的
大概描述一下我遇到的情况.
父元素没有明确指定高度, 但是其中一个子元素的高度是确定的, 并且通过这个高度将父元素的高度撑起来. 另一个子元素的高度是100%, 即, 我想要使它与父元素的高度统一.
但是, 指定高度100%的子元素没有与父元素的高度统一.
不过, 如果明确而制定了父元素的高度为某一确定值, 那么这个指定高度100%的子元素的高度就生效了.
奇怪的玄学问题增加了
有几种解决方式供参考:
使用绝对定位, 设置top和bottom为0 使用表格布局, 直接指定display为table</content></entry><entry><title>[Web] Margin 失效问题, 设置了 Margin 却不见效果, 解决方案.</title><url>https://slimenull.top/post/error-web-wtfmargin/</url><categories/><tags><tag>Web</tag><tag>HTML</tag><tag>CSS</tag></tags><content type="html"> 这个问题一般被成为 margin 塌陷, 为父元素指定 overflow: hidden 即可解决
首先演示下:
.box1{ width: 300px; height: 300px; } .box2{ width: 200px; height: 200px; } .border-with{ border: solid 1px purple; } .padding-with{ padding: 1px; } .style-pink{ background-color: pink; } .style-green{ background-color: green; } .margin-able{ margin: 10px; } .margin-fix{ overflow: hidden; } &lt;div class="box1 style-pink">&lt;/div> &lt;div class="box1 style-pink margin-able"> &lt;div class="box2 style-green margin-able">&lt;/div> &lt;/div> 效果:
发现, 绿色盒子我们明明定义了margin, 而顶部的margin却没有起作用.
审查元素, 发现是这个情况:
并且发现, 如果指定padding或border, 那么它们就会变得正常.
最好的修复方式是这样, 为父元素指定overflow为hidden:
可以给出一个我猜测的结论. margin是只是指与其他元素的间距, 即便它叫外边距. 因为父元素已经与上面的元素间距为5, 并且子元素没办法与别的元素产生边距, 所以就相对于最上方的元素计算边距, 即相对于父元素的间距是0. 而如果我们指定了border或padding, 他就会相对这多出的控件来运算边距, 即此时的margin相对于父元素.
另外overflow也是一个奇妙的样式, 它还可以用来修复子元素float引起的高度塌陷问题.</content></entry><entry><title>[C#] 好耶! 是幻影坦克! 原理讲解, 完整类库, 现成代码.</title><url>https://slimenull.top/post/csharp-phantomtank/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>图像</tag><tag>算法</tag><tag>笔记</tag></tags><content type="html"> 啥是幻影坦克, 一张黑白图片, 在黑色背景下和白色背景下能够显示出不同的图像. 其基本原理是空指图片的颜色与不透明度以使图片在不同的背景下显现出不同的颜色.
首先, 我可以明确的告诉你, 它的原理就是控制像素的颜色和Alpha通道(不透明度), 来使显示的图像在不同背景下显示不同的颜色.
最基本的, 就是, 一张半透明的黑色薄膜, 如果在黑色的纸上, 你什么也看不出来, 但如果在白色纸上, 你可以看见, 它是灰色.
本文中, Alpha 统一拟定为 0 ~ 1 的浮点数, 像素亮度统一为 0 ~ 1 即像素&rsquo;白的程度&rsquo;, 例如纯白为1, 纯黑则0.
注意: 本项目已经在 github.com/SlimeNull/Null.PhantomTank
开源. 你可以直接 clone 下来以查看源码.
幻影坦克合成库, NullLib.PhantomTank 已经发布到 nuget.org
, 你可以直接在 VS 的 nuget 包管理器中直接安装本库
基本原理: 像素在某背景下最终显示出来的公式如下:
设: 这个图像的背景亮度为 $bc$, 这个像素的亮度为 $pc$, 不透明度为 $pa$, 则最终显示的颜色 $oc$ 就是: $$ oc = pc * pa + bc * (1 - pa) $$
理解起来也简单, 还拿刚刚的例子来讲, 例如一个纯黑的半透明薄膜, 那他肯定:
只有一半的黑色能显示出来, 即 $pc * pa$ 而背景色, 也有一半的颜色能够透过来. 即: $bc * (1 - pa)$ 总的颜色加起来, 也就是 $pc * pa + bc * (1 - pa)$ 幻影坦克: 而当一个像素为白色背景时, 能够显示出一个特定的颜色 $x$, 当黑色背景时, 显示出 $y$, 也可得出一个公式,
设: 颜色 $x$ 的亮度为 $xc$, 颜色 $y$ 的亮度为 $yc$, 这个像素的亮度为 $zx$, 不透明度为 $za$, 则满足: $$ \begin{cases} xc = za \times zc + (1 - za) \ yc = za \times zc \end{cases} $$
稍微处理一下, 可得到下面的公式: $$ \begin{cases} xc = yc + 1 \times (1 - za) \ yc = xc - 1 \times (1 - za) \ za = -[(xc - yc) \div 1] + 1 \ \end{cases} \ \downarrow \ \begin{cases} xc = yc + 1 - za \ yc = xc + za - 1 \ za = yc - xc + 1 \ \end{cases} $$
由于 $xc$, $yc$, $zc$, $za$ 都是小于等于1, 大于等于0的值, 所以: $$ \begin{cases} 1 \geq xc \geq 0 \ 1 \geq yc \geq 0 \ 1 \geq za \geq 0 \ \end{cases} \ \downarrow \ \begin{cases} 1 \geq yc + 1 - za \geq 0 \ 1 \geq xc + za - 1 \geq 0 \ 1 \geq yc - xc + 1 \geq 0 \ \end{cases} \ \downarrow \ \begin{cases} 0 \geq yc - za \geq -1 \ 2 \geq yc + za \geq 1 \ 0 \geq yc - xc \geq -1 \ \end{cases} \ \downarrow \ \begin{cases} za \geq yc \ xc + za \geq 1 \ xc \geq yc \end{cases} \ \ _\text{最终得到的不等式, 则是我们的 x 和 y 需要满足的条件.} \\ _\text{只有 x 和 y 像素满足这些条件, za 和 zc 才有值} $$
最终我们需要的算式是这些: $$ \begin{cases} zc = yc \div za \ za = yc - xc + 1 \end{cases} $$
而 ARGB 通道的值是 0 ~ 255, 所以需要进行转换一下: $$ \begin{cases} zc = yc \div (za \div 255) = yc \times 255 \div za \ za = yc - xc + 255 \end{cases} $$
而刚刚我们需要满足的条件, 其中只有一个是我们真正需要进行处理的, 即: $$ xc \geq yc $$
解决方案: 关于 $xc \geq yc$ 的条件, 很简单, $xc$ 与 $yc$ 的值是在 $0$ 到 $255$ 之内的, 那我们只需要将其压制到 $128$ 到 $255$ 之间, 将 $yc$ 压制到 $0$ 到 $127$ 之间, 即可解决. 然后就可以直接用我们得出的公式来运算了.
Color CalcPixel(Color x, Color y) { int xc = (x.R + x.G + x.B) / 3, yc = (y.R + y.G + z.B) / 3; // 获取亮度 xc = (xc / 255f) * 127 + 128; yc = (yc / 255f) * 127; // 压制颜色 int za = yc - xc + 255, zc = za == 0 ? 0 : yc * 255 / za; // 运算结果颜色 return Color.FromArgb(ya, yc, yc, yc); } 我们还可以加点功能, 就是 x 与 y 的颜色占用比例, 例如, 刚刚的就是 1:1, 如果是 10 : 245, 则 x 占用 245 ~ 255, y 占用 0 ~ 245.
// src1ColorRatio 为 x 的占用比例, 值域是0~1 Color CalcPixel(Color src1, Color src2, float src1ColorRatio = 0.5f) { float src2ColorRatio = 1 - src1ColorRatio; // 运算出 y 的占用比例 int xc = (int)((src1.R + src1.G + src1.B) * src1ColorRatio / 3 + src2ColorRatio * 255 + 1), yc = (int)((src2.R + src2.G + src2.B) * src2ColorRatio / 3); int za = yc - xc + 255, zc = za == 0 ? 0 : (yc * 255 / za); return Color.FromArgb(za, zc, zc, zc); } 完整代码: 需要的库:
System.Drawing 程序集或 System.Drawing.Common 包. LockBitmap 源码:
using System; using System.Drawing; using System.Drawing.Imaging; using System.Runtime.InteropServices; namespace Null.PhantomTank.Library { public class LockBitmap : IDisposable { Bitmap source = null; IntPtr Iptr = IntPtr.Zero; BitmapData bitmapData = null; public byte[] Pixels { get; set; } public int Depth { get; private set; } public int Width { get; private set; } public int Height { get; private set; } public bool IsLocked { get; private set; } private Func&lt;int, Color> colorGetter; private Action&lt;int, Color> colorSetter; public LockBitmap(Bitmap source) { this.source = source; LockBits(); } /// &lt;summary> /// Lock bitmap data /// &lt;/summary> public void LockBits() { try { // Get width and height of bitmap Width = source.Width; Height = source.Height; // get total locked pixels count //int PixelCount = Width * Height; // Create rectangle to lock System.Drawing.Rectangle rect = new System.Drawing.Rectangle(0, 0, Width, Height); // get source bitmap pixel format size Depth = System.Drawing.Bitmap.GetPixelFormatSize(source.PixelFormat); // Check if bpp (Bits Per Pixel) is 8, 24, or 32 if (Depth == 8) { colorGetter = (offset) => Color.FromArgb(Pixels[offset], Pixels[offset], Pixels[offset]); colorSetter = (offset, color) => { Pixels[offset] = color.B; }; } else if (Depth == 24) { colorGetter = (offset) => Color.FromArgb(Pixels[offset + 2], Pixels[offset + 1], Pixels[offset]); colorSetter = (offset, color) => { Pixels[offset] = color.B; Pixels[offset + 1] = color.G; Pixels[offset + 2] = color.R; }; } else if (Depth == 32) { colorGetter = (offset) => Color.FromArgb(Pixels[offset + 3], Pixels[offset + 2], Pixels[offset + 1], Pixels[offset]); colorSetter = (offset, color) => { Pixels[offset] = color.B; Pixels[offset + 1] = color.G; Pixels[offset + 2] = color.R; Pixels[offset + 3] = color.A; }; } else { throw new ArgumentException("Only 8, 24 and 32 bpp images are supported."); } // Lock bitmap and return bitmap data bitmapData = source.LockBits(rect, ImageLockMode.ReadWrite, source.PixelFormat); // create byte array to copy pixel values int step = Depth / 8; Pixels = new byte[bitmapData.Stride * Height]; Iptr = bitmapData.Scan0; IsLocked = true; // Copy data from pointer to array Marshal.Copy(Iptr, Pixels, 0, Pixels.Length); } catch (Exception ex) { throw ex; } } /// &lt;summary> /// Unlock bitmap data /// &lt;/summary> public void UnlockBits() { try { // Copy data from byte array to pointer Marshal.Copy(Pixels, 0, Iptr, Pixels.Length); // Unlock bitmap data source.UnlockBits(bitmapData); IsLocked = false; } catch (Exception ex) { throw ex; } } /// &lt;summary> /// Get the color of the specified pixel /// &lt;/summary> /// &lt;param name="x">&lt;/param> /// &lt;param name="y">&lt;/param> /// &lt;returns>&lt;/returns> public Color GetPixel(int x, int y) { Color clr = Color.Empty; // Get color components count int cCount = Depth / 8; // Get start index of the specified pixel //int i = ((y * Width) + x) * cCount; int i = y * bitmapData.Stride + x * cCount; if (i > Pixels.Length - cCount) throw new IndexOutOfRangeException(); // Get color by array index clr = colorGetter.Invoke(i); return clr; } /// &lt;summary> /// Set the color of the specified pixel /// &lt;/summary> /// &lt;param name="x">&lt;/param> /// &lt;param name="y">&lt;/param> /// &lt;param name="color">&lt;/param> public void SetPixel(int x, int y, Color color) { // Get color components count int cCount = Depth / 8; // Get start index of the specified pixel //int i = ((y * Width) + x) * cCount; int i = y * bitmapData.Stride + x * cCount; // Set color by array index and color object colorSetter.Invoke(i, color); } public bool IsValidCoordinate(int x, int y) { return x >= 0 &amp;&amp; x &lt; this.Width &amp;&amp; y > 0 &amp;&amp; y &lt; this.Height; } #region IDisposable Support private bool disposedValue = false; // 要检测冗余调用 protected virtual void Dispose(bool disposing) { if (!disposedValue) { if (disposing) { // TODO: 释放托管状态(托管对象)。 } // TODO: 释放未托管的资源(未托管的对象)并在以下内容中替代终结器。 // TODO: 将大型字段设置为 null。 UnlockBits(); disposedValue = true; } } // TODO: 仅当以上 Dispose(bool disposing) 拥有用于释放未托管资源的代码时才替代终结器。 // ~LockBitmap() { // // 请勿更改此代码。将清理代码放入以上 Dispose(bool disposing) 中。 // Dispose(false); // } // 添加此代码以正确实现可处置模式。 void IDisposable.Dispose() { // 请勿更改此代码。将清理代码放入以上 Dispose(bool disposing) 中。 Dispose(true); // TODO: 如果在以上内容中替代了终结器，则取消注释以下行。 // GC.SuppressFinalize(this); } #endregion } } 幻影坦克制作源码:
using System; using System.Collections.Generic; using System.Drawing; using System.Linq; using System.Text; using Null.PhantomTank.Library; namespace Null.PhantomTank { public static class PhantomTank { /// 像素运算方式 变量 : 源色: Xc Yc, 输出: Za Zc /// 其中: c表示Color, 即颜色亮度, a代表Alpha通道, 即不透明度 /// 备注: 值全部为0~1的比值 /// /// Expr: | Xc = Za * Zc + 1 - Za /// | Yc = Za * Zc /// /// Calc: | Xc = Yc + 1 - Za /// | Yc = Xc + Za - 1 /// | Za = Yc - Xc + 1 /// /// Need: | 1 >= Yc + 1 - Za >= 0, 0 >= Yc - Za >= -1; Then: | Za >= Yc /// | 1 >= Xc + Za - 1 >= 0, 2 >= Xc + Za >= 1; Then: | Xc + Za >= 1 /// | 1 >= Yc - Xc + 1 >= 0, 0 >= Yc - Xc >= -1; Then: | Xc >= Yc /// /// Root: | Zc = Yc / Za /// | Za = Yc - Xc + 1 /// /// Basic Root: | Zc = Yc / (Za / 255) = Yc * 255 / Za /// | Za = Yc - Xc + 255 private static Color CalcPixel(Color src1, Color src2, float src1ColorRatio = 0.5f) { float src2ColorRatio = 1 - src1ColorRatio; int xc = (int)((src1.R + src1.G + src1.B) * src1ColorRatio / 3 + src2ColorRatio * 255), yc = (int)((src2.R + src2.G + src2.B) * src2ColorRatio / 3); int za = yc - xc + 255, zc = za == 0 ? 0 : (yc * 255 / za); return Color.FromArgb(za, zc, zc, zc); } private static float ConvertRatio(float ratio) { return ratio / (ratio + 1); } public const float DefaultRatio = 1; public static Bitmap ResizeBitmap(Bitmap src, Color bgColor, ResizeMode resize, int newWidth, int newHeight) { Size srcSize = src.Size; int srcWidth = srcSize.Width, srcHeight = srcSize.Height; Bitmap result = new Bitmap(newWidth, newHeight, src.PixelFormat); Graphics rstG = Graphics.FromImage(result); rstG.Clear(bgColor); Size destSize; Rectangle srcRect, destRect; switch(resize) { case ResizeMode.NoResize: destRect = new Rectangle((newWidth - srcWidth) / 2, (newHeight - srcHeight) / 2, srcWidth, srcHeight); rstG.DrawImageUnscaled(src, destRect); break; case ResizeMode.Stretch: srcRect = new Rectangle(0, 0, srcWidth, srcHeight); destRect = new Rectangle(0, 0, newWidth, newHeight); rstG.DrawImage(src, destRect, srcRect, GraphicsUnit.Pixel); break; case ResizeMode.Uniform: srcRect = new Rectangle(0, 0, srcWidth, srcHeight); destSize = new Size(newWidth, srcHeight * newWidth / srcWidth); if (destSize.Height > newHeight) destSize = new Size(srcWidth * newHeight / srcHeight, newHeight); destRect = new Rectangle(new Point((newWidth - destSize.Width) / 2, (newHeight - destSize.Height) / 2), destSize); rstG.DrawImage(src, destRect, srcRect, GraphicsUnit.Pixel); break; case ResizeMode.UniformToFill: srcRect = new Rectangle(0, 0, srcWidth, srcHeight); destSize = new Size(newWidth, srcHeight * newWidth / srcWidth); if (destSize.Height &lt; newHeight) destSize = new Size(srcWidth * newHeight / srcHeight, newHeight); destRect = new Rectangle(new Point((newWidth - destSize.Width) / 2, (newHeight - destSize.Height) / 2), destSize); rstG.DrawImage(src, destRect, srcRect, GraphicsUnit.Pixel); break; } return result; } /// &lt;summary> /// 最基本的合成方法, 请保证图片尺寸是一致的 /// &lt;/summary> /// &lt;param name="src1">在白底下可以看到的图片&lt;/param> /// &lt;param name="src2">在黑底下可以看到的图片&lt;/param> /// &lt;returns>合并后的黑白图像&lt;/returns> public static Bitmap BasicCombineBitmap(Bitmap src1, Bitmap src2, float colorRatio) { if (src1 == null || src2 == null) throw new ArgumentNullException(); if (src1.Size != src2.Size) throw new ArgumentOutOfRangeException(); Size srcSize = src1.Size; int width = srcSize.Width, height = srcSize.Height; Bitmap result = new Bitmap(width, height, src1.PixelFormat); result.SetResolution(src1.HorizontalResolution, src1.VerticalResolution); LockBitmap lbmp1 = new LockBitmap(src1); LockBitmap lbmp2 = new LockBitmap(src2); LockBitmap lrst = new LockBitmap(result); float whiteRatio = ConvertRatio(colorRatio); for (int i = 0; i &lt; height; i++) { for (int j = 0; j &lt; width; j++) { Color srcPixel1 = lbmp1.GetPixel(j, i), srcPixel2 = lbmp2.GetPixel(j, i), outPixel = CalcPixel(srcPixel1, srcPixel2, whiteRatio); lrst.SetPixel(j, i, outPixel); } } lbmp1.UnlockBits(); lbmp2.UnlockBits(); lrst.UnlockBits(); return result; } /// &lt;summary> /// 转换图片 /// &lt;/summary> /// &lt;param name="src">源图&lt;/param> /// &lt;param name="tankType">坦克类型&lt;/param> /// &lt;returns>转换结果&lt;/returns> public static Bitmap ConvertBitmap(Bitmap src, TankType tankType) { Size srcSize = src.Size; int srcWidth = srcSize.Width, srcHeight = srcSize.Height; Bitmap result = new Bitmap(srcWidth, srcHeight, src.PixelFormat); result.SetResolution(src.HorizontalResolution, src.VerticalResolution); LockBitmap lsrc = new LockBitmap(src); LockBitmap lrst = new LockBitmap(result); Func&lt;int, Color> pixelCalcFunc; switch (tankType) { case TankType.AppearOnBlack: pixelCalcFunc = (srcPixel) => Color.FromArgb(srcPixel, 255, 255, 255); break; case TankType.AppearOnWhite: pixelCalcFunc = (srcPixel) => Color.FromArgb(255 - srcPixel, 0, 0, 0); break; default: throw new InvalidOperationException("Not supported."); } for (int i = 0; i &lt; srcHeight; i++) { for (int j = 0; j &lt; srcWidth; j++) { Color pixel = lsrc.GetPixel(j, i); int light = (pixel.R + pixel.G + pixel.B) / 3; lrst.SetPixel(j, i, pixelCalcFunc.Invoke(light)); } } lsrc.UnlockBits(); lrst.UnlockBits(); return result; } public static Bitmap ConvertImage(Image src, TankType tankType) { Bitmap newSrc = new Bitmap(src); Bitmap result = ConvertBitmap(newSrc, tankType); newSrc.Dispose(); return result; } public static Bitmap CombineBitmap(Bitmap src1, Bitmap src2, Color bgColor1, Color bgColor2, ResizeMode resize, float colorRatio) { Size src1Size = src1.Size, src2Size = src2.Size; int src1Width = src1Size.Width, src1Height = src1Size.Height, src2Width = src2Size.Width, src2Height = src2Size.Height; int maxWidth = src1Width > src2Width ? src1Width : src2Width, maxHeight = src1Height > src2Height ? src1Height : src2Height; Bitmap newSrc1 = new Bitmap(maxWidth, maxHeight, src1.PixelFormat), newSrc2 = new Bitmap(maxWidth, maxHeight, src2.PixelFormat); Graphics srcG1 = Graphics.FromImage(newSrc1), srcG2 = Graphics.FromImage(newSrc2); srcG1.Clear(bgColor1); srcG2.Clear(bgColor2); // 这里进行的是对图片的重新调整尺寸操作 switch(resize) { case ResizeMode.NoResize: srcG1.DrawImageUnscaled(src1, (maxWidth - src1Width) / 2, (maxHeight - src1Height) / 2); srcG2.DrawImageUnscaled(src2, (maxWidth - src2Width) / 2, (maxHeight - src2Height) / 2); break; case ResizeMode.Stretch: srcG1.DrawImage(src1, new Rectangle(0, 0, maxWidth, maxHeight), new Rectangle(0, 0, src1Width, src1Height), GraphicsUnit.Pixel); srcG2.DrawImage(src2, new Rectangle(0, 0, maxWidth, maxHeight), new Rectangle(0, 0, src2Width, src2Height), GraphicsUnit.Pixel); break; case ResizeMode.Uniform: Size scaleSize1 = new Size(maxWidth, (int)(src1Height * ((float)maxWidth / src1Width))), scaleSize2 = new Size(maxWidth, (int)(src2Height * ((float)maxWidth / src2Width))); if (scaleSize1.Height > maxHeight) scaleSize1 = new Size((int)(src1Width * ((float)maxHeight / src1Height)), maxHeight); if (scaleSize2.Height > maxHeight) scaleSize2 = new Size((int)(src2Width * ((float)maxHeight / src2Height)), maxHeight); srcG1.DrawImage(src1, new Rectangle(new Point((maxWidth - scaleSize1.Width) / 2, (maxHeight - scaleSize1.Height) / 2), scaleSize1), new Rectangle(0, 0, src1Width, src1Height), GraphicsUnit.Pixel); srcG2.DrawImage(src2, new Rectangle(new Point((maxWidth - scaleSize2.Width) / 2, (maxHeight - scaleSize2.Height) / 2), scaleSize2), new Rectangle(0, 0, src2Width, src2Height), GraphicsUnit.Pixel); break; case ResizeMode.UniformToFill: Size scaleFillSize1 = new Size(maxWidth, (int)(src1Height * ((float)maxWidth / src1Width))), scaleFillSize2 = new Size(maxWidth, (int)(src2Height * ((float)maxWidth / src2Width))); if (scaleFillSize1.Height &lt; maxHeight) scaleFillSize1 = new Size((int)(src1Width * ((float)maxHeight / src1Height)), maxHeight); if (scaleFillSize2.Height &lt; maxHeight) scaleFillSize2 = new Size((int)(src2Width * ((float)maxHeight / src2Height)), maxHeight); srcG1.DrawImage(src1, new Rectangle(new Point((maxWidth - scaleFillSize1.Width) / 2, (maxHeight - scaleFillSize1.Height) / 2), scaleFillSize1), new Rectangle(0, 0, src1Width, src1Height), GraphicsUnit.Pixel); srcG2.DrawImage(src2, new Rectangle(new Point((maxWidth - scaleFillSize2.Width) / 2, (maxHeight - scaleFillSize2.Height) / 2), scaleFillSize2), new Rectangle(0, 0, src2Width, src2Height), GraphicsUnit.Pixel); break; } srcG1.Dispose(); srcG2.Dispose(); Bitmap result = BasicCombineBitmap(newSrc1, newSrc2, colorRatio); // 调用最终合成方法 newSrc1.Dispose(); newSrc2.Dispose(); return result; } public static Bitmap CombineBitmap(Bitmap src1, Bitmap src2, Color bgColor1, Color bgColor2, ResizeMode resize) { return CombineBitmap(src1, src2, Color.White, Color.Black, resize, DefaultRatio); } public static Bitmap CombineBitmap(Bitmap src1, Bitmap src2, Color bgColor1, Color bgColor2, float colorRatio) { return CombineBitmap(src1, src2, Color.White, Color.Black, ResizeMode.NoResize, DefaultRatio); } public static Bitmap CombineBitmap(Bitmap src1, Bitmap src2, ResizeMode resize, float colorRatio) { return CombineBitmap(src1, src2, Color.White, Color.Black, resize, colorRatio); } public static Bitmap CombineBitmap(Bitmap src1, Bitmap src2, ResizeMode resize) { return CombineBitmap(src1, src2, Color.White, Color.Black, resize, 0); } public static Bitmap CombineBitmap(Bitmap src1, Bitmap src2, float colorRatio) { return CombineBitmap(src1, src2, Color.White, Color.Black, ResizeMode.NoResize, colorRatio); } public static Bitmap CombineBitmap(Bitmap src1, Bitmap src2) { return CombineBitmap(src1, src2, Color.White, Color.Black, ResizeMode.NoResize, DefaultRatio); } public static Bitmap CombineImage(Image src1, Image src2, Color bgColor1, Color bgColor2, ResizeMode resize, float colorRatio) { Bitmap newSrc1 = new Bitmap(src1), newSrc2 = new Bitmap(src2); Bitmap result = CombineBitmap(newSrc1, newSrc2, bgColor1, bgColor2, resize, colorRatio); newSrc1.Dispose(); newSrc2.Dispose(); return result; } public static Bitmap CombineImage(Image src1, Image src2, Color bgColor1, Color bgColor2, ResizeMode resize) { return CombineImage(src1, src2, Color.White, Color.Black, resize, DefaultRatio); } public static Bitmap CombineImage(Image src1, Image src2, Color bgColor1, Color bgColor2, float colorRatio) { return CombineImage(src1, src2, Color.White, Color.Black, ResizeMode.NoResize, colorRatio); } public static Bitmap CombineImage(Image src1, Image src2, ResizeMode resize, float colorRatio) { return CombineImage(src1, src2, Color.White, Color.Black, resize, colorRatio); } public static Bitmap CombineImage(Image src1, Image src2, ResizeMode resize) { return CombineImage(src1, src2, Color.White, Color.Black, resize, DefaultRatio); } public static Bitmap CombineImage(Image src1, Image src2, float colorRatio) { return CombineImage(src1, src2, Color.White, Color.Black, ResizeMode.NoResize, colorRatio); } public static Bitmap CombineImage(Image src1, Image src2) { return CombineImage(src1, src2, Color.White, Color.Black, ResizeMode.NoResize, DefaultRatio); } } public enum ResizeMode { NoResize, Stretch, Uniform, UniformToFill, } public enum TankType { AppearOnBlack, AppearOnWhite, } } $\downarrow$ 点个赞再走呗! $\downarrow$</content></entry><entry><title>[安利] 什么鬼? 居然还有人不会截图??? 还在用手机对着电脑屏幕拍照????? 各种截图方式大集结!</title><url>https://slimenull.top/post/sth-screencapture/</url><categories/><tags><tag>杂</tag></tags><content type="html"> Windows截屏工具, Win10截图快捷键, QQ &amp; 微信, Snipaste, ShareX 各种截图方式
某天, 我在一群里看到了这副画面&hellip; 我的天哪!!! 他居然!!! 还在用手机拍照! 简直妄为技术人! 得, 我今天就全方面得介绍一波你在电脑中可以进行截图的方式吧!
截图方式: 首先啊, 截图还是有不同的存储方式的, 像是手机里, 一般都是保存为文件, 电脑上当然也支持这种方式, 当然最最最好用的! 还是截图到剪切板. (不知道剪切板的可以重开人生以谢罪了)
而这种方式保存的图呢, 一般用于粘贴出来. 例如 QQ 微信 的消息输入框, 你可以直接粘贴位于剪切板中的内容. 像是PS, Word, MSPaint(画图), 这些程序也是支持粘贴图片的! 当然当然, CSDN 的 Markdown 编辑器也是支持粘贴图片的, 自动上传图片到 CSDN, 挺好用的哈哈.
通用截图: PrtSc 以及与之相关的截图快捷键: 各个系统! 通用的截图快捷键!!! PrtSc 键! 全称是 Print Screen, 按下它的作用是, 将整块屏幕的内容截取, 然后存储在剪切板中. 还有 Alt + PrtSc, 它是将当前的活动窗口的内容截取, 存储到剪切板.
例如这样, 就是截取整个屏幕的
这样, 就是截取当前活动窗口的, 因为我现在正在使用浏览器, 所以就是浏览器的内容, 不包括底部任务栏: Windows 截图工具: 估计早就没人用了, 建议跳过. 1. SnippingTool: Windows 自带的截图工具. 中文名: 截图工具. 简述: Snipping Tool 是一个很老的工具了, 至少在 XP 就已经存在, 并且, 虽然在 Win10 已经有了更好的截图方式, 不过这个工具还是保留了下来. 效果图: 使用方式: Windows 全局搜索: 运行: 支持功能: 矩形截屏: 在屏幕上拖拽出一个矩形, 并将举行包含的内容保存到剪切板. 自由截屏: 随便画出一个形状, 然后将形状包含的内容保存到剪切板. 窗口截屏: 选择一个窗口, 然后将窗口的内容保存到剪切板. 截屏编辑: 截屏成功后, 会直接进入编辑页面. 并且还支持保存为 JPG, PNG, MHT 文件格式. Win10 截图快捷键: 估计不是很多人会用这个. 1. Win + Shift + S 简述: 是 Windows10 新增的截图快捷键, 截图后直接存储到剪切板, 并且可以在通知栏对图像进行更多操作. 效果图: 支持功能: 矩形截屏: 拖拽一个矩形, 然后截取矩形内的内容保存到剪切板. 自由截屏: 自由选择一个区域, 然后保存到剪切板. 窗口截屏: 选择窗口截屏, 保存到剪切板. 截取全屏: 点击, 即截取全屏并保存到剪切板. 截屏编辑: 截屏成功的项目(Item), 可以在通知中查看, 点击, 即进入对该图的编辑. QQ &amp; 微信: 不用说, 肯定有人不知道 QQ 和微信还有截图功能! 1. QQ: Ctrl + Alt + A: 简述: QQ 的默认截屏快捷键是 Ctrl + Alt + A, 温馨提示, QQ 的截屏功能非常强大, 是前面两个方式无法比拟的. 效果图: 按 Ctrl + Alt + A 进入截图, 支持功能: 矩形截屏: 正如刚刚演示的, 直接拖拽即可截取矩形区域, 并存储到剪切板. 置顶贴纸: 截取一个区域后, 先不要确认, 点击一个钉子图标, 即可将截取的区域置顶悬浮, 并且可拖拽. 双击可关闭. 文本识别与翻译功能: 选择完一个区域后, 还支持文本识别和翻译功能. 编辑功能: 选择完矩形区域, 进入编辑模式, 下面有非常多的选项可供使用. 从左到右, 依次是这些: 2. 微信: Alt + A: 简述: 微信的默认截屏键是 Alt + A, 不过微信的截屏相比 QQ 来讲, 就弱很多了, 没多少功能, 没有置顶贴纸功能. 效果图: 支持功能: 矩形截屏: 跟 QQ 一模一样, 就不放图了 编辑功能: 弱化版的 QQ 截图编辑, 只有形状, 箭头, 马赛克, 文本识别, 别的都没有. 第三方工具: 好了! 重点来了! QQ 的截图是强大了, 但是有的时候你不联网, 没办法登陆 QQ, 可不是就不能用 QQ 的截图了?
1. Snipaste: 简述: 官方网站: www.snipaste.com
一个非常强大的截图工具! 完全能够替代 QQ, 相比较 QQ, 它没有文本识别和长截图功能. 但是它可以作为一个非常好用的取色器(虽然 QQ 也彳亍, 但是 Snipaste 更好用) 在各个工具上, 比 QQ 要细致更多! 例如 Snipaste 的有模糊工具和马赛克工具这两种, 并且可以调整模糊程度; 矩形工具和椭圆工具中, Snipaste 可以还放置实心的形状, 而 QQ 仅仅支持单线边框的形状. 支持截图时微调, 通过 WSAD 按键, 可以一个像素一个像素的移动鼠标光标, 通过箭头, 可以移动整个选框的位置, 也是逐像素. 更方便的快捷键, Snipaste 支持通过快捷键来将最后一个截取的图片作为置顶贴纸放置出来, 这是 QQ 所不支持的. 更厉害的贴纸, 如果你复制了一个十六进制颜色代码, RGB颜色码, 一段文本, 或者是 Excel 表格中的内容, 这时你将它贴在屏幕上, Snipaste 会为你展示所有你需要的信息. 支持多种语言, 自动适配系统区域设置. 效果图: 支持功能: 矩形截屏: Snipaste 的默认截屏快捷键是 F1, 使用方式上与 QQ 的截屏没有太大的差异. 置顶贴纸: 当你截屏完毕后, 可以直接通过 F3 来将这个图像贴在屏幕上, 同样可移动, 并且还支持鼠标滚轮调整大小. 双击可关闭. 更细致的贴纸: 对于文本, 颜色值, 表格内容, 贴纸都有进行处理. 非常完美的格式化! 显示/隐藏 所有贴纸: Snipaste 还支持临时隐藏所有的贴纸, 稍后可再次显示出来. 快捷键: Shift + F3 2. ShareX: 简述: 好了好了! 大佬要来了! ShareX 可谓是一个非常强大的程序, 截图, 取色器, 屏幕取色器, 屏幕录制, 屏幕录制(GIF), 图像上传(到图床), 视频转格式, 程序图: 支持的功能: 写这么多真的是累死我了&hellip; 反正看这个界面图也差不多理解了, 我就截几个图放出来好了. 但是! ShareX 是一个超级厉害的软件啊啊啊啊! 一定要试试!
截图 工具: 快捷键编辑: 最后说两句: 贴纸功能是真的好用啊淦! 我写文章的时候, 直接把 ShareX 的程序界面截取, 然后贴在屏幕上, 就可以慢慢一个个介绍了! 总的来说, 储了最开始那个老工具和Win10截屏快捷键, 我还是都挺推荐的! 平常使用我一直用的 Snipaste, 截图和贴纸最常用, 然后录制 GIF 的时候, 就使用 ShareX. 毕竟录制 GIF 无非在 QQ 里发一些奇妙内容, 而没有多少人愿意去用 MP4 格式. 因为 GIF 自动播放的. (尽管大多数情况, MP4比GIF小, 质量又好) 然后!!! 我再吹一波 ShareX! ShareX 的 GIF 录制是真的厉害! 我完全不知道它是如何压缩的图片大小. 质量非常棒! 而且 ShareX 的 MP4 录制, 大小压缩的是真的彳亍! Data Rate 仅有 397 kbps 的情况下, 居然完全能够保证质量! (听朋友说是压缩算法, 计算运动轨迹什么的, 估计仅在屏幕单调内容录制的情况下效果好.)</content></entry><entry><title>[C#] 就让这张图片来揭露你的本性吧! 老绅士.</title><url>https://slimenull.top/post/csharp-hentaiimg/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>图像</tag><tag>算法</tag><tag>笔记</tag></tags><content type="html"> 在一张图片中填满字, 或者用字来构成一整张彩色图片
看到上面那幅图了吗? 放大, 放大, 看到了吗? 说的就是你 .
淦! 1. 正常的: 简单的, 就是最开始那张图片了, 看起来还彳亍, 对吧
好吧, 这种东西, 实现起来也不难, 无非是在图片中写字. 写字你总会吧? 我直接贴 Graphics 元数据:
namespace System.Drawing { // // 摘要: // 封装一个 GDI+ 绘图图面。 此类不能被继承。 public sealed class Graphics : MarshalByRefObject, IDeviceContext, IDisposable { // // 摘要: // 在指定位置并且用指定的 System.Drawing.Brush 和 System.Drawing.Font 对象绘制指定的文本字符串。 // // 参数: // s: // 要绘制的字符串。 // // font: // System.Drawing.Font，它定义字符串的文本格式。 // // brush: // System.Drawing.Brush，它确定所绘制文本的颜色和纹理。 // // point: // System.Drawing.PointF 结构，它指定所绘制文本的左上角。 // // 异常: // T:System.ArgumentNullException: // brush 为 null。 或 - s 为 null。 public void DrawString(string s, Font font, Brush brush, PointF point); } } 懂了吧? 当然本程序可没那么简单嘿嘿! 我可是还实现了类似于蒙版的东西! (好吧也不是很难)
2. 难一点的: 看出有什么区别没? 没错! 你发现, 背景变成单色, 而字变成彩色的了!!! 当然 PS 用剪切蒙版很容易实现. 那么, 用 C# 该如何实现呢?
首先创建一个位图, 作为我们的临时空间, 背景是黑色, 然后用白色的笔在上面写字. 哦豁, 这不就是一张蒙版吗?
我们的源图像跟这个蒙版图是一样大小的, 输出图像当然也同样大小, 然后遍历原图像的像素, 并且判断蒙版图像的颜色, 如果蒙版图像的颜色是白色, 则把这个像素拷贝到输出图像中. 于是于是! 就实现了画彩色的字! (好吧的确有点投机取巧的意味.)
3. 简单点的: 哈哈哈, 每一个字, 都相当于原图的一个像素, 可不可以说是变相的字符画?
完整的内容介绍: Null.CharImg: 字符图像混合工具 Null.CharImg [ -{CharWidth | CWidth} 字符占宽 ] [ -{CharHeight | CHeight} 字符占高 ] [ -{MaxWidth | MWidth} 最大宽度 ] [ -{MaxHeight | MHeight} 最大高度 ] [ -{FontSize | FSize} 字体大小 ] [ -{String | Str} 字符串内容 ] [ -{CorrectRate | CRate} 颜色矫正程度] [ -{BackgroundColor | BgColor} 背景颜色 ] [ -{FontFamily | Font} 字体 ] [ /{FontBold | Bold} ] [ /{Opposite | Oppo} ] [ /{AutoCorrect | Correct}] [ /{AutoBackground | AutoBg}] [ /{HighDefinition | HD}] -{Output | Out} 输出路径 *源文件 Null.CharImg /{Help | H | ?} 显示本帮助内容 其中参数的概述如下: 字符占宽, 指图像中, 一个字符独占的宽度, 默认8 字符占高, 字符独占的高度, 与字符占宽决定了字符的间距, 默认16 最大宽度, 指输出图像中, 横向最多含多少个字符 最大高度, 指输出图像中, 纵向最多含多少个字符 字体大小, 指字体大小, 单位是像素, 默认16 字符串内容, 要显示在图像中的字符, 将逐个显示 颜色矫正程度, 指定了自动颜色矫正的程度, 值域是0~100, 默认100 背景颜色, 表示图像背景颜色, 使用十六进制代码表示 输出路径, 表示输出图像的保存路径 字体, 表示图像中字符所使用的字体, 默认是Sans Serif FontBold, 粗体, 表示是否使用粗体 Opposite, 使背景与前景颜色反转 AutoCorrect, 自动矫正颜色 AutoBackground, 自动判断背景色 HighDefinition, 高分辨率模式 关于自动矫正颜色: 自动矫正颜色旨在尝试调节前景色的色彩, 以做到前景与背景结合时, 颜色 趋近于原图, 如果背景颜色指定了亮度较高的颜色, 例如白色, 这个功能会 启到很好的作用, 如果你认为颜色矫正有些严重, 可以使用 CorrectRate 参数来指定自动调节的力度, 尝试调节为80, 甚至更低的值来适应. 关于自动判断背景色 当启动该功能时, 用户设置的颜色作废, 程序会自动计算整个原图像的平均色 作为输出图像的背景色 关于高分辨率模式: 当启用高分辨率时, 图像中的一个字符不再单单是一种颜色, 而是使用彩色, 以使输出图像更能趋近于原图的形状与颜色, 同时Opposite也是受支持的 关于程序: 作者: 诺尔, Null; 擅长:摸鱼 Github仓库: https://github.com/SlimeNull/Null.CharImg 如果有啥感到迷惑的, 在下方留言噢~</content></entry><entry><title>[C#] 绘制函数图像! 可拖动, 可缩放, 可调整精度</title><url>https://slimenull.top/post/csharp-drawfunc/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>算法</tag><tag>图像</tag><tag>轮子</tag></tags><content type="html"> WinForm, 借助 Graphics 绘制函数图像, 可拖动, 可缩放, 可调整精度, 可自定义表达式
欸嘿, 这就是程序图了, 通过鼠标拖拽可以移动, 鼠标滚轮可以缩放, 右下角还可以选择要绘制的函数. 项目仓库链接在文章末尾
基本原理: Graphics 绘图, 不用我说了吧? 如果你不是很懂, 留言, 我会专门写一篇文章来介绍 Graphics.
带入求值, 没啥难的. 线是一个个点连起来的, 也就是: 然后, 标尺, 也是一个个线呗, 那个数字的话, 就是这个: 填充小三角的话, 就是这个: 关于优化: 首先是计算问题, 保证仅仅计算需要显示的区域, 区域外的坐标不予以计算, 以节省资源.
然后是闪屏问题, 使用BufferedGraphics, 既能解决闪屏问题, 又不会像Bitmap缓冲那样闪屏.
关于绘图闪屏问题, 网上有很多解决方案, 最核心的, 无非是双缓冲, 也就是先将图绘制到缓冲区, 再将缓冲区的内容绘制到屏幕上. 实现双缓冲有两种方式, 一就是通过创建一个Bitmap, 将图画到Bitmap上, 然后画完之后, 再将Bitmap画到屏幕上(Graphics.DrawImage()), 缺点是会造成撕裂问题. 第二种方式是 BufferedGraphics, 这是一个比Bitmap更好用的东西, 不会造成撕裂.
封装一下: using System; using System.Collections.Generic; using System.Drawing; using System.Linq; namespace Null.FuncDraw { public static class FuncDraw { /// &lt;summary> /// 根据数字坐标获取像素位置 /// &lt;/summary> /// &lt;param name="xCoord">x坐标&lt;/param> /// &lt;param name="yCoord">y坐标&lt;/param> /// &lt;param name="xOffset">原点位置&lt;/param> /// &lt;param name="yOffset">原点位置&lt;/param> /// &lt;param name="scale">缩放&lt;/param> /// &lt;returns>像素位置&lt;/returns> public static Point GetPointFromCoords(double xCoord, double yCoord, int xOffset, int yOffset, double scale) { return new Point((int)(xCoord * scale + xOffset), (int)(-yCoord * scale + yOffset)); } /// &lt;summary> /// /// &lt;/summary> /// &lt;param name="coords">数字坐标&lt;/param> /// &lt;param name="offset">原点位置&lt;/param> /// &lt;param name="scale">缩放&lt;/param> /// &lt;returns>像素位置&lt;/returns> public static Point GetPointFromCoords(PointF coords, Point offset, double scale) { return new Point((int)(coords.X * scale + offset.X), (int)(-coords.Y * scale + offset.Y)); } /// &lt;summary> /// 根据像素位置获取数字坐标 /// &lt;/summary> /// &lt;param name="x">水平位置&lt;/param> /// &lt;param name="y">竖直位置&lt;/param> /// &lt;param name="xOffset">原点位置&lt;/param> /// &lt;param name="yOffset">原点位置&lt;/param> /// &lt;param name="scale">缩放&lt;/param> /// &lt;param name="xCoord">输出: 数字X坐标&lt;/param> /// &lt;param name="yCoord">输出: 数字Y坐标&lt;/param> public static void GetCoordsFromPoint(int x, int y, int xOffset, int yOffset, double scale, out double xCoord, out double yCoord) { xCoord = (x - xOffset) / scale; yCoord = -((y - yOffset) / scale); return; } /// &lt;summary> /// 根据像素长度返回数字 /// &lt;/summary> /// &lt;param name="length">像素长度&lt;/param> /// &lt;param name="scale">缩放&lt;/param> /// &lt;returns>数字&lt;/returns> public static double GetNumberFromPixel(int length, double scale) { return length / scale; } /// &lt;summary> /// 根据数字来获取它距离原点的像素长度 /// &lt;/summary> /// &lt;param name="number">数字&lt;/param> /// &lt;param name="scale">缩放&lt;/param> /// &lt;returns>像素长度&lt;/returns> public static double GetPixelFromNumber(int number, double scale) { return number * scale; } /// &lt;summary> /// 画函数图像 /// &lt;/summary> /// &lt;param name="func">要画的函数&lt;/param> /// &lt;param name="inputs">X的取值&lt;/param> /// &lt;param name="graphics">绘图Graphics&lt;/param> /// &lt;param name="pen">画线所用的Pen&lt;/param> /// &lt;param name="drawArea">画函数的区域&lt;/param> /// &lt;param name="xOffset">原点的位置&lt;/param> /// &lt;param name="yOffset">原点的位置&lt;/param> /// &lt;param name="scale">缩放参数&lt;/param> public static void DrawFunc(Func&lt;double, double> func, IEnumerable&lt;double> inputs, Graphics graphics, Pen pen, Rectangle drawArea, int xOffset, int yOffset, double scale) { double[] nums = inputs.ToArray(); Point[] coords = new Point[nums.Length]; int drawAreaLeft = drawArea.X, drawAreaRight = drawAreaLeft + drawArea.Width, drawAreaTop = drawArea.Y, drawAreaBottom = drawAreaTop + drawArea.Height; double y; for (int i = 0, len = nums.Length; i &lt; len; i++) // 最近刚知道要少用属性, 毕竟属性的实质是函数, 函数调用需要分配栈空间, 而且似乎还涉及到装箱拆箱, 所以这样效率高一些 { y = func.Invoke(nums[i]); coords[i] = GetPointFromCoords(nums[i], y, xOffset, yOffset, scale); } bool point1xIn1, point1xIn2, point1yIn1, point1yIn2, point2xIn1, point2xIn2, point2yIn1, point2yIn2; for (int i = 1, len = nums.Length; i &lt; len; i++) { Point point1 = coords[i - 1]; Point point2 = coords[i]; point1xIn1 = point1.X >= drawAreaLeft; point1xIn2 = point1.X &lt;= drawAreaRight; point1yIn1 = point1.Y >= drawAreaTop; point1yIn2 = point1.Y &lt;= drawAreaBottom; point2xIn1 = point2.X >= drawAreaLeft; point2xIn2 = point2.X &lt;= drawAreaRight; point2yIn1 = point2.Y >= drawAreaTop; point2yIn2 = point2.Y &lt;= drawAreaBottom; if ((!(point1xIn1 &amp;&amp; point2xIn1)) || (!(point1xIn2 &amp;&amp; point2xIn2)) || (!(point1yIn1 &amp;&amp; point2yIn1)) || (!(point1yIn2 &amp;&amp; point2yIn2))) continue; if (!point1xIn1) point1 = new Point(drawAreaLeft, (int)(point1.Y + (point2.Y - point1.Y) * ((double)drawAreaLeft - point1.X) / (point2.X - point1.X))); // 这里是有一些奇妙优化的, 不要删去. 否则将导致某些函数无法绘制. else if (!point2xIn1) point2 = new Point(drawAreaLeft, (int)(point2.Y + (point1.Y - point2.Y) * ((double)drawAreaLeft - point2.X) / (point1.X - point2.X))); if (!point1xIn2) point1 = new Point(drawAreaRight, (int)(point2.Y + (point1.Y - point2.Y) * ((double)drawAreaRight - point2.X) / (point1.X - point2.X))); else if (!point2xIn2) point2 = new Point(drawAreaRight, (int)(point1.Y + (point2.Y - point1.Y) * ((double)drawAreaRight - point1.X) / (point2.X - point1.X))); if (!point1yIn1) point1 = new Point((int)(point1.X + (point2.X - point1.X) * ((double)drawAreaTop - point1.Y) / (point2.Y - point1.Y)), drawAreaTop); else if (!point2yIn1) point2 = new Point((int)(point2.X + (point1.X - point2.X) * ((double)drawAreaTop - point2.Y) / (point1.Y - point2.Y)), drawAreaTop); if (!point1yIn2) point1 = new Point((int)(point2.X + (point1.X - point2.X) * ((double)drawAreaBottom - point2.Y) / (point1.Y - point2.Y)), drawAreaBottom); else if (!point2yIn2) point2 = new Point((int)(point1.X + (point2.X - point1.X) * ((double)drawAreaBottom - point1.Y) / (point2.Y - point1.Y)), drawAreaBottom); graphics.DrawLine(pen, point1, point2); } } /// &lt;summary> /// 画一个坐标轴 /// &lt;/summary> /// &lt;param name="xNumbers">x轴要画的数&lt;/param> /// &lt;param name="yNumbers">y轴要画的数&lt;/param> /// &lt;param name="graphics">绘图Graphics&lt;/param> /// &lt;param name="brush">填充坐标轴三角所使用的Brush&lt;/param> /// &lt;param name="pen">画坐标轴所使用的Pen&lt;/param> /// &lt;param name="font">画坐标数字所使用的Font&lt;/param> /// &lt;param name="drawArea">画坐标轴的区域&lt;/param> /// &lt;param name="xOffset">原点的位置&lt;/param> /// &lt;param name="yOffset">远点的位置&lt;/param> /// &lt;param name="barLength">坐标轴上小竖线的长度&lt;/param> /// &lt;param name="scale">缩放参数&lt;/param> /// &lt;param name="text">是否绘出数字&lt;/param> public static void DrawShaft(IEnumerable&lt;double> xNumbers, IEnumerable&lt;double> yNumbers, Graphics graphics, Brush brush, Pen pen, Font font, Rectangle drawArea, int xOffset, int yOffset, int barLength, double scale, bool text) { Action&lt;Point, double> drawText; if (text) drawText = (point, num) => graphics.DrawString(num.ToString("F2"), font, brush, point); // 使用委托, 那么接下来就不需要进行多余的对text的判断, 而直接Invoke就彳亍 else drawText = (point, num) => { }; Point yTop = new Point(xOffset, drawArea.Y), yBottom = new Point(xOffset, drawArea.Y + drawArea.Height), // 确认轴的位置 xLeft = new Point(drawArea.X, yOffset), xRight = new Point(drawArea.X + drawArea.Width, yOffset); graphics.DrawLine(pen, yTop, yBottom); // 画轴 graphics.DrawLine(pen, xLeft, xRight); int triangleHeight = (int)(Math.Tan(Math.PI / 3) * barLength); // 坐标轴末端小三角的高度 Point[] triangle1 = new Point[] { yTop, new Point(yTop.X - barLength, yTop.Y + triangleHeight), new Point(yTop.X + barLength, yTop.Y + triangleHeight) }, triangle2 = new Point[] { xRight, new Point(xRight.X - triangleHeight, xRight.Y + barLength), new Point(xRight.X - triangleHeight, xRight.Y - barLength) }; graphics.FillPolygon(brush, triangle1); // 画三角 graphics.FillPolygon(brush, triangle2); foreach (double x in xNumbers) { Point numBase = GetPointFromCoords(x, 0, xOffset, yOffset, scale); Point numEnd = new Point(numBase.X, numBase.Y - barLength); graphics.DrawLine(pen, numBase, numEnd); // 画x轴数 drawText(numBase, x); } foreach (double y in yNumbers) { Point numBase = GetPointFromCoords(0, y, xOffset, yOffset, scale); Point numEnd = new Point(numBase.X + barLength, numBase.Y); graphics.DrawLine(pen, numBase, numEnd); // 画y轴数 drawText(numBase, y); } } } } 注意事项: Graphics 在绘制某些超级远的东西时, 例如这个坐标时 (2147483647,2147483647), 总之就是非常大, 那可能会不能绘制, 报 Overflow 异常
还有一些要用的内容: CSDN 文章: C# 中的 Range 函数
CSDN 文章: C# IEnumerable 连接, 将迭代器串起来
更新记录: 最新版本已经支持自定义函数表达式
项目: 项目仓库: https://github.com/SlimeNull/Null.FuncDraw</content></entry><entry><title>[C#] IEnumerable拼接! 将枚举器串起来~</title><url>https://slimenull.top/post/csharp-concatenumerator/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag></tags><content type="html"> 通过 yield 可以实现很多骚操作, 例如自己定义拓展函数以支持将可迭代对象连接起来
本来以为 IEnumerable 不能拼接, 就自己实现了一个, 结果发现 Linq 是提供了一个 Concat 函数的. 不过, 也没必要删了. 留着做记录也不错
using System; using System.Collections; using System.Collections.Generic; namespace NullLib.Iterator { public static class NIterator { public static IEnumerable Concat(this IEnumerable iterator1, IEnumerable iterator2) { foreach (var i in iterator1) yield return i; foreach (var i in iterator2) yield return i; } public static IEnumerable&lt;T> Concat&lt;T>(this IEnumerable&lt;T> iterator1, IEnumerable&lt;T> iterator2) { foreach (var i in iterator1) yield return i; foreach (var i in iterator2) yield return i; } public static IEnumerable Concat(this IEnumerable iterator1, params IEnumerable[] iterator2) { foreach (var i in iterator1) yield return i; foreach (var i in iterator2) foreach (var j in i) yield return j; } public static IEnumerable&lt;T> Concat&lt;T>(this IEnumerable&lt;T> iterator1, params IEnumerable&lt;T>[] iterator2) { foreach (var i in iterator1) yield return i; foreach (var i in iterator2) foreach (var j in i) yield return j; } public static IEnumerable Concat(params IEnumerable[] iterators) { foreach (var i in iterators) foreach (var j in i) yield return j; } public static IEnumerable&lt;T> Concat&lt;T>(params IEnumerable&lt;T>[] iterators) { foreach (var i in iterators) foreach (var j in i) yield return j; } } }</content></entry><entry><title>[.NET] WPF 数据绑定与 MVVM 模型</title><url>https://slimenull.top/post/csharp-wpfmvvm/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>WPF</tag><tag>MVVM</tag><tag>参考</tag></tags><content type="html"> 欸? 听说你还在使用 Dispatcher 来设置与获取数据? 落后啦! 快来试试 MVVM 吧!
数据绑定: 数据绑定需要有一个源, 这个源可以是一个控件, 也可以是一个对象.
最简单的数据绑定是对控件属性的绑定. 例如, 一个 Label 始终显示 Slider 的值: 绑定数据到某个控件, 此时, 数据绑定的源就是这个控件. Path是Value, 即, 我们要获取与设置这个控件的Value
DataContext: 如果要设置源为一个对象. 例如我们定义的 MyObj 的实例, 则需要指定 DataContext. 指定 DataContext 的控件以及它的子元素都将使用指定的对象作为数据绑定的源. 例如: MVVM: MVVM 的意思是: Model, View, ViewModel, 其中:
Model: 程序的核心代码, 例如数据库操作 View: 程序的展示层, 例如UI展示与UI事件. ViewModel: 视图数据层. 啊我知道你很迷惑&hellip; 毕竟当时我也是这样, 反正, 一个例子足够描述出来了.
例子: 新建一个 WPF 项目. 此次演示, 我们以 MvvmTest 作为项目名. 在项目中创建以下文件夹: Model, View, ViewModel. 将 MainWindow.xaml 移动到 View 中. 并调整 xaml 中的 Window 的 x:Class 属性值.</content></entry><entry><title>[C#] Range 函数, 方便快捷</title><url>https://slimenull.top/post/csharp-rangefunc/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>轮子</tag></tags><content type="html"> 包含了所有常用的数字循环
使用: 在 nuget 包管理器中安装 NullLib.Range
源码: 这么多重载, 完全够用了~, 返回值是 IEnumerable&lt;T> 其中, Range函数是简单的循环, RangeEx加入了检测, 不会造成死循环, 且精度非常准确
using System; using System.Collections.Generic; namespace NullLib.Range { public class NRange { public static IEnumerable&lt;int> Range(int stop) { for (int i = 0; i &lt; stop; i++) yield return i; } public static IEnumerable&lt;int> Range(int start, int stop) { for (int i = start; i &lt; stop; i++) yield return i; } public static IEnumerable&lt;int> Range(int start, int stop, int step) { for (int i = start; i &lt; stop; i += step) yield return i; } public static IEnumerable&lt;float> Range(float stop) { for (int i = 0; i &lt; stop; i++) yield return i; } public static IEnumerable&lt;float> Range(float start, float stop) { for (float i = start; i &lt; stop; i++) yield return i; } public static IEnumerable&lt;float> Range(float start, float stop, float step) { for (float i = start; i &lt; stop; i += step) yield return i; } public static IEnumerable&lt;double> Range(double stop) { for (int i = 0; i &lt; stop; i++) yield return i; } public static IEnumerable&lt;double> Range(double start, double stop) { for (double i = start; i &lt; stop; i++) yield return i; } public static IEnumerable&lt;double> Range(double start, double stop, double step) { for (double i = start; i &lt; stop; i += step) yield return i; } public static IEnumerable&lt;int> RangeEx(int stop) { int start = 0, step = 1, current = start; step = step &lt; 0 ? -step : step; if (start &lt; stop) for (int i = 0; current &lt; stop; i++, current = step * i + start) yield return current; else for (int i = 0; current > stop; i--, current = step * i + start) yield return current; } public static IEnumerable&lt;int> RangeEx(int start, int stop) { int step = 1, current = start; step = step &lt; 0 ? -step : step; if (start &lt; stop) for (int i = 0; current &lt; stop; i++, current = step * i + start) yield return current; else for (int i = 0; current > stop; i--, current = step * i + start) yield return current; } public static IEnumerable&lt;int> RangeEx(int start, int stop, int step) { int current = start; step = step &lt; 0 ? -step : step; if (start &lt; stop) for (int i = 0; current &lt; stop; i++, current = step * i + start) yield return current; else for (int i = 0; current > stop; i--, current = step * i + start) yield return current; } public static IEnumerable&lt;float> RangeEx(float stop) { float start = 0, step = 1, current = start; step = step &lt; 0 ? -step : step; if (start &lt; stop) for (int i = 0; current &lt; stop; i++, current = step * i + start) yield return current; else for (int i = 0; current > stop; i--, current = step * i + start) yield return current; } public static IEnumerable&lt;float> RangeEx(float start, float stop) { float step = 1, current = start; step = step &lt; 0 ? -step : step; if (start &lt; stop) for (int i = 0; current &lt; stop; i++, current = step * i + start) yield return current; else for (int i = 0; current > stop; i--, current = step * i + start) yield return current; } public static IEnumerable&lt;float> RangeEx(float start, float stop, float step) { float current = start; step = step &lt; 0 ? -step : step; if (start &lt; stop) for (int i = 0; current &lt; stop; i++, current = step * i + start) yield return current; else for (int i = 0; current > stop; i--, current = step * i + start) yield return current; } public static IEnumerable&lt;double> RangeEx(double stop) { double start = 0, step = 1, current = start; step = step &lt; 0 ? -step : step; if (start &lt; stop) for (int i = 0; current &lt; stop; i++, current = step * i + start) yield return current; else for (int i = 0; current > stop; i--, current = step * i + start) yield return current; } public static IEnumerable&lt;double> RangeEx(double start, double stop) { double step = 1, current = start; step = step &lt; 0 ? -step : step; if (start &lt; stop) for (int i = 0; current &lt; stop; i++, current = step * i + start) yield return current; else for (int i = 0; current > stop; i--, current = step * i + start) yield return current; } public static IEnumerable&lt;double> RangeEx(double start, double stop, double step) { double current = start; step = step &lt; 0 ? -step : step; if (start &lt; stop) for (int i = 0; current &lt; stop; i++, current = step * i + start) yield return current; else for (int i = 0; current > stop; i--, current = step * i + start) yield return current; } } }</content></entry><entry><title>[.NET] WPF DoubleAnimation 动画, 一篇文章悟透!</title><url>https://slimenull.top/post/dotnet-wpfdoubleanimation/</url><categories/><tags><tag>.NET</tag><tag>WPF</tag><tag>XAML</tag><tag>参考</tag></tags><content type="html"> WPF 的异步动画, 支持加速度与减速度的设置, 递增, 重复执行
完全理解 DoubleAnimation! 仅需这一篇文章.
介绍 首先, DoubleAnimation可以用来创建一些简单的动画, 这些动画仅限于使用Double值的属性, 例如控件的位置, 尺寸, 缩放, 旋转, 或者透明度变化等. 一个DoubleAnimation实例, 应该至少指定3个值:
From (值从哪里开始), To (值到哪里结束), Duration (值的变化经过多少时间)
例如, 如果要创建一个 1s 内从值从 0 到 1 的动画, From 就是0, To 就是 1, Duration就是 1s.
启动动画, 需要调用将要执行这个动画的对象的 BeginAnimation 方法, 例如一个控件, 或者一个窗口, 参数包括 DependencyProperty(这个动画将对哪个属性执行), AnimationTimeline(执行哪个动画)
实例: 例如, 创建一个, 当点击按钮时, 按钮的高度增加 30 个像素. CS代码: 然后, 看看效果吧:
其实, DoubleAnimation还可以指定运动时, 加速在整个时间线中的占比以及减速在整个时间线中的占比.
例如, 你想指定这个运动中, 前半部分是加速, 后半部分是匀速, 那么加速占比就是0.5, 减速占比就是0, 如下: 然后, 看看运行效果吧: 可以看出, 有加速的效果了, 或者, 再狠点, 我们指定全部是减速, 加速占比0, 减速占比1: 果然减速看起来非常好看啊.
纯XAML使用: DoubleAnimation是可以在纯 xaml 中声明并使用的. 有种东西叫做 Trigger, 在 xaml 中声明他, 然后可以合适的触发动画, 如下: 然后, 运行效果的话, 除了不能不断增加高度, 其他的是一样的, 点一次, 就会从20到50, 第二次点击, 还是从20到50.
贴代码: 按钮事件:
private void Button_Click(object sender, RoutedEventArgs e) { DoubleAnimation animation = new DoubleAnimation( button1.ActualHeight, // From 从按钮的 高度 开始 button1.ActualHeight + 30, // To 到按钮的 高度 + 30 结束 new Duration(TimeSpan.FromSeconds(1))) // Duration 间隔是 1s { AccelerationRatio = 0, // 设置加速占比为一半, 即 0.5 DecelerationRatio = 1, // 设置减速占比为0, 其实这里可以省略, 因为默认是0 }; button1.BeginAnimation( Button.HeightProperty, // DependencyProperty 动画是针对于高度的 animation); // AnimationTimeline 指定刚刚创建好的动画 } 纯xaml实现:
&lt;Button Name="button1" Content="Button" HorizontalAlignment="Left" Margin="343,182,0,0" VerticalAlignment="Top" Width="75" Height="20"> &lt;Button.Triggers> &lt;EventTrigger RoutedEvent="Button.Click"> &lt;BeginStoryboard> &lt;Storyboard> &lt;DoubleAnimation Storyboard.TargetProperty="Height" From="20" To="50" Duration="0:0:1" AccelerationRatio="0" DecelerationRatio="1"/> &lt;/Storyboard> &lt;/BeginStoryboard> &lt;/EventTrigger> &lt;/Button.Triggers> &lt;/Button> 小彩蛋~ 是窗口加载时的透明度变化动画欸嘿
&lt;Window.Triggers> &lt;EventTrigger RoutedEvent="Loaded"> &lt;BeginStoryboard > &lt;Storyboard> &lt;DoubleAnimation From="0" To="1" Duration="0:0:0.3" Storyboard.TargetProperty="Opacity"/> &lt;/Storyboard> &lt;/BeginStoryboard> &lt;/EventTrigger> &lt;/Window.Triggers> 参考文章: 以下文章对本文章的理解有帮助噢~ [.NET] WPF XAML 原理, 节点与实例, 以及一些重要的零碎知识点.
[.NET] WPF Triggers 触发器, EventTrigger, Trigger</content></entry><entry><title>[.NET] WPF Triggers 触发器, EventTrigger, Trigger</title><url>https://slimenull.top/post/dotnet-wpftrigger/</url><categories/><tags><tag>.NET</tag><tag>WPF</tag><tag>XAML</tag><tag>参考</tag></tags><content type="html"> 通过触发器来实现某种特定情况下才会对控件应用的样式, 例如鼠标悬停时改变颜色
触发器, 如其名, 可根据某些事件或属性值来触发某些东西, 那么我们来了解一下 xaml 中的触发器吧.
样式变更: 我们试试通过使用普通触发器来实现当鼠标悬停时更改控件背景颜色. 然后运行一下, 效果就是这样: 启动动画: 然后, 试着用事件触发器(EventTrigger)与DoubleAnimation来创建一个启动动画吧(其实代码都写好了): 然后运行效果如下: 可以看到, 窗口是渐渐浮现的, 也就是Opacity从0到1.
什么? 你问我对应的CS代码怎么写? 先看看这篇文章吧, 看完它, 相信大多数的 xaml 代码, 你都能写出对应的 CS 代码, 这是一个通用的规律. [.NET] WPF XAML 原理, 节点与实例, 以及一些重要的零碎知识点.
推荐文章: [.NET] WPF DoubleAnimation 动画, 一篇文章悟透!</content></entry><entry><title>[.NET] WPF XAML 原理, 节点与实例, 以及一些重要的零碎知识点</title><url>https://slimenull.top/post/dotnet-wpfxamlandother/</url><categories/><tags><tag>.NET</tag><tag>WPF</tag><tag>XAML</tag><tag>参考</tag></tags><content type="html"> xaml 与 CS 是相关联的, xaml 也完全可以转换为对应的 CS 代码
当你查资料时, 看到那些眼花缭乱的 xaml 代码, 让人瞬间没有了学习的欲望&hellip; 先试着寻找下其中的规律吧.
节点与实例: 首先看看上面的文章, 从我们最常接触的 Button 入手吧. Button 是可以用 CS 代码来进行实例化, 然后放置在窗口中的, 而其它的元素, 例如根节点 Window, 都是可以通过 CS 代码进行实例化.
可以推测出, 在 xaml 中, 一个个的节点, 例如 Button, Label, 其实就是等同于声明一个对应类型的实例.
那么如何在 CS 代码中访问这个实例呢? 很简单, 为这个实例指定一个名称(Name), 就如上面的图片中为 Label 指定 Name 那样. 然后就可以在 CS 代码中访问了 实例的属性: 如果要设置一个 Label 的 Content, 在 xaml 代码中, 该如何设置? 最常用的肯定是下面这个: xaml 还支持一种, 就是这样: 其实 TextBox 的 Text 属性也是可以这么设置的: 大概猜出了吧? xaml中, 一堆标签之间的值可以设置为对应实例的特定属性设置值. 例如 Label 就是设置Content, TextBox 就是 设置 TextBox.
其实, 还有另外一种, 你肯定见过啦, Grid.RowDefinitions 就是这么用的. 你可能会想到, Label 和 TextBox 这类普通的控件, 是否也支持呢? 哈哈, 很有趣吧, 所以说, 以后看到什么 xaml 代码, 对应的 CS 代码也能猜出来一些, 毕竟如果是控件, 也无非是设置属性以及添加成员了, 噢, 下面就是添加成员咯.
声明控件成员: 如果一个控件可以有子成员, 就可以像上面那样声明, 当然, 这个也肯定经常用, 只是可能没注意过罢了.
自定义类型实例: 少年, 学过数据绑定吗? 数据绑定的上下文如何声明的, 应该还记得吧. 我之前就像一个憨憨一样, 去用 CS 代码来指定 DataContext. (文章末有关于数据绑定的文章推荐
) 但是,,, 刚刚我们说过, 想 Button, Label 这样的 UI 组件, 其实在声明后, 其实就是一个个的实例, 我们刚刚进行的指定上下文操作, 也是创建一个 TestModel 实例, 然后指定给这个窗口的 DataContext 属性.
如何指定属性, 我们知道, 那如何在 xaml 中创建我们自己定义的类型实例呢? 下面是一个示例: 你悟了吗? 通过这个, 我们就可以在 xaml 中声明实例了&hellip; 当然, 肯定有小聪明在想, &ldquo;我试试在 xaml 里面声明一个浮点数试试?&rdquo; 没错, 那个憨憨就是我, 亲自尝试了一下, 不过也不算是没有收获, 至少我们可以知道, 这些实例的声明, 肯定是在特定的情况下才是可以的. 例如这个 Grid 子元素, 你必须指定一个 UIElement, 这跟 CS 代码里的一模一样hhh
所以 xaml 跟 CS 还是相关联的哈哈哈, 我一开始还觉得 xaml 跟 CS 的关联不是很大呢.
查看窗体完整代码: 如果你用过 WinForm, 肯定会经常接触这个, 当指定了控件的某些事件, 而这个函数又不存在的时候肯定需要自己调整代码的: WinForm 的窗体完整代码就在这里了, 一到WPF, 就令人窒息了, 因为没有直接显示这个文件.
不过, 你还是可以通过这样的方式去查看的: 然后, 欢呼吧, 虽然一般很少动这个文件(你也没办法动, 自动生成会覆盖你的改动), 但是看这个东西, 肯定对学习 WPF 有帮助的.
窗体类型: 其实这里只是指 xaml 中, Window 节点的 x:Class 属性, 我们知道, WPF 会有一些自动生成的代码, 这些代码中声明了这个窗体, 而这个生成的代码中窗体的命名空间和类名, 就是通过 xaml 文档中的 x:Class 属性指定的.
例如我指定 x:Class=&ldquo;MvvmTest.View.MainWindow&rdquo;, 那么完整代码中就是这样的: 所以说, 如果要改变这个窗体的命名空间, 你需要指定 x:Class 属性, 以及指定 xaml.cs 文件的命名空间.
例如, 你将一个窗体从项目的根目录移动到了项目的View文件夹, 此时, 规范的做法应该是同时将这个窗体的命名空间添加上一个View.
看的这么开心, 赶快关注诺尔吧qwq, 别忘了点个赞噢~
推荐文章: [C#] MCI 详解与封装类, MCI 播放音乐, 获取播放状态, 获取音频长度, 进度调整
[.NET] WPF 数据绑定与 MVVM 模型</content></entry><entry><title>[C#/VB.NET] C# 与 VB.NET 的类库跨语言引用</title><url>https://slimenull.top/post/dotnet-crosslangdllref/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>VB.NET</tag><tag>经验</tag></tags><content type="html"> C# 与 VB.NET 同样基于 .NET, 编译后的 MSIL 当然都是由 .NET Runtime 来执行, 所以互相调用完全合理
例如你有一个程序, 是 VB.NET 写的, 你希望在里面引用 C# 的代码, 那么, 该如何操作呢?
准备材料: 一个 C# 或 VB.NET 项目, 我们以一个测试项目(WinForm)开始 与该项目语言不同的, 但是是基于 .NET 的类代码片. 代码地址: 一个类实现控件拖拽移动
分布演示: 1. > 创建类库项目: 创建一个与我们准备的类库语言相同的类库, 并将代码拷贝到其中: 2. > 添加项目引用: 在刚刚准备好的 WinForm 项目中, 添加对类库项目的引用. 3. > 开始使用: 现在, 你就可以直接使用类库中的类了. > 使用效果:</content></entry><entry><title>[Linux] Linux 指令与全称</title><url>https://slimenull.top/post/linux-cmdfullname/</url><categories/><tags><tag>Linux</tag></tags><content type="html"> Linux 部分指令的全称与描述
指令 全称 *描述 su switch user 切换用户 cat concatenate uname unix name unix 名称 df disk free 磁盘空余 du disk usage 磁盘使用 chown change owner 改变所有者 chmod change mode 改变模式 chgrp change group 改变群组 ps process status 进程状态 tar tape archive umount unmount 卸载 ldd list dynamic dependencies 列举动态依赖 insmod install module 安装模块 rmmod remove module 移除模块 lsmod list module 列举模块 alias alias 别名 bash Bourne-Again shell grep global regular expression print 全局正规表达式打印 sudo super user do 超级用户执行</content></entry><entry><title>[C#] 音乐播放 3 种方式 Demo 与 MCI 音乐播放器封装类</title><url>https://slimenull.top/post/csharp-playmusic/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>音频</tag></tags><content type="html"> SoundPlayer, MciCommandString, NAudio 三种方式播放音频示例
淦! 首先代码是不完整的, 我还是没能成功设置音量, 除此之外, 别的倒是挺顺利的, 当前实现的功能如下:
播放 暂停 还原 停止 获取进度 获取长度 设置进度 获取播放状态
内容: 本项目的仓库在: SlimeNull/AudioTest, 在这里下载哦. > 音乐播放 Demo: 先放图吧: 首先左上角是打开文件的, 然后 PlayType 是播放方式, 我现在让它支持 3 种, 一种是SoundPlayer, 然后是 MCI, 然后是 NAudio 库. 实现了播放, 暂停, 停止, 移除, 进度调整到开头, 进度调整(就那个track bar), 同步播放(如果点了这个, UI线程会阻塞的哦), 获取音乐长度, 获取播放状态, 获取播放位置, 重复播放. 不同的功能对不同的播放种类支持性不同, 所以, 如果你按下了按钮, 没反应, 也没报错, 那就是它不支持这个功能(也就是代码里没有写)'
下载代码, 请看前面的链接.↑跳转↑
> MCI 播放器封装: 上边的窗体程序就体现了封装类所实现的所有功能喔, 所以试试吧, 你也可以直接粘贴下面的代码, 但是cs文件的名称, 如果可以的话, 我希望你命名为 &ldquo;Null.MciPlayer&rdquo; (没错就是我的名字 using System; using System.IO; using System.Runtime.InteropServices; namespace Null.MciPlayer { public class MciPlayer : IDisposable { [DllImport("kernel32.dll", EntryPoint = "GetShortPathNameW", CharSet = CharSet.Unicode)] extern static short GetShortPath(string longPath, string buffer, int bufferSize); [DllImport("winmm.dll", EntryPoint = "mciSendString", CharSet = CharSet.Unicode)] extern static int MciSendString(string command, string buffer, int bufferSize, IntPtr callback); bool TryGetShortPath(string longPath, out string shortPath) { shortPath = null; short reqLen = GetShortPath(longPath, null, 0); // 指定 null与0, 则返回需要的长度 if (reqLen == 0) return false; shortPath = new string('\0', reqLen); // 声明缓冲 short rstLen = GetShortPath(longPath, shortPath, reqLen); // 转换 if (rstLen == 0 || rstLen == reqLen) return false; shortPath = shortPath.TrimEnd('\0'); return true; } private string longpath; private string shortName; private string aliasName; public MciPlayer() { } public MciPlayer(string path) { if (!File.Exists(path)) throw new FileNotFoundException("File not exist.", path); longpath = path; } void MciSendStringWithCheck(string command, string buffer, int bufferSize, IntPtr callback) { int err = MciSendString(command, buffer, bufferSize, callback); if (err != 0) throw new MciException(err); } string StatusInfo(string info) { string buffer = new string('\0', 32); MciSendStringWithCheck($"status {aliasName} {info}", buffer, 32, IntPtr.Zero); return buffer.TrimEnd('\0'); } public string DevicePath { get => longpath; } public string DeviceShortPath { get => shortName; } public string AliasName { get => aliasName; } public bool SetDevicePath(string longpath) { if (aliasName != null) return false; this.longpath = longpath; return true; } public void Open() { if (!TryGetShortPath(longpath, out shortName)) throw new Exception("Get short path faield when initializing."); aliasName = $"nmci{DateTime.Now.Ticks}"; MciSendStringWithCheck($"open {shortName} alias {aliasName}", null, 0, IntPtr.Zero); } public void Close() { MciSendStringWithCheck($"close {aliasName}", null, 0, IntPtr.Zero); aliasName = null; } public void Play() { MciSendStringWithCheck($"play {aliasName}", null, 0, IntPtr.Zero); } public void Resume() { MciSendStringWithCheck($"resume {aliasName}", null, 0, IntPtr.Zero); } public void Pause() { MciSendStringWithCheck($"pause {aliasName}", null, 0, IntPtr.Zero); } public void Stop() { MciSendStringWithCheck($"stop {aliasName}", null, 0, IntPtr.Zero); } public int GetPosition() { return int.Parse(StatusInfo("position")); } public int GetLength() { return int.Parse(StatusInfo("length")); } public PlaybackState GetState() { switch (StatusInfo("mode").ToLower()) { case "playing": return PlaybackState.Playing; case "paused": return PlaybackState.Paused; case "stopped": return PlaybackState.Stopped; default: return PlaybackState.Invalid; } } public void PlayWait() { MciSendStringWithCheck($"play {aliasName} wait", null, 0, IntPtr.Zero); } public void PlayRepeat() { MciSendStringWithCheck($"play {aliasName} repeat", null, 0, IntPtr.Zero); } public void Seek(int position) { MciSendStringWithCheck($"seek {aliasName} to {position}", null, 0, IntPtr.Zero); } public void SeekToStart() { MciSendStringWithCheck($"seek {aliasName} to start", null, 0, IntPtr.Zero); } public void SetSeekMode(bool fExact) { MciSendStringWithCheck($"set {aliasName} seek exactly {(fExact ? "on" : "off")}", null, 0, IntPtr.Zero); } public void Dispose() { if (aliasName != null) Close(); } } public enum PlaybackState { Stopped, Playing, Paused, Invalid = -1, } public class MciException : Exception { private MciError err; public int ErrorId { get => (int)err; } public string ErrorName { get => err.ToString(); } public override string Message { get => ErrorName; } public MciException() { } public MciException(int errorId) { if (Enum.IsDefined(typeof(MciError), errorId)) err = (MciError)errorId; else throw new ArgumentOutOfRangeException("不是正确的错误ID"); } public MciException(string errorName) { if (!Enum.TryParse&lt;MciError>(errorName, out err)) throw new ArgumentOutOfRangeException("不是正确的错误ID"); } enum MciError { MCIERR_NO_ERROR = 0, MCIERR_INVALID_DEVICE_ID = 257, MCIERR_UNRECOGNIZED_KEYWORD = 259, MCIERR_UNRECOGNIZED_COMMAND = 261, MCIERR_HARDWARE = 262, MCIERR_INVALID_DEVICE_NAME = 263, MCIERR_OUT_OF_MEMORY = 264, MCIERR_DEVICE_OPEN = 265, MCIERR_CANNOT_LOAD_DRIVER = 266, MCIERR_MISSING_COMMAND_STRING = 267, MCIERR_PARAM_OVERFLOW = 268, MCIERR_MISSING_STRING_ARGUMENT = 269, MCIERR_BAD_INTEGER = 270, MCIERR_PARSER_INTERNAL = 271, MCIERR_DRIVER_INTERNAL = 272, MCIERR_MISSING_PARAMETER = 273, MCIERR_UNSUPPORTED_FUNCTION = 274, MCIERR_FILE_NOT_FOUND = 275, MCIERR_DEVICE_NOT_READY = 276, MCIERR_INTERNAL = 277, MCIERR_DRIVER = 278, MCIERR_CANNOT_USE_ALL = 279, MCIERR_MULTIPLE = 280, MCIERR_EXTENSION_NOT_FOUND = 281, MCIERR_OUTOFRANGE = 282, MCIERR_FLAGS_NOT_COMPATIBLE = 284, MCIERR_FILE_NOT_SAVED = 286, MCIERR_DEVICE_TYPE_REQUIRED = 287, MCIERR_DEVICE_LOCKED = 288, MCIERR_DUPLICATE_ALIAS = 289, MCIERR_BAD_CONSTANT = 290, MCIERR_MUST_USE_SHAREABLE = 291, MCIERR_MISSING_DEVICE_NAME = 292, MCIERR_BAD_TIME_FORMAT = 293, MCIERR_NO_CLOSING_QUOTE = 294, MCIERR_DUPLICATE_FLAGS = 295, MCIERR_INVALID_FILE = 296, MCIERR_NULL_PARAMETER_BLOCK = 297, MCIERR_UNNAMED_RESOURCE = 298, MCIERR_NEW_REQUIRES_ALIAS = 299, MCIERR_NOTIFY_ON_AUTO_OPEN = 300, MCIERR_NO_ELEMENT_ALLOWED = 301, MCIERR_NONAPPLICABLE_FUNCTION = 302, MCIERR_ILLEGAL_FOR_AUTO_OPEN = 303, MCIERR_FILENAME_REQUIRED = 304, MCIERR_EXTRA_CHARACTERS = 305, MCIERR_DEVICE_NOT_INSTALLED = 306, MCIERR_GET_CD = 307, MCIERR_SET_CD = 308, MCIERR_SET_DRIVE = 309, MCIERR_DEVICE_LENGTH = 310, MCIERR_DEVICE_ORD_LENGTH = 311, MCIERR_NO_INTEGER = 312, MCIERR_WAVE_OUTPUTSINUSE = 320, MCIERR_WAVE_SETOUTPUTINUSE = 321, MCIERR_WAVE_INPUTSINUSE = 322, MCIERR_WAVE_SETINPUTINUSE = 323, MCIERR_WAVE_OUTPUTUNSPECIFIED = 324, MCIERR_WAVE_INPUTUNSPECIFIED = 325, MCIERR_WAVE_OUTPUTSUNSUITABLE = 326, MCIERR_WAVE_SETOUTPUTUNSUITABLE = 327, MCIERR_WAVE_INPUTSUNSUITABLE = 328, MCIERR_WAVE_SETINPUTUNSUITABLE = 329, MCIERR_SEQ_DIV_INCOMPATIBLE = 336, MCIERR_SEQ_PORT_INUSE = 337, MCIERR_SEQ_PORT_NONEXISTENT = 338, MCIERR_SEQ_PORT_MAPNODEVICE = 339, MCIERR_SEQ_PORT_MISCERROR = 340, MCIERR_SEQ_TIMER = 341, MCIERR_SEQ_PORTUNSPECIFIED = 342, MCIERR_SEQ_NOMIDIPRESENT = 343, MCIERR_NO_WINDOW = 346, MCIERR_CREATEWINDOW = 347, MCIERR_FILE_READ = 348, MCIERR_FILE_WRITE = 349, MCIERR_NO_IDENTITY = 350, } } } 如果有什么建议或者这个类有可改进的地方, 欢迎留言哦~ n(*≧▽≦*)n</content></entry><entry><title>[Win32] MCI 详解与封装类, MCI 播放音乐, 获取播放状态, 获取音频长度, 进度调整</title><url>https://slimenull.top/post/win32-mci/</url><categories/><tags><tag>Win32</tag><tag>.NET</tag><tag>C#</tag><tag>参考</tag><tag>经验</tag></tags><content type="html"> MCI 打开文件, 播放, 暂停, 停止音频, 设定播放进度, 获取播放进度
淦! 琢磨了一晚上啊, 总算有些眉目了.
首先, MCI的全称是Multimedia Control Interface, 即多媒体控制接口, 通过它, 我们可以做到播放音频视频, 甚至录制音频, 虽然古老, 但是真的强大.
注意, 文章较官方文档有不少删减, 如果看标准内容, 还是看官方文档比较好.
MCI Command Strings 官方文档: Microsoft Command Strings - Win32 app | Microsoft Docs
哦对了, 文档是纯英文哦~
理论基础: MCI 不能与 C# 中的内存流打交道, 他只能播放文件. MCI 支持很多格式, 包含: CD音频, 数字音频, MIDI音乐, 视频唱片(videodisc), VCR, 以及波形音频. MCI 中, 被播放的音频文件被称作 设备(Device) MCI 中, 支持巨多设置项, 包括播放进度, 音量大小, 声道开关, 如果你播放的是 MIDI, 支持的设置更多. 正式开始: 下面, 我们将以播放音频为例, 尽可能多的讲述 MCI 的相关知识, 文章在今后可能会继续更新.
示例文件在: C:\Users\Null\Desktop\Tutorial.wav
> 引用库: 最最开始, 无非是载入库. 对于 C++, 需要引用 Windows.h 以及 Mmsystem.h 这两个头文件 对于 C#, using System.Runtime.InteropServices; 以进行非托管库的调用. > 执行指令: MCI 中, 有 3 种方式来执行 MCI 指令. 分别是: mciSendString, mciExecute, mciSendCommand, 它们均位于 winmm.dll 中. 函数原型:
MCIERROR mciSendString( // MCIERROR 是 无符号长整形数字 LPCTSTR lpszCommand, LPTSTR lpszReturnString, UINT cchReturn, HANDLE hwndCallback ); BOOL mciExecute( LPCSTR pszCommand ); MCIERROR mciSendCommand( MCIDEVICEID IDDevice, // 设备 ID, 通过另一个函数打开文件可以获得 UINT uMsg, DWORD_PTR fdwCommand, DWORD_PTR dwParam ); C# 声明方式:
[DllImport("winmm.dll", EntryPoint = "mciSendString", CharSet = CharSet.Unicode)] extern static ulong MciSendString(string command, string buffer, int bufferSize, IntPtr callback); [DllImport("winmm.dll", EntryPoint = "mciExecute", CharSet = CharSet.Unicode)] extern static bool MciExecute(string command); [DllImport("winmm.dll", EntryPoint = "mciSendCommand", CharSet = CharSet.Unicode)] extern static ulong MciSendCommand(uint deviceId, uint uMsg, IntPtr fdwCommand, IntPtr dwParam); 简略说明:
mciSendString: 最常用的方法, 通过字符串来表示一个指令, 会返回错误码, 不会有弹窗警告 mciExecute: 调试时较常用的方法, 在执行时若有未完善的地方, 会弹窗警告, 也因为如此, 程序的发布版本不会使用这个(影响使用体验) mciSendCommand: 很少用, 通过指令的ID来表示指令, 会返回错误码, 不会有弹窗警告 某些 MCI 指令具有返回值, 例如获取播放状态, 这些指令不能通过mciExecute执行.
文章只会通过 mciSendString 来介绍 MCI 哟 > 打开文件: 对于播放音频, 首要的第一件事, 肯定就是打开文件并将其载入到内存了. 不过有一点很重要, 就是 MCI 指令只支持短路径(ShortPath), 所以在拿到文件路径后, 我们得将其转换为短路径. 如果不对路径进行转换, 那么某些名字长度大于8的文件(准确来说是路径中任何一部分长度大于8)的将无法播放 关于短路径与长路径: windows系统下的文件长名和文件短名
短路径与长路径的转换: [C#/C/C++] GetShortPathName 详解, 长路径转换为短路径
MCI 指令中, 通过 open 来打开一个文件, 并且在末尾还可以使用 &ldquo;alias 别名&rdquo; 来为这个已打开的文件起一个别名. 下面是两个示例: // 文件是 C:\Users\Null\Desktop\Tutorial.wav // 转换为短路径是 C:\Users\Null\Desktop\Tut~1.wav mciSendString(@"open C:\Users\Null\Desktop\Tut~1.wav", null, 0, IntPtr.Zero); mciSendString(@"open C:\Users\Null\Desktop\Tut~1.wav alias tutorial", null, 0, IntPtr.Zero); 在第一的 mciSendString 中, 很清晰明了, 打开了一个文件, 而第二个中, 我们还加了一个alias, 即, 别名, MCI支持为打开的文件起一个别名, 并且推荐这么做. 第二个种, 我们为它起的别名是 tutorial. > 播放音频: 播放音频的 MCI 指令是 play, 直接 &ldquo;play 设备&rdquo; 示例: mciSendString(@"play C:\Users\Null\Desktop\Tut~1.wav", null, 0, IntPtr.Zero); mciSendString(@"play tutorial", null, 0, IntPtr.Zero); 如果你没有为文件指定别名, 那么在使用 play 指令时, 只能指定短路径 如果你为文件指定了别名, 直接play加上别名即可播放这个文件. > 重复播放音频: 这里, 用到了参数, 就像alias一样, 可选. 重复播放还是使用的play指令. 示例: mciSendString(@"play C:\Users\Null\Desktop\Tut~1.wav repeat", null, 0, IntPtr.Zero); mciSendString(@"play tutorial repeat", null, 0, IntPtr.Zero); 设备名如旧, 可以直接指定短路径, 也可以指定别名, 而想做到重复播放, 只需要在最后指定repeat > 同步播放音频: 同样是参数, 这里是wait, 支持wait参数的指令可以同步执行, 例如play指令 示例: mciSendString(@"play C:\Users\Null\Desktop\Tut~1.wav wait", null, 0, IntPtr.Zero); mciSendString(@"play tutorial wait", null, 0, IntPtr.Zero); 执行后, 将会阻塞当前现成, 直至播放结束. > 暂停播放: 暂停, pause, 用法很简单, 同样是 &ldquo;pause 设备&rdquo; 示例: mciSendString(@"pause C:\Users\Null\Desktop\Tut~1.wav", null, 0, IntPtr.Zero); mciSendString(@"pause tutorial", null, 0, IntPtr.Zero); 执行后, 正在播放的音频就会暂停. > 恢复播放: 恢复, resume, 语法是 &ldquo;resume 设备&rdquo; 示例: mciSendString(@"pause C:\Users\Null\Desktop\Tut~1.wav", null, 0, IntPtr.Zero); mciSendString(@"pause tutorial", null, 0, IntPtr.Zero); 执行后, 暂停播放的音频就会恢复. > 关闭文件: 关闭, close, 语法是: &ldquo;close 设备&rdquo; 示例: mciSendString(@"close C:\Users\Null\Desktop\Tut~1.wav", null, 0, IntPtr.Zero); mciSendString(@"close tutorial", null, 0, IntPtr.Zero); 执行后, 文件会被关闭. 如果音频正在播放, 则会停止. > 改变播放位置: seek 指令, 这个指令比较复杂哦. 语法如下: seek device to position seek device to start seek device to end
示例: mciSendString(@"seek tutorial to 1000", null, 0, IntPtr.Zero); mciSendString(@"seek tutorial to start", null, 0, IntPtr.Zero); mciSendString(@"seek tutorial to end", null, 0, IntPtr.Zero); 短路径肯定是能用的哦, 我只是懒得写了, 至于 &ldquo;seek device to position&rdquo; 的用法, 其中position默认是ms为单位的整数时间哦, 也就是说, 1000代表1s. seek 的单位是可以调整的, 继续看哦 > 设置相关: 设置, set, 这个支持的就更多了
以下是适用于 CD Audio 的语法 : set device time format milliseconds set device time format msf set device time format tmsf
以下是适用于 Wave Audio 的语法 : set device any input set device any output set device channels channel_count set device format tag pcm set device format tag tag set device input integer set device output integer set device time format bytes set device time format milliseconds
选项 描述 time format milliseconds 将时间格式设置为毫秒, 所有使用position值的指令都将采用毫秒作为单位, 你可以将milliseconds缩写为ms. 对于音序器设备, time format msf 设置时间格式到 分钟, 妙, 以及帧. 所有使用position值的指令都见采用MSF格式(CD音频的默认格式), 请将MSF值指定为 mm:ss:ff 的格式, mm是分钟, ss是秒, ff是帧. 如果一个字段以及后面的字段都是0, 你可以忽略掉它. 例如, 3, 3:0, 3:0:0 都是表示3分钟的正确方式. MSF字段有以下最大值, 分钟:99, 秒:59, 帧: 74. time format tmsf 将时间格式设置为 音轨, 分钟, 秒, 以及帧. 所有使用position值的指令都见采用TMSF格式, 额, 与上面的一样, 只不过多了个音轨. 音轨的最大值是99, 分钟, 秒, 帧的最大值与MSF格式一致. any input 当录制时, 使用所有支持当前格式的输入, 这是默认设置 any output 当播放时, 使用所有支持当前格式的输出, 这是默认的 time format bytes 在 PCM 文件格式中, 设置时间格式(单位)为字节, 指定这个指令后, 所有position信息都将被指定为字节格式 > 状态信息: 状态, status, 语法: &ldquo;status device option&rdquo;, 返回到 mciSendString 参数指定的字符串缓冲区
适用于音频的常用语法
status device position
status device length
status device mode
status device time format
选项 描述 position 获取目前播放的位置单位与时间格式统一 length 获取当前播放音频的长度 单位与时间格式统一 mode 获取播放状态, 返回的值是以下值之一: stopped / playing / paused time format 获取当前的时间格式 string buffer = new string('\0', 256); // 分配一个长度的字符串用来存放返回值 mciSendString("status tutorial position", buffer, 256, IntPtr.Zero); // 调用 Console.WriteLine(buffer.TrimEnd('\0')); // 打印返回值, TrimEnd的原因字符串的是长度是256, 函数没有使用的部分仍然是 \0 字符. > 音频设置 设置音频, setaudio, 语法 &ldquo;setaudio device option&rdquo;
常用语法:
setaudio device left volume to factor
setaudio device right volume to factor
setaudio device volume to factor
选项 描述 left/right volume to factor 将指定声道的音量设置为指定值 volume to factor 将音量设置为指定值 错误码: 下面是sendMciString会返回的错误码以及描述(对名称翻译, 然后稍加校正), 哦对了, 返回 0 代表无错误哦 错误码 名称 描述 257 MCIERR_INVALID_DEVICE_ID 无效设备 ID 259 MCIERR_UNRECOGNIZED_KEYWORD 未识别关键字 261 MCIERR_UNRECOGNIZED_COMMAND 未识别的命令 262 MCIERR_HARDWARE 硬件 263 MCIERR_INVALID_DEVICE_NAME 无效的设备名称 264 MCIERR_OUT_OF_MEMORY 内存不足 265 MCIERR_DEVICE_OPEN 设备打开 266 MCIERR_CANNOT_LOAD_DRIVER 无法加载驱动程序 267 MCIERR_MISSING_COMMAND_STRING 缺少命令字符串 268 MCIERR_PARAM_OVERFLOW 参数溢出 269 MCIERR_MISSING_STRING_ARGUMENT 缺少字符串参数 270 MCIERR_BAD_INTEGER 坏整数 271 MCIERR_PARSER_INTERNAL 分析器内部 (估计是这个API内部对指令分析时出现的错误) 272 MCIERR_DRIVER_INTERNAL 驱动程序内部 273 MCIERR_MISSING_PARAMETER 缺少参数 274 MCIERR_UNSUPPORTED_FUNCTION 不支持的功能 275 MCIERR_FILE_NOT_FOUND 未找到文件 276 MCIERR_DEVICE_NOT_READY 设备未就绪 277 MCIERR_INTERNAL 内部 278 MCIERR_DRIVER 驱动器 279 MCIERR_CANNOT_USE_ALL 不能全部使用 280 MCIERR_MULTIPLE 多个 281 MCIERR_EXTENSION_NOT_FOUND 未找到扩展 282 MCIERR_OUTOFRANGE 超出范围 284 MCIERR_FLAGS_NOT_COMPATIBLE 标志不兼容 286 MCIERR_FILE_NOT_SAVED 文件未保存 287 MCIERR_DEVICE_TYPE_REQUIRED 需要设备类型 288 MCIERR_DEVICE_LOCKED 设备已锁定 289 MCIERR_DUPLICATE_ALIAS 重复别名 290 MCIERR_BAD_CONSTANT 坏常量 291 MCIERR_MUST_USE_SHAREABLE 必须使用可共享 292 MCIERR_MISSING_DEVICE_NAME 缺少设备名称 293 MCIERR_BAD_TIME_FORMAT 错误的时间格式 294 MCIERR_NO_CLOSING_QUOTE 没有关闭中的引用 295 MCIERR_DUPLICATE_FLAGS 重复标志 296 MCIERR_INVALID_FILE 无效文件 297 MCIERR_NULL_PARAMETER_BLOCK 空参数块 298 MCIERR_UNNAMED_RESOURCE 未命名的资源 299 MCIERR_NEW_REQUIRES_ALIAS 新需要别名 300 MCIERR_NOTIFY_ON_AUTO_OPEN 自动打开时通知 301 MCIERR_NO_ELEMENT_ALLOWED 不允许任何元素 302 MCIERR_NONAPPLICABLE_FUNCTION 不可应用功能 303 MCIERR_ILLEGAL_FOR_AUTO_OPEN 非法自动打开 304 MCIERR_FILENAME_REQUIRED 需要文件名 305 MCIERR_EXTRA_CHARACTERS 额外字符 (可能是指多出了一些不需要的字符) 306 MCIERR_DEVICE_NOT_INSTALLED 未安装设备 307 MCIERR_GET_CD 获取 CD 308 MCIERR_SET_CD 设置 CD 309 MCIERR_SET_DRIVE 设置驱动器 310 MCIERR_DEVICE_LENGTH 设备长度 311 MCIERR_DEVICE_ORD_LENGTH 设备 ORD 长度 312 MCIERR_NO_INTEGER 无整数 320 MCIERR_WAVE_OUTPUTSINUSE 波输出 321 MCIERR_WAVE_SETOUTPUTINUSE 波设置输出 322 MCIERR_WAVE_INPUTSINUSE 波输入使用 323 MCIERR_WAVE_SETINPUTINUSE 波设置 324 MCIERR_WAVE_OUTPUTUNSPECIFIED 波输出未指定 325 MCIERR_WAVE_INPUTUNSPECIFIED 波输入未指定 326 MCIERR_WAVE_OUTPUTSUNSUITABLE 波输出可居住 327 MCIERR_WAVE_SETOUTPUTUNSUITABLE 波设置通普通西装 328 MCIERR_WAVE_INPUTSUNSUITABLE 波输入可居住 329 MCIERR_WAVE_SETINPUTUNSUITABLE 波设置通图适合 336 MCIERR_SEQ_DIV_INCOMPATIBLE Seq Div 不兼容 337 MCIERR_SEQ_PORT_INUSE SEQ 端口 INUSE 338 MCIERR_SEQ_PORT_NONEXISTENT Seq 端口不存在 339 MCIERR_SEQ_PORT_MAPNODEVICE Seq 端口地图无设备 340 MCIERR_SEQ_PORT_MISCERROR SEQ 杂项错误 341 MCIERR_SEQ_TIMER SEQ 定时器 342 MCIERR_SEQ_PORTUNSPECIFIED SEQ 端口未指定 343 MCIERR_SEQ_NOMIDIPRESENT SEQ 没有MIDI在场 346 MCIERR_NO_WINDOW 无窗口 347 MCIERR_CREATEWINDOW 创建窗口 348 MCIERR_FILE_READ 文件读取 349 MCIERR_FILE_WRITE 文件写入 350 MCIERR_NO_IDENTITY 无标识 附加内容: 下面是我的一些发现
WinForm 程序使用 MCI 是可以打开 MP3 文件的, 但是如果是控制台程序, 就会出现错误, 错误码266, &ldquo;MCIERR_CANNOT_LOAD_DRIVER&rdquo; MCI 的某些指令不能正常使用, 但其实并不是很影响, 例如, &ldquo;set device audio left/right off/off&rdquo;, 无法正常使用. 音量控制我目前还是没弄成&hellip; 不过可以确认的是, 进度获取, 调整, 长度获取是没问题的, 有这些最基本的, 就差不多公用了呢</content></entry><entry><title>[Win32] GetShortPathName详解, 长路径转换为短路径</title><url>https://slimenull.top/post/win32-getshortpathname/</url><categories/><tags><tag>Win32</tag><tag>.NET</tag><tag>C#</tag><tag>参考</tag><tag>经验</tag></tags><content type="html"> 借助 WinApi 即可实现长路径转换为短路径
说点骚话: 转换需要用到 Windows API (废话)
官方文档: GetShortPathNameW function (fineapi.h) - Win32 apps | Microsoft docs
(纯英文, 没有中文版本.)
引用命名空间: using System.Runtime.InteropServices; 关键代码: C# [DllImport("kernel32.dll", EntryPoint = "GetShortPathNameW", CharSet = CharSet.Unicode)] extern static short GetShortPath(string longPath, string buffer, int bufferSize); // 获取转换所需要的缓冲区大小 bool TryGetConvertBufferSize(string longPath, out short size) { size = GetShortPath(longPath, null, 0); return size != 0; } // 进行转换 bool TryGetShortPath(string longPath, out string shortPath, int bufferSize = 256) { string resultBuffer = new string('\0', bufferSize); // 256 大概合适, 根据需求调整吧 short rstLen = GetShortPath(longPath, resultBuffer, bufferSize); if (rstLen != 0 &amp;&amp; rstLen != bufferSize) { shortPath = resultBuffer.TrimEnd('\0'); return true; } else { shortPath = null; return false; } } C++ long length = 0; TCHAR* buffer = NULL; // 初次通过传递NULL和0来获取所需空间 length = GetShortPathName(lpszPath, NULL, 0); if (length == 0) ErrorExit(TEXT("GetShortPathName")); // 动态分配准确的内存 buffer = new TCHAR[length]; // 现在, 使用同一个长路径来简单调用函数吧 length = GetShortPathName(lpszPath, buffer, length); if (length == 0) ErrorExit(TEXT("GetShortPathName")); _tprintf(TEXT("long name = %s shortname = %s"), lpszPath, buffer); delete [] buffer; 更多说明: 内容 1: 如果设置了 buffer, 与 bufferSize, 函数会尝试转换长路径到短路径, 如果返回的数字与 bufferSize 一致, 则表示缓冲区(buffer)太小.
如果 buffer 被设为 null, bufferSize 被设为 0, 则返回值将返回所需要的缓冲区大小.
无论如何, 如果返回值是 0, 则表示函数由于某些原因, 未能成功执行.
获取更多的错误信息, 请调用 CallLastError
原文:
If the function succeeds, the return value is the length, in TCHARs, of the string that is copied to lpszShortPath, not including the terminating null character. If the lpszShortPath buffer is too small to contain the path, the return value is the size of the buffer, in TCHARs, that is required to hold the path and the terminating null character. If the function fails for any other reason, the return value is zero. To get extended error information, call GetLastError
.
内容 2: 在这个函数(GetShortPathName)的 ANSI 版本中, 路径长度被限制在 MAX_PATH(260) 个字符. 要拓展这个限制到 23767 宽字符(wide character), 请调用这个函数的 Unicode 版本, 并且在路径的首部加上 &ldquo;\\?\&rdquo;. 更多信息, 请查阅 文件, 路径, 以及命名空间的命名
原文:
In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend &ldquo;\?" to the path. For more information, see Naming Files, Paths, and Namespaces.
内容 3: 关于 Windows API 函数的 Unicode 版本和 ANSI 版本的区别, 可参阅: Windows API 函数后缀的作用</content></entry><entry><title>[C#] WinForm 与 WPF 获取命令行参数</title><url>https://slimenull.top/post/csharp-winformandwpfgetcommandlineargs/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>经验</tag></tags><content type="html"> 使用 Environment.GetCommandLineArgs() 即可, 但是需要去除第一个元素, 因为第一个元素时文件自身路径
推荐方法: 1. Environment.GetCommandLineArgs(); using System; Environment.GetCommandLineArgs(); // 返回 string[] 注意, 与控制台程序入口处的string[] args相比较, 这个函数返回的结果是完整的命令行, 也就是包含程序自身路径. 例如我一个没有传递任何参数的程序: 所以注意区分哦.
其他: WinForm 在 Program.cs 的 Main 入口参数处添加 string[] args, 然后你可以更改窗体的构造函数, 使其能够接收这个args. WPF 暂时不知道.</content></entry><entry><title>[踩坑记录] C# 源代码被误删, 通过反编译之前编译好的文件来拯救这一切, 三款反编译工具对比</title><url>https://slimenull.top/post/error-dotnet-decompileyourdeletedcode/</url><categories/><tags><tag>踩坑记录</tag><tag>.NET</tag><tag>C#</tag><tag>反编译</tag><tag>笔记</tag></tags><content type="html"> 结果是 ILSpy 效果最棒, dotPeek 启动速度慢, dnSpy反编译效果差
事件: 首先, 语言是C#, 然后我把代码给删了&hellip; 但是在删之前, 我编译过一次, 所以&hellip; 我就想着使用反编译工具来搞了.
我知道的反编译工具, dnSply, ILSpy, dotPeek
dnSpy是ILSpy的一个分支(dnSpy is a .NET assembly editor, decompiler, and debugger forked from ILSpy)
dotPeek 是 JetBrains 的反编译工具, 在这之前我还没使用过.
开始吧: > 首先, 是 dnSpy 上场: 乍一看, 没啥问题, 但是, 会有很多毛病哦~ 一一道来吧:
dnSpy 的反编译结果, 似乎不会吧字段和方法放在一起, 我也没找到它反编译的字段定义跑哪去了&hellip; 会有一大堆奇怪代码, 跟我们想要的源代码完全不一致, 即便导出为项目, 也会有无数个错误 总之, dnSpy是个反编译的好工具, 但还不能够完全获取源代码&hellip; 总之先导出一下吧, 选中你的项目, 然后程序左上角, 文件(File) -> 导出为项目(Export to project) 然后就是&hellip; 惨不忍睹&hellip; 左下角的错误数量 99+ 了已经, 完全没有纠错的必要. > 然后, 就是 ILSpy 上场了: 嗯好吧, 我承认 ILSpy 没有 dnSpy 好看, 但这可不是决定实力的第一要素.
你看到了, 枚举, 字段, 方法, 一切都井然有序 仔细看看, 中间的那个 switch 语句, 瞧瞧! 这不是 C#8 的新语法嘛! (我当初没有使用这个语法哦) 完全没有任何奇怪的变量名 那么我们尝试导出项目吧! 在左侧选中项目, 右击, 选择 Save Code 以导出项目 感动世界!!! 没有任何错误! 非常非常非常完美~ > 再试试 dotPeak: 哦豁, 看样子, 也不错啊.
dotPeek 没有像 ILSpy 那样将 switch 还原为 C#8 的语法, 而是使用的旧的语法 没有奇怪的变量名, 奇怪的语法 出现了我没有写过的东西, 标签 导出项目咯, 直接右击项目, 然后 Export to Project 唔, 一开始就与众不同呢&hellip; 跟普通的项目完全不一样, 少了一些文件夹&hellip; 嘛, 总之先试着打开吧. 果然在VS里面一眼就能看出错误了! 它居然在本地方法的前头中加了static&hellip; 好吧好吧, 我知道它们本质上是静态的, 但你这么弄, 我可就不能编译了呀. (假设我很懒, 懒到连这仅有的一个错误也不愿意改)
总结: 如果说我平常使用, 我肯定会用 dnSpy (颜值高), 毕竟平常还是很少改源代码甚至导出为项目滴, 如果是像这次的特殊情况, 我就会用 ILSpy, 很强大的有木有? 至于 dotPeek, 打入冷宫了, 而且加载速度慢的一批,,, 等它启动完, 黄花菜都凉了.
也算是大成功了, 所以,,, 如果想要通过反编译来挽回删掉的文件, 那么请使用 ILSpy 吧! 经过这一次使用, 我也是爱上 ILSpy了, 毕竟一开始我没报有这么大希望.
如果你觉得有什么改进的, 或者有什么下期文章的建议, 评论区见ovo</content></entry><entry><title>[踩坑记录] 某功能在C#7.3中不可用,请使用 8.0 或更高的语言版本 (通用解决方案)</title><url>https://slimenull.top/post/error-dotnet-featureinvalid/</url><categories/><tags><tag>踩坑记录</tag><tag>.NET</tag><tag>C#</tag></tags><content type="html"> 使用自动修复或者手动编辑项目文件指定语言版本
问题: 正如标题描述, 是某个语法在低版本中不受支持, 只需要升级到高版本即可.
步骤: > 第一种 :
使用快捷键 Alt + Enter 或点击黄色的的提示调出快速操作 选择 将该项目升级为 C# 语言版本 &ldquo;8.0&rdquo;
如果没有这一选项, 继续看第二种.
> 第二种 :
打开项目所在目录并打开项目文件. 在 PropertyGroup 节点下添加 LangVersion, 如图: 第二种其实就是通过更改 csproj 文件内容来置顶所使用的语言版本, 某些时候可能在这个文件中没有 LangVerison 节点, 就导致了快速操作中没有 &ldquo;升级项目版本&rdquo; 的选项, 这时就需要手动改文件了
如果没能解决你的问题, 麻烦在下面评论下, 这样我可以搜寻更多答案以修改这边文章. 如果解决了, 就点个赞吧 (卑微ovo)</content></entry><entry><title>[杂] 杜绝广告, 让你的电脑变的更加干净舒适</title><url>https://slimenull.top/post/sth-noad/</url><categories/><tags><tag>基础</tag><tag>杂</tag></tags><content type="html"> 电脑上弹广告, 这就是你的不对了, 为什么不好好整理一下电脑呢?
从根部治理, 拒绝流氓软件: 广告弹窗啊, 无非是用了流氓软件. 所以说, 少用流氓软件, 至于哪些是流氓软件, 杀毒软件我从来没用过(只用Windows Defender). 至于其它的, 能少用国内的就少用(忠告), 毕竟某些厂商的尿性, 咱都懂. 然后, 就是捆绑, 这个很简单, 其实原因就是你使用了所谓的"高速下载器", 而那些"高速下载器"在你电脑上安装了一堆你不需要的软件, 而避免方式就是, 永远不使用高速下载, 只选择本地下载或者地名+运营商的下载按钮. 例如, 上海电信下载. 还有就是, XXX下载站, XXX软件园, 这些地方少去, 下载软件还是去官方网站比较好.
然后就是流氓软件了, 国内最大的流氓, 莫过于杀毒软件了, 所以, 把你的360, 电脑管家, 金山毒霸, 鲁大师全部卸载了吧. 如果是火绒倒是可以留着, 这不算是流氓, 不过意义也不大就是了.
然后就是其它的流氓, WinRAR, Flash player, WPS之类的, WinRAR和Flash Player建议直接卸载, WPS可以通过控制面板的"卸载或更改"来关掉广告, 这个随便一搜索就能找到.
替代品: 既然说了不使用流氓软件, 肯定就还有推荐的软件的.
杀毒软件, 一般是不需要的, 除非你天天浏览奇怪的网站&hellip; 但即便那样, Windows Defender 也够用.
输入法. 不要用搜狗输入法! 不要用搜狗输入法! 不要用搜狗输入法! 这东西广告多的一批&hellip; 我跟你讲噢, windows是有自带的中文输入法的, 连日文以及其他语言也有&hellip; 所以完全没必要安装多余的输入法. 在 设置 -> 时间和语言 -> 语言 中添加中文, 然后点击中文, 点击选项, 在下面的键盘那里, 添加一个键盘, 微软拼音, 如果已经有了就不需要添加. 语言和键盘添加完毕后, 就可以通过 Win + 空格 键来切换语言, 哦对了, 如果你有一个 英文语言, 会好很多噢. Ctrl + Shift 是切换同一个语言内的不同键盘(输入法), Win + 空格 是直接切换语言, 这个要知道.
(好吧我知道肯定有人要喷, 说能够关闭搜狗输入法的广告啥的, 但是虽然关闭了, 但是它的广告功能其实还存在, 或者有些人是使用别的软件来屏蔽他的广告, 例如火绒, 至少本人作为一只强迫症是没办法忍受它的)
压缩包管理软件, 不使用WinRAR, 也不使用好压什么的软件, 你可以使用7zip, Bandzip, 或者360压缩的国际版.
浏览器, 不要使用360的任何一款浏览器,,, 因为它本身就有内置广告&hellip; 还有很多浏览器打的什么双核的幌子, 其实双核就是Chromium核+IE核, 现在IE核心已经没啥乱用了. 所以, 老老实实用系统自带的Edge, 如果你是Win7, 就去搜索Edge, 然后去官网下载. 或者, 你也可以用 Chrome, Firefox, 不过据我所知, 新Edge跟Chrome是一个核心的, 并且Edge优化了内存占用, 更推荐Edge.
然后是即时通讯软件, 不推荐使用QQ, 因为这玩意儿也有弹窗广告, 并且是关不掉的, 推荐使用TIM, 不用担心, TIM是QQ的办公版本, 与QQ的数据是同步的, 而且更为简洁方便, 所以, 非常推荐哦, 搜索TIM就能找到官网了
然后就是,,, 娱乐? 腾讯视频, 爱奇艺, 优酷, 这些软件我是不用的, 并且也不推荐使用. 我看视频消遣一向是哔哩哔哩(网页, 且无任何视频广告, 没错, 没有视频广告!)
(非要使用的话, 那就开个虚拟机? 我反正是完全无法忍受这些天天推广弹窗的软件存在于我的生产环境的, 所以开个虚拟机去弄这些, 也完全不会有问题)
音乐的话, 我是用的网易云音乐, 没发现什么流氓行为.
然后是办公软件, 如果你是使用的WPS, 推荐你更换为Office, 只要你电脑是整机购买的, 大多都是带有Office的, Office比WPS流畅很多呢. 如果你用习惯了WPS, 不愿更换, 并且忍受不了它的广告弹窗, 通过控制面板, 然后点卸载WPS(其实是"更改或卸载"), 里面是可以配置广告弹窗的
如果遇到广告弹窗? 这里呢, 再安利一个软件, 叫做Process Explorer, 里面有个功能, 可以通过窗口来查找进程, 操作非常的简单, 你呢, 在网上稍微搜索一下使用教程, 就彳亍, 通过它, 你可以很轻易的找到这个广告的主程序. 最后, 看看你是否认识他, 如果认识,,, 就想办法禁用掉广告, 网上会有一些方法的, 我也提两个吧.
先把后缀改为txt, 然后你就可以作为文本编辑它了, 打开它, 清空所有内容, 保存, 然后改为原来的后缀. 找到 uninstall.exe 类似的程序, 直接卸载完事儿. 保养措施: 在安装了一个软件后, 千万千万要检查它是否开机自动启动, 保证开机启动的都是你想要启动的程序.
最后: 我个人已经很久没见过弹窗广告了 (笑, 大概就是上面的那些经验了, 精髓就是, 绝对不使用流氓软件, 尽量避免使用国内软件.</content></entry><entry><title>[项目实例] 手把手教你使用Python写一个功能非常强大的翻译程序</title><url>https://slimenull.top/post/python-translateapp/</url><categories/><tags><tag>Python</tag><tag>网络</tag><tag>轮子</tag><tag>参考</tag></tags><content type="html"> 简单破解有道翻译 API, 然后调用, 实现在线翻译功能.
关于: 程序是借助API的(废话), 所以在无网络时, 没办法使用. 成品下载地址在文章末. 准备工作: 导入库, request(发送请求) 和 json(解析返回数据).
开搞: 首先, 是找到我们所需要的API, 瞧瞧这个链接: 有道翻译体验
虽说是体验, 但是我都用了巨长一段时间却没有任何问题, 看来这个API至少短时间内不会有任何变更了~
然后就是破解API的请求内容了. 打开浏览器调试, 转到网络选项卡, 然后重新翻译一下, 好的, 结果很明显, 芜湖 :-D post请求, 3个参数, q是翻译内容, from和to表示翻译的语言, 那么, 试着换一下语言吧. 哦, 我们得到了中文与日文的对应数据, zh-CHS 和 ja, 还有更多语言呢, 看看HTML节点吧 哦豁, 比想象中的要简单! 2就是to的意思, 那么, 我们能得到所有的语言对应参数值了! 记录下来吧~
参数: q:翻译文本 from:从语言 to:至语言 语言支持的值: 中文:zh-CHS, 英语:en, 日语:ja, 韩语:ko, 法语:fr, 俄语:ru, 西班牙语:es, 葡萄牙语:pt, 越南语:vi, 德语:de, 印尼语:id 阿拉伯语:ar 接下来, 就是对网页中, 源代码的进一步分析了, 检查"翻译"按钮的节点, 然后查看click事件监听代码. 然后, 回到刚刚的网络选项卡, 然后重新翻译一下, 查看返回值. 弄到 Visual Studio Code里面, 保存为json文件, 然后格式化文档. 但是, 不止如此, 我们再尝试翻译一些, 词, 例如 sugar, 然后看看返回值, 不出所料, 果然! 返回值里面包含的内容不是一般的多啊, 甚至还有音标, hhh
{ "returnPhrase": [ "sugar" ], "query": "sugar\n", "errorCode": "0", "l": "en2zh-CHS", "tSpeakUrl": "http://openapi.youdao.com/ttsapi?q=%E7%B3%96&amp;langType=zh-CHS&amp;sign=B212B7714049BBB65257DC9D64234EA0&amp;salt=1612384414308&amp;voice=4&amp;format=mp3&amp;appKey=2423360539ba5632&amp;ttsVoiceStrict=false", "web": [ { "value": [ "糖", "食糖", "白糖", "糖分" ], "key": "Sugar" }, { "value": [ "红糖", "黄糖" ], "key": "brown sugar" }, { "value": [ "糖用甜菜", "甜菜", "糖甜菜", "糖料甜菜" ], "key": "Sugar beet" } ], "requestId": "f54b0c24-4818-4d7e-ab04-8123adec8671", "translation": [ "糖" ], "dict": { "url": "yddict://m.youdao.com/dict?le=eng&amp;q=sugar%0A" }, "webdict": { "url": "http://m.youdao.com/dict?le=eng&amp;q=sugar%0A" }, "basic": { "exam_type": [ "初中", "高中", "CET4", "CET6", "考研", "SAT" ], "us-phonetic": "ˈʃʊɡər", "phonetic": "ˈʃʊɡə(r)", "uk-phonetic": "ˈʃʊɡə(r)", "wfs": [ { "wf": { "name": "复数", "value": "sugars" } }, { "wf": { "name": "过去式", "value": "sugared" } }, { "wf": { "name": "过去分词", "value": "sugared" } }, { "wf": { "name": "现在分词", "value": "sugaring" } }, { "wf": { "name": "第三人称单数", "value": "sugars" } } ], "uk-speech": "http://openapi.youdao.com/ttsapi?q=sugar%0A&amp;langType=en&amp;sign=C668ACDF9C58F3D76BADC5B54F1BDEE7&amp;salt=1612384414308&amp;voice=5&amp;format=mp3&amp;appKey=2423360539ba5632&amp;ttsVoiceStrict=false", "explains": [ "n. 糖；食糖；甜言蜜语", "vt. 加糖于；粉饰", "vi. 形成糖", "n. (Sugar)人名；(英)休格" ], "us-speech": "http://openapi.youdao.com/ttsapi?q=sugar%0A&amp;langType=en&amp;sign=C668ACDF9C58F3D76BADC5B54F1BDEE7&amp;salt=1612384414308&amp;voice=6&amp;format=mp3&amp;appKey=2423360539ba5632&amp;ttsVoiceStrict=false" }, "isWord": true, "speakUrl": "http://openapi.youdao.com/ttsapi?q=sugar%0A&amp;langType=en&amp;sign=C668ACDF9C58F3D76BADC5B54F1BDEE7&amp;salt=1612384414308&amp;voice=4&amp;format=mp3&amp;appKey=2423360539ba5632&amp;ttsVoiceStrict=false" } 是不是已经有些感到兴奋了呢? 现在, 开始正式Coding吧!
先是以自动识别语言开始吧. 那么, 首先是最基本的导库与定义:
import requests import json url = 'https://aidemo.youdao.com/trans' ''' 有道翻译API, 支持get与post 参数: q:翻译文本 from:从语言 to:至语言 语言支持的值: 中文:zh-CHS, 英语:en, 日语:ja, 韩语:ko, 法语:fr, 俄语:ru, 西班牙语:es, 葡萄牙语:pt, 越南语:vi, 德语:de, 印尼语:id 阿拉伯语:ar 错误码: 411:过于频繁 413:访问上限 103:字符太长 410:过于频繁 ''' 然后是请求
def translate(text): try: data = {"q": text, "from": "auto", "to": "auto"} resp = requests.post(url, data) except: return None return resp 然后是打印翻译结果:
advancedmode = False # 默认状态下, 不展示所有信息, 当advancedMode为True时, 展示更多内容 def listPrint(obj, iden, ps = ''): print("\n".join(' ' * iden + ps + str(i) for i in obj)) def printrst(resp): if resp is not None and resp.status_code == 200: respJson = json.loads(resp.text) if advancedmode: print(" &lt;0> Result:") if "translation" in respJson: print(" Normal:") listPrint(respJson["translation"], 9) if "basic" in respJson and "explains" in respJson["basic"]: print(" Basic:") listPrint(respJson["basic"]["explains"], 9) if "web" in respJson: print(" From web:") index = 1 for i in respJson["web"]: print(" %d. %s:" % (index, i["key"])) listPrint(i["value"], 14) index += 1 # print else: print(" &lt;0> Result:") listPrint(respJson["translation"], 7) else: print("Request error, status code: %s" % (resp.status_code if resp != None else "???")) 既然都有advancedMode了, 所以得让用户有办法打开关闭它, 模拟简单的命令行吧, 如果输入的内容是以 $ 开头的, 则判定为命令, 并运行这个命令
def runcmd(cmd): cmdline = cmd.split(' ') cmdname = cmdline[0].lower() if cmdname == '$': global advancedmode advancedmode = not advancedmode print(" &lt;$> AdvancedMode: %s" % advancedmode) elif cmdname == '$help': if len(cmdline) == 1: print(" &lt;$> Help document, type '$help command' for more information.") listPrint(( "$ : Switch Advanced Mode.", "$help : Display help document." "" ), 7) elif len(cmdline) == 2: if cmdline[1] == '$': print(" &lt;$> Switch Advanced Mode.") listPrint(( "Advanced Mode: %s" % advancedmode, "If advanced mode is enabled, more information will be shown. default value is disabled." ), 7) else: print(" &lt;$> Help document: unknown command.") else: print(" &lt;$> Help document: unknown usage.") else: print(" &lt;$> Unknown command.") # 更多指令, 你来添加吧, 例如切换语言 最后是主程序
if __name__ == "__main__": print("Null.Translator, by Null, type '$help' for help. ref: Youdao AI translation api.") while True: text = input("\n>>> ") # 模拟像Python那样的提示符, 很酷炫的有木有 if text != '': if text.startswith('$'): runcmd(text) else: resp = translate(text) printrst(resp) else: exit() # 如果输入为空, 则退出, 方便退出程序. (表示懒得挪鼠标 滑稽) (最后, 上面所有的代码片, 拼在一起, 就能运行, 懒得拼的话, 就点击下面的下载链接下载吧)
再多说一句, 那个API返回的数据辣么多, 想实现什么功能自己随便实现啦~
下载链接: CSDN站内下载: Null.Translator
预告: 这可不就是一个文本转语音API嘛! 薅有道羊毛真不戳</content></entry><entry><title>[C#] 单文件编译 - 编译时嵌入dll</title><url>https://slimenull.top/post/csharp-embeddll/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag></tags><content type="html"> 直接安装 Costura.Fody 库就能使项目单文件编译啦~
1.打开 NuGet 包管理器 位于 工具 -> NuGet 包管理器 -> 管理解决方案的 NuGet 程序包 2. 安装 搜索 Costura.Fody 并将其安装到你的项目 3. 起飞 然后, 进行编译, 你就会发现! 所有的dll全部被打包进exe中啦~~~</content></entry><entry><title>[项目实例] 使用 IronPython 库来创建一个支持使用Python脚本操作的简易文本编辑器</title><url>https://slimenull.top/post/csharp-ironpytxteditor/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>参考</tag></tags><content type="html"> 支持使用 Python 脚本来操作文本内容的简单编辑器
步骤 : 打开 nuget 包管理器, 工具 -> NuGet 包管理器 -> 管理解决方案的 NuGet 程序包. 在 nuget 包管理器中找到 IronPython, 安装到你的项目. using 所需的命名空间, Microsoft.Scripting, Microsoft.Scripting.Hosting, Microsoft.Win32, IronPython.Hosting.
创建 Python 引擎:
ScriptEngine engine = Python.CreateEngine(); ``
创建定义域(Scope), 它用来存储变量:
ScriptScope scope = engine.CreateScope(); ``
在 Scope 中设置与获取变量值:
scope.SetVariable("name", "value"); // 其中, name是变量名, "value"可以是任意类型, 表示变量值 `` 获取变量也差不多, 是GetVariable.
设置引擎的标准输出流以捕获内容:
TriggerStream stream = new TriggerStream(); // TriggerStream是一个能够在写入时触发事件的, 继承了Stream的类. engine.Runtime.IO.SetOutput(stream, Encoding.Default); // 这样, 我们可以通过TriggerStream的写入事件来获取写入的内容 `` 提示: 了解 TriggerStream, 请查看这篇文章: 支持事件的Stream
, 关于为什么使用 Encoding.Default 而不使用 UTF-8, 是因为在Windows里面, 都是用的 ANSI. 而Default就是获取ANSI的编码(在中国是GBK)
执行 Python 代码:
ScriptSource thisSrc = engine.CreateScriptSourceFromString("print('hello world')", SourceCodeKind.File) thisSrc.Execute(scope); // 代码在这个定义域种执行 `` SourceCodeKind.File指这个字符串是来自文件的代码, 也就是说你可以在里面加换行加缩进以定义一个语句块之类的. 还有一个就是SourceCodeKind.Expression, 指一个表达式.
项目 : 项目已经在 GitHub 开源, 地址: SlimeNull/Null.TextEditor
想直接下载成品? 希望你能下载成功: Release/Null.TextEditor.exe</content></entry><entry><title>[C#] Stream 支持写入读取触发事件的类库</title><url>https://slimenull.top/post/csharp-triggerstream/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>轮子</tag></tags><content type="html"> 在写入, 读取, 寻址时触发事件的Stream
实现了 : 你可以将这个流类的实例提供给某些东西, 在它操作这个流时, 你可以通过事件来接收到消息, 并加以处理, 例如拒绝写入, 或在写入前判断写入的内容. 你可以稍微改动一下这个类以适应你的需求.
应用场景: 例如你使用了 IronPython 库, 并使用它执行了一些操作, 你希望 IronPython 每次 print 时, 你都能获取到内容, 则, 你可以使用这个触发流(TriggerStream)类, 将 IronPython 引擎的标准输出流设置为触发流的实例, 这样, 每当 IronPython 有内容输出时, 你都能获取到内容. 例如这个项目: 使用IronPython来制作一个支持py脚本操作内容的简易文本编辑器
应用场景: 例如, 你运行了一个 Process, 并且希望实时获取它的输出内容, 而不是运行完之后一次性获取所有内容, 同理, 你可以设置它的标准输出流为触发流实例, 然后每次它输出内容你都能接收到.
源代码 : 首先是仅仅包含触发器, 而不会有任何存储行为的类
using System; using System.IO; namespace Null.Library.TriggerStream { class WriteStreamEventArgs : EventArgs { public byte[] Buffer; public int Offset, Count; public bool Denied = false; } class TriggerStream : Stream { public override bool CanRead => false; public override bool CanSeek => false; public override bool CanWrite => true; public override long Length => 0; public override long Position { get => 0; set { } } public override void Flush() { } public override int Read(byte[] buffer, int offset, int count) { return 0; } public override long Seek(long offset, SeekOrigin origin) { return 0; } public override void SetLength(long value) { } public override void Write(byte[] buffer, int offset, int count) { if (PreviewWrite != null) PreviewWrite.Invoke(this, new WriteStreamEventArgs() { Buffer = buffer, Offset = offset, Count = count, }); } public event EventHandler&lt;WriteStreamEventArgs> PreviewWrite; } } 很明显能够看出, 上面的这个, 仅有事件触发, 而Seek, Read, Position等方法及属性, 都是直接使用的空或者返回合适的固定值.
然后是带有存储功能的(使用MemoryStream)类
using System; using System.IO; namespace Null.Library.EventedStream { class ReadStreamEventArgs : EventArgs { public byte[] Buffer; public int Offset, Count; public bool Denied = false; } class WriteStreamEventArgs : EventArgs { public byte[] Buffer; public int Offset, Count; public bool Denied = false; } public class FlushStreamEventArgs : EventArgs { public bool Denied = false; } public class SetStreamLengthEventArgs : EventArgs { public long Value; public bool Denied = false; } public class SeekStreamEventArgs : EventArgs { public long Offset; public SeekOrigin SeekOrigin; public bool Denied = false; } class EventedStream : Stream, IDisposable { MemoryStream baseMemory = new MemoryStream(); public override bool CanRead => baseMemory.CanRead; public override bool CanSeek => baseMemory.CanSeek; public override bool CanWrite => baseMemory.CanWrite; public override long Length => baseMemory.Length; public override long Position { get => baseMemory.Position; set => baseMemory.Position = value; } public override void Flush() { if (PreviewFlush != null) { FlushStreamEventArgs args = new FlushStreamEventArgs(); PreviewFlush.Invoke(this, args); if (args.Denied) return; } baseMemory.Flush(); } public override int Read(byte[] buffer, int offset, int count) { if (PreviewRead != null) { ReadStreamEventArgs args = new ReadStreamEventArgs() { Buffer = buffer, Offset = offset, Count = count }; PreviewRead.Invoke(this, args); if (args.Denied) return 0; } return baseMemory.Read(buffer, offset, count); } public override long Seek(long offset, SeekOrigin origin) { if (PreviewSeek != null) { SeekStreamEventArgs args = new SeekStreamEventArgs() { Offset = offset, SeekOrigin = origin }; PreviewSeek.Invoke(this, args); if (args.Denied) return Position; } return baseMemory.Seek(offset, origin); } public override void SetLength(long value) { if (PreviewSetLength != null) { SetStreamLengthEventArgs args = new SetStreamLengthEventArgs() { Value = value }; PreviewSetLength.Invoke(this, args); if (args.Denied) return; } baseMemory.SetLength(value); } public override void Write(byte[] buffer, int offset, int count) { if (PreviewWrite != null) { WriteStreamEventArgs args = new WriteStreamEventArgs() { Buffer = buffer, Offset = offset, Count = count }; PreviewWrite.Invoke(this, args); if (args.Denied) return; } baseMemory.Write(buffer, offset, count); } public new void Dispose() { baseMemory.Dispose(); } public event EventHandler&lt;FlushStreamEventArgs> PreviewFlush; public event EventHandler&lt;SetStreamLengthEventArgs> PreviewSetLength; public event EventHandler&lt;SeekStreamEventArgs> PreviewSeek; public event EventHandler&lt;WriteStreamEventArgs> PreviewWrite; public event EventHandler&lt;ReadStreamEventArgs> PreviewRead; } } 原理 : 倒也简单, 直接继承基类, 然后实现方法即可.
提示 : 如果你要同时使用这两个,,, 别忘记稍微移动下事件参数使它们在同一个文件中, 并使两个事件流类using事件参数的命名空间, 否则, 在不完全指定命名空间的状况下, 会出现不明确引用的错误.</content></entry><entry><title>[踩坑记录] ASP.NET Core System.Data.SqlTypes.SqlNullValueException: 数据为空。不能对空值调用此方法</title><url>https://slimenull.top/post/aspnet-sqlnull/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>ASP.NET</tag></tags><content type="html"> 添加空值检查或者直接设置数据库字段不可空
问题是出在这里的: SoftwareInfo result = new SoftwareInfo( reader.GetString(1), // reader 是 MySqlDataReader 实例 reader.GetString(7)) { ID = reader.GetInt32(0), Label = reader.GetString(2), Coder = reader.GetString(3), DownloadCount = reader.GetInt32(4), Stars = reader.GetFloat(5), Introduction = reader.GetString(6) }; return result; 解决方案: 第一种: 添加 Null 检查, 在调用 GetString, GetInt32, GetFloat 这类包含具体的类型转换的函数前, 先调用 IsDBNull 检查这条数据是不是 Null.
SoftwareInfo currentInfo = new SoftwareInfo( reader.GetString(1), reader.GetString(7)) { ID = reader.GetInt32(0), Label = reader.IsDBNull(2) ? null : reader.GetString(2), Coder = reader.IsDBNull(3) ? null : reader.GetString(3), DownloadCount = reader.IsDBNull(4) ? 0 : reader.GetInt32(4), Stars = reader.IsDBNull(5) ? 0 : reader.IsDBNull(5) ? 0 : reader.GetFloat(5), Introduction = reader.IsDBNull(6) ? null : reader.GetString(6) }; return currentInfo; 第二种: 直接指定数据库的字段不可为 Null, 从根本上杜绝空值
altertabletablenamemodifycolumnnamenotnull;原因: 如果数据是 Null, 就无法调用包含具体类型的方法, 因为它们内部涉及到类型转换.</content></entry><entry><title>[Android] Android 入门 - 1.初识IDE</title><url>https://slimenull.top/post/android-getstarted/</url><categories/><tags><tag>Android</tag><tag>教程</tag><tag>笔记</tag></tags><content type="html"> 从这篇文章摆脱对新知识的恐惧
我也是初学 Android Studio (甚至不到一个星期), 也察觉到了&hellip; 关于这方面的图文资料居然那么少, 全都是视频教程, 为了想要节省时间的同学着想, 我挺身而出了. 不是适合所有人哦~ 你得懂一些英文, 你需要有Java基础, 不需要技术多厉害, 会写Hello world就行.但是如果你不满足条件, 推荐你去B站找视频教程. 下载IDE 下载肯定简单咯, 直接去官网吧: 链接地址
, 然后, 额, 我相信你的英文水平足以支持你找到下载按钮的, 安装IDE 安装也差不多是傻瓜式安装了, 因为本人也是刚入门, 所以, 差不多是一路同意接受确认. 噢需要提到的是, Android Studio 支持使用 Java 或者 Kotlin 来编写程序, Kotlin 是编程语言哦, 这个知道就好. 创建项目 打开Android后, 点击Create a project, 然后你看到的是这个: 看到了吗? 这是模板, 也就是给你的安卓程序创建最开始的一个页面, 不过作为我们初学者, 使用 Empty Activity 就好了~ Activity 的话, 其实就是相当于 Android 程序中的一个页面咯, 那么我们继续(Next), 你会看到项目配置: 能看懂吧, 名字, 包名, 保存路径, 语言, 是的, 在 Language 那里需要选择你要使用的编程语言, 例如我这里使用Java. 然后, 包名的命名, 你可以这么命名: &ldquo;域名.你的名字.项目名&rdquo;, 然后 Minimum SDK, 最低版本的SDK, 这个决定了你能够使用的功能(因为不同版本的SDK功能会有差异)以及程序的兼容性(例如使用了高版本SDK的程序无法在Android版本较低的手机上运行), 其他内容的话, 我相信你能看懂. 锵锵~ 新项目创建完成了~ 菜单栏 额, 讲到这里, 用过IDEA的童鞋肯定会直接芜湖起飞的, 因为, Android Studio有JetBrains内味儿, 说不熟悉是假的, 不过,,, 既然都有Java基础了, 这点英文应该彳亍口巴? 常用的也就那么点了, 像是换配色, 更换快捷键, 你可以在网上搜索, 然后慢慢的, 你就会用了. 项目结构 呐, 这是最初的项目了, 先莫得慌张, 我们得先知道左侧那一堆东西是干啥用的. 首先看到的就是 MainActivity, 对吧, 前面说了 Activity 是一个界面, 这个, 就是主界面了. 接下来, 我们展开这些目录, 然后看看所有的东西 大概就是这些内容了, 对于入门教程, 你只需要关心layout文件夹(存放布局文件)以及java源代码文件夹. 编辑界面 首先就是打开我们主页面(MainActivity)的布局文件, MainActivity.xml 可视化编辑页面出现了 然后, 点击右上角的Split(被我用红色线框标注了的按钮), 切换到拆分设计模式, 然后, 左侧代码, 右侧是布局预览, 可以边写代码边查看效果. 一般的, 我们还是使用代码来编辑界面的, 具体这些内容是什么意思, 我们下篇文章再讲 (咕咕咕?) 界面代码 打开 MainActivity.java, 额, 如图所示 喏, 然后就是最基本的解释了. 创建AVD AVD, 即Android virtual device, 类似于虚拟机的玩意儿, 虚拟的安卓机, 可以用来运行你的程序, 所以在运行我们的程序之前, 必须得创建一个AVD, 点击AVD管理器 这就是AVD管理器了, 那么创建你的第一个虚拟设备吧~ 在这里选择你想要使用的设备配置, 然后继续 接下来就是选择系统镜像了, 默认是没有下载的, 你需要下载一个你想要使用的系统镜像, 点击系统镜像名称后的下载按钮以下载它 等待他下载吧, 1GB也不是很大. 下载完成后, 选择你想要使用的系统镜像, 然后继续 最后是验证配置信息 哦对了, 有一条需要注意, 展开高级配置, 然后找到 Performance, Boot option, 看到了吗? Cold boot 和 Quick boot, 这俩类似于电脑的快速启动, 如果使用 Cold boot, 每一次启动这个虚拟设备, 都跟手机开机一样, 如果使用Quick boot, 那启动这个虚拟设备, 就是从上次退出时保存的状态启动, 宛如电脑从休眠状态启动. (如果你还是不懂, 就去搜索一下什么是休眠). 之说注意这一点, 是因为, 如果你这个设备死机了, 并且你使用的是Quick boot, 那你关闭虚拟设备再打开虚拟设备, 还是死机的状态&hellip; 所及建议改为Cold boot. 万事具备后, 就点Finish吧. 哦对了, 原生安卓玩起来真的超级舒服哦~ 运行程序 点击运行按钮即可编译项目并在指定的设备上运行程序 需要知道的是, 运行了的虚拟设备是已经开启了调试功能的, 在你查看完运行结果后, 不必关闭虚拟设备, 虚拟设备随时为你的调试工作待命! 同时, 你也可以用你的手机进行调试, 使用数据线连接手机和电脑, 然后打开手机的调试功能, 在 Android Studio 中, 运行按钮左侧的选择设备中, 能够找到你的手机. 原生安卓 原生安卓, 可能有些人不大会用吧(例如笔者), 这里就说一点吧, 查看所有已安装的程序, 只需要在主屏幕从导航键或任意空白处向上滑动, 就能彳亍了 结束了 哈, 彳亍了口巴, 通过这篇文章, 绝对能消除你对Android Studio的恐惧了, 关于更多教程, 会继续更新的, 敬请关注~ 有什么建议, 或者需要改正的地方, 可以通过评论或私信指出哦, 别忘了点个赞~</content></entry><entry><title>[Web] 浅谈 Get 与 Post 请求</title><url>https://slimenull.top/post/web-aboutgetandpost/</url><categories/><tags><tag>Web</tag><tag>HTTP</tag><tag>Python</tag><tag>HTML</tag></tags><content type="html"> 关于 Get 与 Post 的最基本知识, 以及使用 Python 编写简单的请求示例
HTTP 请求 前端与后端的数据传递是通过 HTTP 请求实现的, 浏览器(前端)向服务器(后端)发送一个 HTTP 请求, 后端对请求进行处理, 然后再给浏览器发一个响应, 这就是 HTTP 的基本概念.
Get 和 Post 是HTTP请求的两种方式, 最明显的区别是传递参数.
如果你不大了解 HTTP 请求, 可以先查看文章末对 HTTP 的简述.
HTTP Get 概述 Get 的意思是获取, 它一般也是用于进行数据的获取. 浏览器访问一个页面时, 发送的第一个请求就是 Get.
Get 的参数将直接写明在请求 URL 中, 这意味着, 任何人可以直接通过浏览器上方的地址来清除的看到, 例如你要下载一个东西, 文件名叫 &lsquo;idea&rsquo;, 将文件名作为filename参数传递过去, 那么这个请求类似于这样:
https://xxx.com/download/?filename=idea 在 URL 中, 写一个 &lsquo;?&rsquo; 表示后面的内容是参数, 然后以 参数名=参数值 的格式表示参数, 如果要传多个参数, 则使用 &lsquo;&amp;&rsquo; 连接它们
服务端接收到你的请求后, 可以根据参数来做出对应处理, 然后发送合适的响应.
示例 在浏览器新建选项卡, 在地址栏中输入一个地址, 发送的是一个 Get 请求, 所以我们可以直接通过这个来测试.
hitokoto 是一个提供&rsquo;一句话&rsquo;的网站, 提供了接口以供开发这调用, 其中一个是:
地址 协议 方法 v1.hitokoto.cn HTTPS ANY 其中一个参数是:
参数 值 可选 说明 encode text / json / js 是 返回的编码 方法是 Any, 即, 同时支持 Get 与 Post, 那么我们尝试使它返回一个格式为文本的结果, 对应的 URL 是:
https://v1.hitokoto.cn/?encode=text hitokoto 服务器返回了我们所需要的值:
那么, 如果是json呢? 试试看吧:
https://v1.hitokoto.cn/?encode=json hitokoto 服务器又返回了我们所需要的值:
HTTP Post 概述 Post 有 &lsquo;邮递,布置&rsquo; 的意思, 一般用来将数据提交给服务端.
看完 Get, 你也知道了 Get 的一个特点: 参数直接暴露在 url 中, 直接被别人看 到, 肯定是不大妥当的, 假如你要向服务器提交你的密码, 让别人看到, 那就不好了, 而 Post 相对 Get 来说, 就稍微安全点了, 因为参数在这个HTTP请求体中.
一个POST请求的概述:
它的响应内容:
由此可知, POST可以大致认为, 只是将参数放到了请求体中, 相对来说, 严谨一些.
示例 因为大多数浏览器不能直接发送 post 请求, 所以我们通过 python 与一个测试网页来测试:
有道有一个翻译接口示例, 支持 post 请求
地址: &lsquo;https://aidemo.youdao.com/trans'
参数 介绍 值 q 翻译文本 要进行翻译的文本 from 从哪种语言翻译 auto / zh-CHS / en / 其他 to 翻译到哪种语言 auto / zh-CHS / en / 其他 我们可以使用 Python 通过 requests 包来发送 post 请求.
import requests url = "https://aidemo.youdao.com/trans" args = {"q": "翻译这段话", "from": "auto", "to": "auto"} resp = requests.post(url, args) # 发送请求, 并将响应赋值到resp print(resp.text) # 打印响应解码后的文本 运行后, 可以看到, 返回了我们需要的数据:
在网页中, 我们可以使用 form 表单来发送 get 或 post 请求, 下面编写一个简单的 html 文件来测试:
&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>Post Request Demo&lt;/title> &lt;/head> &lt;body> &lt;form action="https://aidemo.youdao.com/trans" method="post" target="_blank"> &lt;label for="kwd">关键字:&lt;/label> &lt;input id="kwd" type="text" name="q" placeholder="输入关键词"/> &lt;input type="hidden" name="from" value="auto"/> &lt;input type="hidden" name="to" value="auto"/> &lt;input type="submit" value="请求"/> &lt;/form> &lt;/body> &lt;/html> 打开这个 html 文件:
输入 &ldquo;白嫖有道翻译API真棒&rdquo; 并按下请求按钮, 返回了我们所需要的数据: ​ 指正 可能会有人告诉你, get 比 post 安全, 但事实上, 这仅仅是针对门外汉, 你只需要打开浏览器调试功能, 就可以看到这个页面的一切请求以及请求的各种详细内容, post 的参数也能看到.
所以说, 说 post 安全, 只是指它的参数不能直接在 url 中看到, 但只要你想看, 只需要打开调试&hellip;
附加: HTTP 概述 一个HTTP数据包有头和体两部分, 头中包含了一些摘要数据, 这些数据以键值对的形式存放, 例如指定可接收的数据类型, 指定编码, 压缩算法, 数据长度等. 体中是这个包的主要内容, 例如传输文件时, 文件内容就位于体中. 如果想要详细的了解HTTP数据的内容, 不妨在浏览器中按下F12, 打开调试, 进入 &lsquo;网络(Network)&rsquo; 选项卡, 刷新页面, 然后观察一个个的数据包.</content></entry><entry><title>[C#] TOC Tiny - 基于 TCP 套接字的简易网络聊天室</title><url>https://slimenull.top/post/csharp-simplechat/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>网络</tag><tag>轮子</tag></tags><content type="html"> WPF 网络聊天小程序, 最新版已经支持图像发送
简介: 之前开了一个大坑, 额, 其实就是带有注册登录, 然后完美解决粘包, 心跳包, 还有并发量等问题的坑, 但是太难填了(我太菜了), 于是我就开了一个新项目, 砍掉登陆注册功能, 直接作为聊天室开放&hellip; 预览: 难题是如何解决的:
首先是传输协议, 我这里的数据传输, 无论是什么数据, 都是一个TransPackage实例, 里面有基本的结构, 就是Name, Content, ClientGuid, PackageType这四个字段(除此之外就没了). 然后把它们弄成字符串, 然后弄成字符数组, 然后发送. 关于粘包, 也就是两个包黏在一起, 我这里使用的是自己封装好的事件驱动的套接字, 粘包问题发生时, 就是在一次收到消息时, 收到了两个或以上的包, 而每个包都是一个Json数据, Json数据的特点呢, 就是很容易能分开, 例如你Object并列, 没有分隔符, 也能明确的知道这是两个Object, 于是我又为我自己造的轮子 CHO.Json
优化了一波, 使它支持这个功能 关于并发, 其实这个问题在你发现TCP时全双工的时候就不需要考虑了, 因为是聊天室, 所以也不必担心什么. 之所以我考虑这个, 是因为我在很久之前写的聊天小程序, 由于我把TCP当成半双工用, 导致不能太过频繁的处理消息, 否则就可能会嗝屁, 但这次有我封装好的事件套接字, 就方便多了 更新记录: 最新版已经支持发送图片, 以及对图片的查看(旋转缩放移动)
下载链接： CSDN下载</content></entry><entry><title>[C#] 控制台动态输入</title><url>https://slimenull.top/post/csharp-dynamicinput2/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>轮子</tag></tags><content type="html"> 在输入的过程中就能获取, 设置已经输入的内容, 甚至移动输入内容在控制台中的显示位置
简介： 这是一个类库，正如标题所说，它具有这两个最基本而又强大的功能，有时候，我们可能会需要在ReadLine的过程中就访问已经输入了的内容，但.NET又没有提供这样的功能。 其实在之前已经写过一个文章，也是动态输入，但是太烂了地址：旧的动态输入
功能： 在ReadLine的时候就读取已经输入了的内容，提供了完整的封装 移动已经输入了的内容，你可以在输入时就将输入内容移动到控制台的任意位置 光标移动，插入和覆盖模式，HOME和END键的处理。 字符输入事件，在用户按下后，会有两个事件触发，可以通过这两个事件来过滤用户输入内容，例如，仅允许输入数字，只需要判断事件参数即可。 密码输入模式，与Linux的密码输入一致，不会显示任何内容，但功能按键以及输入事件仍然可用 历史记录功能，它模拟的是Linux系统的命令行输入历史记录功能，比Windows的历史记录功能好那么一丢丢。 （后续会增加更多功能，如果我需要或者你需要的话。 原理： 其实就是对 Console.ReadKey() 的妙用 使用方式： 实例化一个DynamicScanner对象。 调用DynamicScanner的ReadLine()方法或者QuietReadLine()方法 读取正在输入的内容，请使用类实例的InputtingString属性 获取已输入内容的起始位置以及末端位置, 可使用StartLeft, StartTop, EndLeft, EndTop属性 CharInput事件是当字符输入并且已经录入后触发的，PreviewCharInput是字符已经输入，但是并未录入的事件，CharInput要求返回值指定是否停止输入，PreviewCharInput要求返回值指定是否取消录入 如果代码有部分可以优化的部分，或者你有好的点子，欢迎私信我哦~ 2021 / 1 / 5: 更新了源代码, 优化了一个小细节: 当此次输入为空时, 不保存历史记录
源代码： 创建一个名为Null.DynamicScanner.cs的文件，粘贴以下内容，添加到你的项目中，即可使用 using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace Null.Library { public class DynamicScanner { int startTop, startLeft, endTop, endLeft, currentTop, currentLeft, tempEndTop, tempEndLeft; int inputIndex, historyIndex; bool insertMode = true, inputting = false, cursorVisible; private readonly object printting = false; // 用于互斥锁 ConsoleKeyInfo readedKey; private readonly List&lt;List&lt;char>> inputHistory; private List&lt;char> inputtingChars; private string promptText = string.Empty; public delegate bool CharInputEventHandler(DynamicScanner sender, ConsoleKeyInfo c); public delegate bool PreviewCharInputEventHandler(DynamicScanner sender, ConsoleKeyInfo c); public event CharInputEventHandler CharInput; public event PreviewCharInputEventHandler PreviewCharInput; public DynamicScanner() { inputHistory = new List&lt;List&lt;char>>(); } public string InputtingString { get { return inputtingChars == null ? string.Empty : new string(inputtingChars.ToArray()); } } public int StartTop { get => startTop; } public int StartLeft { get => startLeft; } public int EndTop { get => endTop; } public int EndLeft { get => endLeft; } public int CurrentTop { get => currentTop; } public int CurrentLeft { get => currentLeft; } public bool IsInputting { get => inputting; } public string PromptText { get => promptText; set => promptText = value; } public static bool IsControlKey(ConsoleKey k) { return k == ConsoleKey.Enter || k == ConsoleKey.UpArrow || k == ConsoleKey.DownArrow || k == ConsoleKey.LeftArrow || k == ConsoleKey.RightArrow || k == ConsoleKey.Insert || k == ConsoleKey.Backspace || k == ConsoleKey.Delete || k == ConsoleKey.Home || k == ConsoleKey.End; } private void InitReadLine() { startTop = Console.CursorTop; startLeft = Console.CursorLeft; inputIndex = 0; if (inputHistory.Count == 0 || inputHistory[inputHistory.Count - 1].Count != 0) { historyIndex = inputHistory.Count; inputHistory.Add(new List&lt;char>()); } else { historyIndex = inputHistory.Count - 1; } inputtingChars = inputHistory[historyIndex]; inputting = true; } private bool DealInputChar() { switch (readedKey.Key) { case ConsoleKey.Enter: Console.WriteLine(); return true; case ConsoleKey.UpArrow: if (historyIndex > 0) { historyIndex--; UpdateInputState(); } break; case ConsoleKey.DownArrow: if (historyIndex &lt; inputHistory.Count - 1) { historyIndex++; UpdateInputState(); } break; case ConsoleKey.LeftArrow: if (inputIndex > 0) { inputIndex--; } break; case ConsoleKey.RightArrow: if (inputIndex &lt; inputtingChars.Count) { inputIndex++; } break; case ConsoleKey.Insert: insertMode = !insertMode; break; case ConsoleKey.Backspace: if (inputIndex > 0) { inputtingChars.RemoveAt(inputIndex - 1); inputIndex--; } break; case ConsoleKey.Delete: if (inputIndex &lt; inputtingChars.Count) { inputtingChars.RemoveAt(inputIndex); } break; case ConsoleKey.Home: inputIndex = 0; break; case ConsoleKey.End: inputIndex = inputtingChars.Count; break; default: if (inputIndex == inputtingChars.Count) { inputtingChars.Add(readedKey.KeyChar); } else { if (insertMode) { inputtingChars.Insert(inputIndex, readedKey.KeyChar); } else { inputtingChars[inputIndex] = readedKey.KeyChar; } } inputIndex++; break; } return false; } private void PrintInputString() { lock(printting) { cursorVisible = Console.CursorVisible; Console.CursorVisible = false; Console.SetCursorPosition(startLeft, startTop); Console.Write(promptText); if (inputIndex == inputtingChars.Count) { for (int i = 0; i &lt; inputtingChars.Count; i++) { Console.Write(inputtingChars[i]); } currentLeft = Console.CursorLeft; currentTop = Console.CursorTop; } else { for (int i = 0; i &lt; inputtingChars.Count; i++) { if (inputIndex == i) { currentLeft = Console.CursorLeft; currentTop = Console.CursorTop; } Console.Write(inputtingChars[i]); } } tempEndLeft = Console.CursorLeft; tempEndTop = Console.CursorTop; while (Console.CursorTop &lt; endTop || Console.CursorLeft &lt; endLeft) { Console.Write(' '); } endLeft = tempEndLeft; endTop = tempEndTop; Console.SetCursorPosition(currentLeft, currentTop); Console.CursorVisible = cursorVisible; } } private void UpdateInputState() { inputtingChars = inputHistory[historyIndex]; inputIndex = inputtingChars.Count; } public void ClearDisplayBuffer() { lock(printting) { cursorVisible = Console.CursorVisible; Console.CursorVisible = false; Console.SetCursorPosition(startLeft, startTop); while (Console.CursorTop &lt; endTop || Console.CursorLeft &lt; endLeft) { Console.Write(' '); } Console.SetCursorPosition(startLeft, startTop); Console.CursorVisible = cursorVisible; } } public void DisplayTo(int cursorLeft, int cursorTop) { lock(printting) { cursorVisible = Console.CursorVisible; Console.CursorVisible = false; Console.SetCursorPosition(cursorLeft, cursorTop); startLeft = cursorLeft; startTop = cursorTop; Console.Write(promptText); if (inputIndex == inputtingChars.Count) { for (int i = 0; i &lt; inputtingChars.Count; i++) { Console.Write(inputtingChars[i]); } currentLeft = Console.CursorLeft; currentTop = Console.CursorTop; } else { for (int i = 0; i &lt; inputtingChars.Count; i++) { if (inputIndex == i) { currentLeft = Console.CursorLeft; currentTop = Console.CursorTop; } Console.Write(inputtingChars[i]); } } endLeft = Console.CursorLeft; endTop = Console.CursorTop; Console.CursorVisible = cursorVisible; } } public void SetInputStart(int cursorLeft, int cursorTop) { lock(printting) { cursorVisible = Console.CursorVisible; Console.CursorVisible = false; Console.SetCursorPosition(startLeft, startTop); while (Console.CursorTop &lt; endTop || Console.CursorLeft &lt; endLeft) { Console.Write(' '); } Console.SetCursorPosition(cursorLeft, cursorTop); startLeft = cursorLeft; startTop = cursorTop; Console.Write(promptText); if (inputIndex == inputtingChars.Count) { for (int i = 0; i &lt; inputtingChars.Count; i++) { Console.Write(inputtingChars[i]); } currentLeft = Console.CursorLeft; currentTop = Console.CursorTop; } else { for (int i = 0; i &lt; inputtingChars.Count; i++) { if (inputIndex == i) { currentLeft = Console.CursorLeft; currentTop = Console.CursorTop; } Console.Write(inputtingChars[i]); } } endLeft = Console.CursorLeft; endTop = Console.CursorTop; Console.CursorVisible = cursorVisible; } } public string ReadLine() { InitReadLine(); PrintInputString(); while (true) { readedKey = Console.ReadKey(true); if (PreviewCharInput != null &amp;&amp; PreviewCharInput.Invoke(this, readedKey)) { continue; } if (DealInputChar()) { inputting = false; return InputtingString; } PrintInputString(); if (CharInput != null &amp;&amp; CharInput.Invoke(this, readedKey)) { inputting = false; return InputtingString; } } } public string QuietReadLine() { InitReadLine(); PrintInputString(); while (true) { readedKey = Console.ReadKey(true); if (PreviewCharInput != null &amp;&amp; PreviewCharInput.Invoke(this, readedKey)) { continue; } if (DealInputChar()) { inputting = false; return InputtingString; } if (CharInput != null &amp;&amp; CharInput.Invoke(this, readedKey)) { inputting = false; return InputtingString; } } } } } 使用实例： 这是一个可以过滤输入的使用实例, 它仅允许用户输入数字, 并且支持使用WSAD按键控制已输入内容在控制台中的移动 using System; using Null.Library; namespace LibraryTest { class Program { static void Main(string[] args) { DynamicScanner scanner = new DynamicScanner(); scanner.PreviewCharInput += Scanner_PreviewCharInput; scanner.CharInput += Scanner_CharInput; while(true) { string temp = scanner.ReadLine(); } } private static bool Scanner_CharInput(DynamicScanner sender, ConsoleKeyInfo c) { Console.Title = $"Length: {sender.InputtingString.Length}, Inputed: {sender.InputtingString}"; return false; } private static bool Scanner_PreviewCharInput(DynamicScanner sender, ConsoleKeyInfo c) { if (c.KeyChar >= '0' &amp;&amp; c.KeyChar &lt;= '9' || DynamicScanner.IsControlKey(c.Key)) { return false; // 表示不取消, 即:录入这个字符 } else { switch (c.Key) // 通过WSAD按键可以控制输入内容移动 { case ConsoleKey.W: sender.SetInputStart(sender.StartLeft, sender.StartTop - 1); break; case ConsoleKey.S: sender.SetInputStart(sender.StartLeft, sender.StartTop + 1); break; case ConsoleKey.A: sender.SetInputStart(sender.StartLeft - 1, sender.StartTop); break; case ConsoleKey.D: sender.SetInputStart(sender.StartLeft + 1, sender.StartTop); break; } return true; } } } }</content></entry><entry><title>Linux BgRun</title><url>https://slimenull.top/post/linux-bgrun/</url><categories/><tags><tag>Linux</tag><tag>Ubuntu</tag><tag>经验</tag></tags><content type="html"> 使用 &amp; 连接符或者 nohup 指令
1. 使用 &lsquo;&amp;&rsquo; 符号 例如启动一个脚本，执行 &lsquo;./idea.sh&rsquo; 以启动idea，但终端会被阻塞，若终端被关闭，idea也就被关闭。 此时，执行 &lsquo;./idea.sh &amp;&rsquo; 可以使 idea 脱离当前终端运行，即便当前终端被关闭，idea也不会受影响。 ./idea.sh # 会阻塞当前终端进程 ./idea.sh &amp; # 不会阻塞 2. 使用 &rsquo;nohup&rsquo; 指令 参考 菜鸟教程 - nohup指令
参考文章：Linux后台执行命令(非阻塞式)</content></entry><entry><title>[Linux] Ubuntu 新手引导 - 中文输入法配置</title><url>https://slimenull.top/post/linux-ubuntu-zhinput/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>经验</tag></tags><content type="html"> 从输入法框架, 输入法引擎到输入法源的完全配置
选择输入法框架： Linux中，有多个输入法框架可供使用，在 Ubuntu 中，默认预装了 ibus 这款输入法引擎，常用的中文输入法引擎有两种，ibus 与 fcitx。两者都还彳亍，懒得下载的话，就直接用ibus吧。 配置使用的输入法框架：打开终端，执行 &lsquo;im-config&rsquo;，在弹出的窗口中，选择ok，yes，然后选择 ibus，于是，你就成功使用了ibus框架。同理，选择 fcitx 则是使用 fcitx 框架，至于安装 fcitx，见文章末。 选择输入法引擎： 关键的时刻到咯，那么对于ibus，常用的输入法有：rime，sunpinyin，googlepinyin(谷歌拼音)，我的话，推荐rime和sunpinyin。 对于fcitx嘛，常用的有sogoupinyin(搜狗拼音)，rime，sunpinyin，googlepinyin，搜狗的话，其实还是很棒的(没有广告，毕竟谁会往Linux系统软件中投放广告呢,,,)，然后rime和sunpinyin，也都蛮棒咯。 至于安装，见文章末。 添加输入法引擎： ibus的话，打开终端，执行 &lsquo;ibus-setup&rsquo;，然后在 &lsquo;Input method&rsquo; 选项卡中就可以添加了。（什么？不会操作？建议重修英文） fcitx的话，更简单了，打开 Ubuntu 应用列表(我指屏幕左下角的按钮)，搜索fcitx，打开fcitx configuration，然后，你懂得，添加输入法就好。实在不会，参考这篇文章吧 在Kali中配置中文输入法
最后一点，如果你在添加输入法引擎的时候，找不到自己安装的输入法，先确认自己的输入法框架是否选择正确了，也就是在 &lsquo;im-config&rsquo; 中查看，二就是尝试重启。 添加输入法源： 重启计算机以保证上面的更改生效，否则无法添加输入法源。 打开Settings（设置） 找到 Region &amp; Language (地区和语言)。 在 Input Source (输入源) 中点击 &lsquo;+&rsquo; 添加输入源，选择自己安装的输入法。它一般位于 Chinese (汉语) 组中，例如 &lsquo;Chinese (SunPinyin)&rsquo; 再次强调，如果你找不到，就尝试重启
享受打字： 如果你走的是 ibus 线，那么现在，你现在可以通过 Super + Space(空格) 来切换输入方式了。 如果你走的是 fcitx 线，则是通过 Ctrl + Space(空格) 来切换输入法，并且你可以在 fcitx configuration 中设置甚至添加更换输入法的快捷键。 在 Ubuntu 中， Super 键对应着 Windows 徽标键
安装输入法框架： 哦？不会安装了吗？让我来帮助你吧。 安装 ibus 使用 &lsquo;sudo apt install ibus&rsquo; 指令即可。 安装 fcitx 使用 &lsquo;sudo apt install fcitx&rsquo; 即可。 下载速度慢？ 如果不是网络问题的话，就尝试更换软件安装源吧。这个在网络上可以很容易的搜索到。个人建议 阿里云镜像 以及 华为云镜像。
安装输入法引擎： 其实这件事情也蛮简单的，因为 apt 可以搜索软件，通过 &lsquo;apt search ibus&rsquo; 就可以搜索到关于 ibus 的软件，其中不乏有许多 ibus 的输入法引擎 输入法引擎的命名方式很简单，就是 框架名-引擎名，例如 ibus-rime，直接 &lsquo;sudo apt install ibus-rime&rsquo; 即可安装适用于 ibus 的 rime 输入法。本文章提到的其他输入法引擎也是如此(只有sogoupinyin需要在SogouPinyin官网
下载) 其他小问题： 不知为何，Ubuntu中 ibus 有点问题，它无法设置为候选词水平显示，网络上也找不到解决方式，如果你介意这一点，那么就使用fcitx框架吧。</content></entry><entry><title>[经验] Windows 与 Linux 通用装机方法</title><url>https://slimenull.top/post/man-genericsysinstall/</url><categories/><tags><tag>经验</tag></tags><content type="html"> 不需要使用虚拟机的, 有一个空闲 U 盘就可以完成的通用装机方式. 准备安装介质, 从你喜欢的渠道下载ISO镜像, 将ISO写入到安装介质
准备安装介质 旧时的安装介质指光盘，但现在，一般的，安装介质都指U盘。你需要准备一个U盘，这个U盘的数据将被完全擦除然后写入安装程序，所以，推荐使用空闲U盘，并且空间大小推荐8G左右，不要小于4G，可以大于8G(只不过有些浪费空间就是了)
Windows10的镜像一般为4G左右，写入到U盘后大于4G Linux镜像一般较小，大多4G以下，但是Kali Linux的镜像要大于4G 这就是为什么推荐8G U盘
从你喜欢的渠道下载ISO镜像 如果你希望你安装的系统是干净的，那么，你需要使用正确的渠道来下载系统镜像。
安装 Windows 系统：
如果你有激活密钥或可以使用数字激活，建议你去 Next, I tell you
下载镜像，你需要登录(这不会花费太长时间)，它也是支持QQ登录的，当然，如果你不想注册账户，也可以去旧的网站 MSDN I tell you
， 但在旧的网站，你无法下载Windows10的最新版本 2004 如果你没有激活密钥, 你可以选择购买 Windows 激活码, 在 Microsoft 商城
或 京东
, 淘宝
等电子商城中可以购买到, 购买后, 按照上面的步骤, 下载 Windows 系统镜像. 或者你可以先进行上面的步骤, 在提到的网站中下载镜像, 然后试用 Windows. 如果你想要使用系统激活工具, 一定要知道, 这是不合法的, 并且激活工具常常伴随着病毒, 这些病毒很难被处理掉. 360或许可以搞定它们. 如果你想要使用盗版软件(不需要你为其支付费用), 请参阅文章尾 硬盘安装 安装 Linux 系统：
不用讲了，Linux 的大部分发行版都是免费且开源，直接在官方网站即可下载到。Ubuntu
， Debian
，Deepin
，Kali
，Arch
，CentOS
，Mint
，Red Hat
提示：I tell you网站内的ed2k是一个特殊的下载地址，可视作p2p下载链接，推荐使用迅雷
(别的软件可能对非技术人员不友好)
注意，大多数国内流行的ISO或GHO镜像下载网站都是包含捆绑软件的非官方原装系统！如果你要使用纯净系统，切记要仔细选择！
将ISO写入到介质 写入到介质可不单单是将ISO作为压缩包打开并内容拷贝到U盘，这样是错误的操作！但是不必担心，同样，它也不是什么复杂的操作
在 Windows 系统中，你需要一个小工具来制作安装介质，它就是Rufus
！， 一个仅有不到5MB的小工具，并且能够自动帮你检测可能缺失的内容！Rufus
的使用也非常简便，只需要选择设备，选择ISO镜像，点击开始即可(我是指, 其他配置内容默认不需要更改)。进入Rufus官网
，下载Rufus 3.13便携版
在Linux中，我们只需要借助一个‘dd’指令即可将ISO镜像写入到U盘，用法是：
dd if=‘输入文件’ of=‘输出设备’ # 使用lsblk指令可以查看自己当前的接入的存储设备 # dd指令示例使用示例： dd if='/home/username/ubuntu20.04lts.iso' of='/dev/sda' 在这里不得不提到一个问题，就是在 Linux 中使用 dd 指令写入 Windows 镜像到U盘，会出现无法安装的问题，但是使用 Rufus 写入就没问题。（可能是格式问题）
示例图像 简介 Rufus 的界面非常简洁, 仅有必要的选项，无任何附加功能，无论小白还是大神，都很适合使用 这是Ubuntu系统中，dd指令的帮助手册，不过对于只需要将ISO写入到U盘的我们，不需要看那么多内容，只需要知道if和of参数即可 开始安装 待写入完毕，安装准备已经完全就绪了！那么，下一步就是安装步骤了！
关闭计算机
插入准备好的安装介质，启动计算机
从U盘启动（有两种方式）：
第一种：按下 选择引导 的按键，它可能是 F12，但不同主板有不同的按键，Dell电脑的按键即是 F12。 第二种：按下进入 启动配置 的按键 ，在 启动配置 中调整引导顺序至USB设备最顶级，重启电脑即可进入安装界面 若有疑问，可参阅这篇文章： 进入BIOS/UEFI配置页面
成功从U盘启动后，就已经进入到系统安装界面了。接下来，按照安装程序的提示进行即可。一般的，Linux系统的可定制性要比Windows高很多，而Windows的安装就简单了很多。
享受新系统！
硬盘安装： 某些ISO镜像，例如国内较为流行的镜像下载网站提供的ISO，将其中的内容直接解压到某处，启动 setup.exe 即可安装，这种安装方式被称为 硬盘安装 ，并且一般的，这种安装方式都是一键傻瓜式安装，中途完全不需要用户进行任何干涉。 下面列举一些国内的非官方镜像下载源： 深度技术
， 雨林木风
，萝卜家园
，电脑公司
，系统之家
，番茄花园
注意，你几乎无法在国内流行镜像下载站获取原版镜像！这些都是包含捆绑的非原版镜像！并且极有可能侵犯了微软(Microsoft)的版权，在使用之前，慎重考虑！
在下载到支持硬盘安装的ISO镜像后，使用任意压缩包管理软件(例如7zip
)打开，解压其中的内容到任意文件夹，但要求不可以在你要安装系统的分区，例如你要将系统安装到C盘，那就不可以将ISO文件解压到C盘。 解压后，双击 setup.exe 按照自己的需要配置一下，如果看不懂，就直接点下一步，然后傻瓜式系统安装就开始了，解压来你需要做的就是等待安装了（喝杯Java提提神？ 安装完成后，享受新系统吧！（记得将所有捆绑的东西全部卸载</content></entry><entry><title>[经验] 如何进入启动配置 (BIOS/UEFI配置)</title><url>https://slimenull.top/post/man-entersetup/</url><categories/><tags><tag>计算机基础</tag><tag>笔记</tag></tags><content type="html"> 一般可以用小键盘上的 del 键, 或者 F2, F12
电脑启动时，需要读取最基本的配置，然后才进入系统，这个配置就是 启动配置 。旧时的启动配置即BIOS配置，但如今UEFI即将取代BIOS配置，我们应该使用 启动配置 这个名称，否则就可能闹出将UEFI称为BIOS的尴尬场面。 这个启动配置，是可以被我们调整的，在启动配置页面，我们可以调整风扇转速，系统时间，设备电压，以及其他更高深的东西，不过最常用的，还是引导优先级。因为一个电脑，可以有多个操作系统，引导优先级则是控制启动系统的配置项。 不同的主板，是有不同的进入按键的，例如Dell电脑，是 F2 进入启动配置。 那么， 下一步就是在网上查找你的设备对应的按键了, 搜索近似于 ‘设备名 BIOS/UEFI 按键’ 的内容以尝试检索出你所需要的按键。下面的步骤以 F2 作为示例。
按下开机键后，狂按 F2 , 直到进入配置页面。（它可能是纯英文界面 如果是国内主板，或者说支持多语言的配置页，你可以尝试找下 ‘Language’ 配置以调整显示语言 启动时，还有一些其他的按键，例如 Windows启动高级选项 的按键是 F8 ，Dell电脑的引导选择的快捷键是 F12 , 如果你只是希望在本次进入系统时从其他设备进入，使用 F12 更简便些。当然，即便是这个，在不同主板中也是不同的，例如我那个台式机就是 F11 。
对于想要通过介质安装系统的朋友呢，在开机时狂按 F12 进入引导选择页面，选择带有USB字样的选项并按 Enter 即可进入安装程序。</content></entry><entry><title>[Linux] Kali Linux 新手引导 - Xfce 桌面时间配置</title><url>https://slimenull.top/post/linux-xfcedesktoptime/</url><categories/><tags><tag>Linux</tag><tag>Kali</tag><tag>笔记</tag></tags><content type="html"> 直接在桌面的时间那里右键, 属性, 然后输入时区, 就能够生效
我的 Kali 操作系统：Linux NullKali 5.9.0-kali2-amd64 #1 SMP Debian 5.9.6-1kali1 (2020-11-11) x86_64 GNU/Linux 桌面环境：Xfce Desktop Environment Version 4.14, destributed by Debian
打开时间配置： 位于固定&rsquo;任务栏&rsquo;的右侧， 右击时间，选择Properties(属性) 进行调整： 亦见： Kali Linux 新手引导 - 区域与语言配置</content></entry><entry><title>[Linux] Kali Linux 记录 - 死锁, 依赖 'Unable to install new version of ...libpng12.so.0 no such file or directory'</title><url>https://slimenull.top/post/linux-deadlockunableinstallxxx/</url><categories/><tags><tag>Linux</tag><tag>Kali</tag><tag>踩坑记录</tag></tags><content type="html"> 既然无法通过 apt 来移除软件包, 那就用 dpkg 移除吧!
概述: 在使用apt或dpkg安装deb包时， 出现了no such file or directory的错误 要点: 在dpkg时是否指定了错误的路径 包对于系统来说是否过旧 我的解决过程: 我遇到的问题属于要点中的后者， libpng12对于我的系统来说太旧了。
具体情况是这样的， 我在使用apt安装一些软件时， 发现， 一直报依赖问题， 让我执行‘apt &ndash;fix-broken install’(即‘apt -f install’)， 但当我执行时， 它尝试安装的libpng12-0始终装不上(都快把孩子急哭了qaq)！ 从报错信息上看， libpng12-0似乎是libpng12.so.0的新版本， 在安装时总是提示no such file or directory。
首先， 我在网上搜索了一波， 但是依照国内IT圈子转载满天飞的尿性， 我还是以失败告终 —— 找了几十篇文章也没看到有用的
后来我发现， 如果我不处理这个错误， 我不能进行任何apt install， upgrade， remove操作！ 我慌了， 于是我尝试执行apt remove libpng12.so.0， 但是提示它被libwebkitgtk什么的一个我不认识的东西包所依赖， 然后， 不能移除。。。
然后我又尝试移除这个依赖于libpng的libwebkitgtk的什么包， 然后我发现它又被sunloginclient(应该是向日葵远程控制软件客户端)所依赖，，， 移除失败，，，
于是我尝试移除sunloginclient这个包（反正我目前不大用得到向日葵）， 但是，，，正如我前面所说的， 虽然sunloginclient不被什么包所依赖， 但是因为我们libpng12-0的依赖问题没解决， 所以，，， 移除失败。。。
于是， 我似乎陷入了一个逻辑问题， 想要处理这个依赖问题， 我就得移除掉旧的libpng12.so.0， 想要移除它我就得移除sunloginclient然后最后移除它， 而只有我处理完依赖问题后， 才能够使用apt来进行安装与移除操作！
查资料, 查资料, 查资料, 经过一段时间的周旋, 我顿悟了, 既然不能用 apt, 就用 dkpg 啊, 很快啊， 我打开终端， 用 dpkg 把 sunloginclient 给移除了， 然后顺理成章的把libwebkitgtk， libpng12.so.0给移除了
完美解决</content></entry><entry><title>[Linux] Kali Linux 新手引导 - 配置中文输入法</title><url>https://slimenull.top/post/linux-kali-zhinput/</url><categories/><tags><tag>Linux</tag><tag>Kali</tag><tag>笔记</tag></tags><content type="html"> 安装基于 fcitx 的搜狗输入法 Linux 版
我的 Kali 操作系统：Linux NullKali 5.9.0-kali2-amd64 #1 SMP Debian 5.9.6-1kali1 (2020-11-11) x86_64 GNU/Linux 桌面环境：Xfce Desktop Environment Version 4.14, destributed by Debian
安装输入法框架Fcitx sudo apt install fcitx # 这里推荐的是Fcitx， kali默认是装了fcitx的， 如果没有安装， 就执行上边的指令安装吧 安装好用的输入法 访问 ‘搜狗输入法 for Linux’ 官网并下载deb包。点此处跳转
sudo dpkg -i sogoupinyin_版本号_amd64.deb # 若出现依赖问题， 则执行指令以尝试修复: sudo apt -f install 配置输入法 启动 Fcitx Configuration ， 点击左下角加号以添加输入法， 取消勾选‘Only Show Current Language’， 找到sogoupinyiin （没错， 不是sougou而是sogou） 现在， 一切就绪， 你可以使用输入法了。 默认的输入法切换快捷键是 ‘Ctrl + Space’ ， 可在Fcitx Configuration的Global Config中调整。切换至‘搜狗拼音’时， 在屏幕上会出现在搜狗拼音的语言栏， 如下： 此时， 你可以正常使用输入法。若有其他问题， 可继续阅读下面的内容。 下图即配置好的Fcitx 玄学问题： Fcitx Configuration 启动后， 窗口中没有任何内容（正常情况下应该有一个Keyboard - 语言）
: 尝试重启， 重新安装Fcitx， 更换区域与语言(参阅：Kali Linux 新手引导 - 区域与语言配置
)
在Fcitx Configuration 中添加输入法时， 无法找到sogoupinyin : 检查输入法是否正确安装了， 尝试执行apt update， apt upgrade， apt -f install</content></entry><entry><title>[Linux] Kali Linux 新手引导 - 区域与语言配置</title><url>https://slimenull.top/post/linux-kali-regionandlang/</url><categories/><tags><tag>Linux</tag><tag>Kali</tag><tag>笔记</tag></tags><content type="html"> 使用 tzselect 配置时区, 使用 sudo dpkg-reconfigure locales 配置语言
我的 Kali 操作系统：Linux NullKali 5.9.0-kali2-amd64 #1 SMP Debian 5.9.6-1kali1 (2020-11-11) x86_64 GNU/Linux 桌面环境：Xfce Desktop Environment Version 4.14, destributed by Debian
配置区域 tzselect # 在Shell中执行即可，tzselect = time zone select 配置语言 sudo dpkg-reconfigure locales # 配置完后记得重启(reboot) # 这条指令的意思应该是调整语言并安装相关包 # 配置完语言后，在登录页面的右上角可以快捷切换语言</content></entry><entry><title>[Win32] Windows APi 函数后缀 (A, W, ExA, ExW) 的含义</title><url>https://slimenull.top/post/win32-functionexname/</url><categories/><tags><tag>C++</tag><tag>Win32</tag><tag>笔记</tag></tags><content type="html"> A = ANSI, W = WideChar, Ex = Extended, ExA = Extended ANSI, ExW = Extended WideChar
A 表示使用 ANSI 编码作为标准输入与输出流的文本编码 W 表示使用 Unicode 作为编码 Ex 表示拓展, 标注了 Ex 的 WinAPI 函数会比没有标 Ex 的函数多一些参数什么的, 可以说拓展了一些功能 ExA 与 ExW 就是 A, W 与 Ex 的结合了</content></entry><entry><title>[C#] 使用 GDI+ 在控制台绘图</title><url>https://slimenull.top/post/csharp-consolegdi/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag></tags><content type="html"> 直接通过 WinAPI 获取控制台窗口句柄, 然后创建 Graphics 对象, 就可以肆无忌惮的画图了
获取控制台的窗口句柄
[DllImport("kernel32.dll")] static extern IntPtr GetConsoleWindow(); 获取Graphics对象
Graphics g = Graphics.FromHwnd(GetConsoleWindow()); 于是乎, 你就可以通过获取的Graphics对象随便进行绘图了!
但是, 注意, 当控制条刷新的时候, 比如Console.Clear(), 或者控制台光标经过绘图区域, 绘制的内容就会失效, 这时你需要重新绘制. (如果有控制台刷新的事件就好了)</content></entry><entry><title>[C#] 运算包含数学表达式的字符串</title><url>https://slimenull.top/post/csharp-mathexprcalc/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>算法</tag><tag>轮子</tag></tags><content type="html"> 这是一个手写的算法，用于计算字符串中包含的数学表达式, 其原理是通过解析字符串中的 token, 分析表达式, 并计算结果.
概述 实例代码适用于: .NET Framework &amp; .NET Core 算法通用. 只要你能够找到与算法对应的实现方式.
完整源代码: Github仓库
最新版本已经使用了逆波兰表达式
实现的功能 分析表达式 实现所有的通用运算符 实现三元运算符 支持嵌套的括号 原理: 使用"状态机"算法分析表达式 根据运算符优先级, 不断尝试运算, 最终得到结果 详解: 第一步, 我们需要将运算表达式分成一个个节点(token), 这个节点可能是一个数字, 可能是一个运算符, 至于表达式里的括号, 我们会使用递归来进行运算. 我们使用下面的class来表示这个token.
enum CalcTokenType { // 规定枚举所对应的int为2的倍数是为了后面方便识别 None = 0, Number = 1, Operator = 2 } enum CalcOperator { None, Add = 1, // + Sub = 2, // - Mul = 4, // * Div = 8, // / Mod = 16, // % Pow = 32, // ** Lss = 64, // &lt; Gtr = 128, // > Leq = 256, // &lt;= Geq = 512, // >= Equ = 1024, // = Neq = 2048, // != Not = 4096, // ! And = 8192, // &amp; Or = 16384, // | If = 32768, // 三元表达式中的 '?' 符号 Witch = 65536 // 三元表达式中的 ':' 符号 } class CalcToken { public CalcToken(CalcTokenType type, object content) { this.Type = type; this.Content = content; } CalcTokenType Type; object Content; // Content, 当Type是None时, 值应该是null // 当Type是Number时, 值应该是double // 当Type是Operator时, 值应该是CalcOperator枚举变量 } 继续, 那么, 先是如何分析一个简单的表达式, 例如下面的:
11+1
分析这个表达式, 我们首先定义一些字符串常量, 如下:
char[] OperatorChars = "+-*/&lt;>!=&amp;|?:".ToArray(); // 表示操作符的字符 char[] NumberChars = "0123456789.".ToArray(); // 表示数字的字符 char[] EmptyChars = " \t".ToArray(); // 表示空字符 我们将逐字符对其分析(有限状态机): 使用List&lt;CalcToken> tokens来保存分析出的token
当开始时, 我们取到一个字符'1&rsquo;, 现在我们还不是在分析任何类型, 但是经过定义的字符集常量的Contains判断, 我们发现它是属于数字的, 那么我们知道, 现在我们正在分析数字. 存储下来这个字符'1&rsquo;, 用什么, 你应该知道吧? 要么是List, 要么是StringBuilder. 并且, 记录下我们现在的状态, 我们分析到了数字 到分析到第二个数字时, 我们当前的状态是正在分析数字, 那么在这个状态下, 如果我们又取到一个数字, 那么我们需要存储下这个数字, 并且当前状态不变, 如果我们取到一个操作符字符, 那么代表现在这个数字结束了, 使用double.Parse将已保存的字符串(一个或多个由数字字符组成的), 转换为double类型, 然后存储下这个token, 并且清空存储的字符, 将当前取到的字符存进去, 然后改变当前状态到"正在分析操作符". 我们的表达式是"11+1", 第二个字符是一个数字字符, 也就是说, 我们应存下这个字符, 且状态不变. 于是, 我们已经存储下了两个字符{&lsquo;1&rsquo;, &lsquo;1&rsquo;}, 当前状态是数字 到第三个字符了, 我们发现它不是一个数字字符, 而是一个操作符字符, 于是, 将已保存的字符串转换为double, 并添加到tokens, 当前状态是:正在分析操作符 到第四个字符, 它又不是一个操作符字符了, 它现在是一个数字, 所以, 将已存储的操作符字符保存 到最后, 分析结束, 但临时存储的部分还有一个字符'1&rsquo;, 将其转换为double, 然后存储到tokens, 于是, 我们成功完成了对表达式的分词, 至此, 基本原理已经讲清, 尝试理解下面的函数 // 下面是分词核心, 这里面包含对括号的分析 // bool inner表示这个函数是否是被另一个分词函数调用的, 也就是说是否在递归状态, 如果是, 则表示在分析一个括号内的表达式, 碰到')'的时候立即return; bool TryParseCalcTokens(ref char[] source, ref int offset, out List&lt;CalcToken> result, bool inner = false, int level = 0) { result = new List&lt;CalcToken>(); for (; offset &lt; source.Length; offset++) { if (EmptyChars.Contains(source[offset])) { continue; } else if (source[offset] == '(') { offset++; if (TryParseCalcTokens(ref source, ref offset, out List&lt;CalcToken> newrst, true, level + 1)) { result.Add(new CalcToken(CalcTokenType.Expression, newrst)); } else { errors.Add($"Error when parsing inner expression. Level:{level};"); return false; } } else if (source[offset] == ')') { return true; } else { if (TryParseToken(ref source, ref offset, out CalcToken newcctk)) { result.Add(newcctk); // 这里是将分析好的token添加到tokens } else { errors.Add($"Error when parsing expression token. Level:{level};"); return false; } } } return true; } 开始运算表达式: (最简单的方法)
遍历我们的tokens, 第一次遍历, 查找优先级最高的操作符并运算结果, 第二次遍历查找优先级略次的操作符并运算结果, 如此往复, 查找完所有的表达式
// 下面是运算核心 bool TryCalculateTokens(ref List&lt;CalcToken> source, out double result, out List&lt;string> errors) { errors = new List&lt;string>(); result = 0; for (int i = 0; i &lt; source.Count; i++) { if (source[i].Type == CalcTokenType.Operator &amp;&amp; CheckOperator(CalcOperator.Mul | CalcOperator.Div | CalcOperator.Mod | CalcOperator.Pow, (CalcOperator)source[i].Content) &amp;&amp; CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, -1) &amp;&amp; CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, 1)) { if (TryGetTokenValue(ref errors, source[i - 1], out double leftnum) &amp;&amp; TryGetTokenValue(ref errors, source[i + 1], out double rightnum)) { double tmpnum = 0; switch ((CalcOperator)source[i].Content) { case CalcOperator.Mul: tmpnum = leftnum * rightnum; break; case CalcOperator.Div: tmpnum = leftnum / rightnum; break; case CalcOperator.Mod: tmpnum = leftnum % rightnum; break; case CalcOperator.Pow: tmpnum = Math.Pow(leftnum, rightnum); break; default: throw new Exception(); } source[i - 1] = new CalcToken(CalcTokenType.Number, tmpnum); source.RemoveRange(i, 2); i--; } else { errors.Add($"Cannot get the value of token when calculate '{source[i].Content}';"); return false; } } } // * / % ** for (int i = 0; i &lt; source.Count; i++) { if (source[i].Type == CalcTokenType.Operator &amp;&amp; CheckOperator(CalcOperator.Add | CalcOperator.Sub, (CalcOperator)source[i].Content) &amp;&amp; CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, 1)) { if (CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, -1)) { if (TryGetTokenValue(ref errors, source[i - 1], out double leftnum) &amp;&amp; TryGetTokenValue(ref errors, source[i + 1], out double rightnum)) { double tmpnum = 0; switch ((CalcOperator)source[i].Content) { case CalcOperator.Add: tmpnum = leftnum + rightnum; break; case CalcOperator.Sub: tmpnum = leftnum - rightnum; break; default: throw new Exception(); } source[i - 1] = new CalcToken(CalcTokenType.Number, tmpnum); source.RemoveRange(i, 2); i--; } else { errors.Add($"Cannot get the value of token when calculate '{source[i].Content}';"); return false; } } else { if (TryGetTokenValue(ref errors, source[i + 1], out double rightnum)) { double tmpnum = 0; switch ((CalcOperator)source[i].Content) { case CalcOperator.Add: tmpnum = rightnum; break; case CalcOperator.Sub: tmpnum = 0 - rightnum; break; default: throw new Exception(); } source[i] = new CalcToken(CalcTokenType.Number, tmpnum); source.RemoveRange(i + 1, 1); } else { errors.Add($"Cannot get the value of token when calculate '{source[i].Content}';"); return false; } } } } // + - for (int i = 0; i &lt; source.Count; i++) { if (source[i].Type == CalcTokenType.Operator &amp;&amp; CheckOperator(CalcOperator.Gtr | CalcOperator.Lss | CalcOperator.Geq | CalcOperator.Leq, (CalcOperator)source[i].Content) &amp;&amp; CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, -1) &amp;&amp; CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, 1)) { if (TryGetTokenValue(ref errors, source[i - 1], out double leftnum) &amp;&amp; TryGetTokenValue(ref errors, source[i + 1], out double rightnum)) { double tmpnum = 0; switch ((CalcOperator)source[i].Content) { case CalcOperator.Gtr: tmpnum = leftnum > rightnum ? 1 : 0; break; case CalcOperator.Lss: tmpnum = leftnum &lt; rightnum ? 1 : 0; break; case CalcOperator.Geq: tmpnum = leftnum >= rightnum ? 1 : 0; break; case CalcOperator.Leq: tmpnum = leftnum &lt;= rightnum ? 1 : 0; break; default: throw new Exception(); } source[i - 1] = new CalcToken(CalcTokenType.Number, tmpnum); source.RemoveRange(i, 2); i--; } else { errors.Add($"Cannot get the value of token when calculate '{source[i].Content}';"); return false; } } } // > &lt; >= &lt;= for (int i = 0; i &lt; source.Count; i++) { if (source[i].Type == CalcTokenType.Operator &amp;&amp; CheckOperator(CalcOperator.Equ | CalcOperator.Neq, (CalcOperator)source[i].Content) &amp;&amp; CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, -1) &amp;&amp; CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, 1)) { if (TryGetTokenValue(ref errors, source[i - 1], out double leftnum) &amp;&amp; TryGetTokenValue(ref errors, source[i + 1], out double rightnum)) { double tmpnum = 0; switch ((CalcOperator)source[i].Content) { case CalcOperator.Equ: tmpnum = leftnum == rightnum ? 1 : 0; break; case CalcOperator.Neq: tmpnum = leftnum != rightnum ? 1 : 0; break; default: throw new Exception(); } source[i - 1] = new CalcToken(CalcTokenType.Number, tmpnum); source.RemoveRange(i, 2); i--; } else { errors.Add($"Cannot get the value of token when calculate '{source[i].Content}';"); return false; } } } // == != for (int i = 0; i &lt; source.Count; i++) { if (source[i].Type == CalcTokenType.Operator &amp;&amp; CheckOperator(CalcOperator.Add | CalcOperator.Or, (CalcOperator)source[i].Content) &amp;&amp; CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, -1) &amp;&amp; CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, 1)) { if (TryGetTokenValue(ref errors, source[i - 1], out double leftnum) &amp;&amp; TryGetTokenValue(ref errors, source[i + 1], out double rightnum)) { double tmpnum = 0; switch ((CalcOperator)source[i].Content) { case CalcOperator.Add: tmpnum = leftnum != 0 &amp;&amp; rightnum != 0 ? 1 : 0; break; case CalcOperator.Or: tmpnum = leftnum != 0 || rightnum != 0 ? 1 : 0; break; default: throw new Exception(); } source[i - 1] = new CalcToken(CalcTokenType.Number, tmpnum); source.RemoveRange(i, 2); i--; } else { errors.Add($"Cannot get the value of token when calculate '{source[i].Content}';"); return false; } } } // &amp; | for (int i = 0; i &lt; source.Count; i++) { if (source[i].Type == CalcTokenType.Operator &amp;&amp; CheckOperator(CalcOperator.If, (CalcOperator)source[i].Content) &amp;&amp; CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, -1) &amp;&amp; CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, 1) &amp;&amp; CheckType(ref source, CalcTokenType.Operator, i, 2) &amp;&amp; CheckType(ref source, CalcTokenType.Number | CalcTokenType.Expression, i, 3) &amp;&amp; CheckOperator(CalcOperator.Witch, (CalcOperator)source[i + 2].Content)) { if (TryGetTokenValue(ref errors, source[i - 1], out double basic)) { double tmpnum = 0; if (basic != 0) { if (TryGetTokenValue(ref errors, source[i + 1], out double leftnum)) { tmpnum = leftnum; } else { errors.Add($"Cannot get the value of token when calculate '{source[i].Content}';"); return false; } } else { if (TryGetTokenValue(ref errors, source[i + 3], out double rightnum)) { tmpnum = rightnum; } else { errors.Add($"Cannot get the value of token when calculate '{source[i].Content}';"); return false; } } source[i - 1] = new CalcToken(CalcTokenType.Number, tmpnum); source.RemoveRange(i, 4); i--; } else { errors.Add($"Cannot get the value of token when calculate '{source[i].Content}';"); return false; } } } // 三元表达式 if (source.Count == 1 &amp;&amp; source[0].Type == CalcTokenType.Number) { result = (double)source[0].Content; return true; } else { errors.Add($"Final result after calculate is not a single number. '{string.Join(" ", source)}';"); return false; } }</content></entry><entry><title>[C#] 使用 CHO.Json 操作 Json 数据</title><url>https://slimenull.top/post/csharp-chojson/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>算法</tag><tag>轮子</tag><tag>旧的</tag></tags><content type="html"> (旧的) CHO.Json 是我所写的 JSON 解析器, 你可以使用它操作 JSON 数据, 包括序列化, 反序列化.
2022/3/26 备注: 尽管这个库速度很快, 但是它已经是很久之前写的了, 我已经重写了一个新的(EleCho.Json
), 逻辑更加清晰, 所以这个文章所提及的库, 只供参考. 新文章: EleCho.Json
CHO.Json： 现在，CHO.Json已经成为了一个强大的Json解析库，速度很快。 支持弱类型操作, JsonData实现了所有Json数据类型的基本操作, 支持像 Python 那样的操作方式 支持强类型操作, JsonData可以直接通过 ‘Get类型’ 方法来获取对应数据类型数据并进行操作 支持序列化， 反序列化， 一次分析多个Json数据： 序列化和反序列化则是所有库都有的功能 一次性序列化多个Json数据则是，允许一段文本中含有多个Json根数据，它可以用于解决TCP套接字的粘包问题 CHO.Json 拥有教快的分析速度，能够完全与Json.Net与Text.Json匹敌，并且它的加载速度时三者中最快的。 这是它与Newtonsoft.Json的差别:
CHO.Json少了许多冗余的功能, 例如将图片序列化为字符串, 因此CHO.Json可能要比Newtonsoft.Json轻量许多。 CHO.Json的源代码比Newtonsoft.Json更适合初学者阅读, 在看懂它的代码后, 你会了解到有限状态机以及反射 CHO.Json仅使用一个C#源文件, 这是因为它的源代码仅有1.5k行左右, 这其中还包含类型转换等片段 更详细的介绍：
首先， 在 CHO.Json 中, 包含一个 JsonData 类, 它可以用来表示任何 Json 数据, 通过 JsonData 类的静态方法, 可以从字符串或字符数组中分析出 Json 数据并存储到 JsonData 实例中, 或者将 JsonData 实例转化为 Json 字符串. JsonData 是你最常用的类, 有一个 DataType 属性指定了这个实例所表示的 Json 数据类型, 例如String, Boolean, Integer, 通过 &lsquo;Get类型&rsquo; 方法可以直接获取对应数据, 例如: GetString() 方法返回这个Json实例中所包含的字符串信息. 但如果你对一个包含了非字符串信息的 JsonData 实例使用这个方法, 则会抛出异常. 在最新版本的 CHO.Json 中, Serializie(序列化)和Deserialize(反序列化)用于直接转换字符串和指定的数据. 但在旧版, 则是转换 JsonData. 新版中, 推荐的方法是使用 JsonData 的静态方法: Parse, Create, ConvertToInstance, ConvertToText. 如果一个字符串里包含多个Json数据, 但并没有分隔符, 例如在TCP套接字中传输的多个Json文本, 你可以通过JsonData的静态方法 ParseStream 来分析它们. JsonData 的 Content 属性是 JsonData 包含的数据原型, 如果是Array, 则它的类型是List&lt;JsonData>, 如果是Object, 则它的类型是 Dictionary&lt;JsonData, JsonData> 下面是使用CHO.Json的例子: 项目完整源代码: Github仓库</content></entry><entry><title>[C#] 计算字符串在控制台上显示的宽度, 包含所有Char能表示的字符</title><url>https://slimenull.top/post/csharp-getcharwidthinconsole/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag><tag>轮子</tag></tags><content type="html"> 通过运算, 获取字符串在控制台上显示的宽度, 例如中文字符宽2, 英文字符宽1
在网上找了半天, 唯一一个正儿八经的, 就是通过GBK编码的字节数来推测所占宽度, 但我认为这个有点不大妥当, 例如某些特殊字符, 可能就不被GBK编码包含. 所以, 我这里提供了一个可获取字符串显示宽度的可行方法. Github 仓库地址: Null.ConsoleEx
关于刚刚所说根据 GBK 编码的字节数来推测宽度
int len = Encoding.GetEncoding(&ldquo;GBK&rdquo;).GetByteCount(str);
关于使用: 在 nuget 包管理器安装 NullLib.ConsoleEx (推荐)
直接去 Clone 开头所写明的代码仓库即可, 会不定时更新的.或者, 直接复制上面的代码(最长的那一段).
下面的代码大部分是自动生成的哦~关于图中使用到的Null.TextEditor, 在这里:
CSDN 站内链接: 使用IronPython来创建支持脚本编辑文本内容的文本编辑器
Github 仓库地址: SlimeNull/Null.TextEditor
实现过程: 首先, 我通过循环C#中所有的字符, 并将其打印到控制台上, 运算单个字符所占宽度, 最终得出了一个List&lt;int>, 通过这个列表, 只需要以字符强制转换为int的值作为索引, 访问对应的元素, 即可得出字符对应宽度 int GetCharLen(char c) { Console.CursorLeft = Console.BufferWidth / 2 - 1; int start = Console.CursorLeft; Console.Write(c); return Console.CursorLeft - start; } 之后, 再获取区间, 稍加处理, 即得到可获取char所有字符在控制台中显示的宽度. using System; using System.Collections; using System.Collections.Generic; namespace NullLib.ConsoleEx { public static class ConsoleText { private struct CharLenSeg : IComparable&lt;CharLenSeg> { public int Start; public int End; public int Length; public CharLenSeg(int start, int end, int length) { Start = start; End = end; Length = length; } public int InRange(int c) { if (c &lt; Start) return c - Start; else if (c >= End) return End - c + 1; else return 0; } public int CompareTo(CharLenSeg other) { return Start.CompareTo(other.Start); } } private class CharLenSegs : IReadOnlyList&lt;CharLenSeg> { CharLenSeg[] collection; public CharLenSegs(CharLenSeg[] collection) { this.collection = collection; Array.Sort(collection); } public CharLenSeg this[int index] => collection[index]; public int Count => collection.Length; public CharLenSeg BinarySearch(char c) { int cIndex = c; int low = 0, high = Count, middle; while (low &lt;= high) { middle = (low + high) / 2; CharLenSeg curSeg = this[middle]; if (cIndex &lt; curSeg.Start) { high = middle - 1; } else if (cIndex &lt; curSeg.End) { return curSeg; } else { low = middle + 1; } } return default; } public IEnumerator&lt;CharLenSeg> GetEnumerator() { foreach (CharLenSeg each in collection) yield return each; } IEnumerator IEnumerable.GetEnumerator() { return collection.GetEnumerator(); } } private static readonly CharLenSegs AllCharLenSegs = new CharLenSegs( new CharLenSeg[] { new CharLenSeg(0, 7, 1), new CharLenSeg(7, 9, 0), new CharLenSeg(9, 10, 8), new CharLenSeg(10, 11, 0), new CharLenSeg(11, 13, 1), new CharLenSeg(13, 14, 0), new CharLenSeg(14, 162, 1), new CharLenSeg(162, 166, 2), new CharLenSeg(166, 167, 1), new CharLenSeg(167, 169, 2), new CharLenSeg(169, 175, 1), new CharLenSeg(175, 178, 2), new CharLenSeg(178, 180, 1), new CharLenSeg(180, 182, 2), new CharLenSeg(182, 183, 1), new CharLenSeg(183, 184, 2), new CharLenSeg(184, 215, 1), new CharLenSeg(215, 216, 2), new CharLenSeg(216, 247, 1), new CharLenSeg(247, 248, 2), new CharLenSeg(248, 449, 1), new CharLenSeg(449, 450, 2), new CharLenSeg(450, 711, 1), new CharLenSeg(711, 712, 2), new CharLenSeg(712, 713, 1), new CharLenSeg(713, 716, 2), new CharLenSeg(716, 729, 1), new CharLenSeg(729, 730, 2), new CharLenSeg(730, 913, 1), new CharLenSeg(913, 930, 2), new CharLenSeg(930, 931, 1), new CharLenSeg(931, 938, 2), new CharLenSeg(938, 945, 1), new CharLenSeg(945, 962, 2), new CharLenSeg(962, 963, 1), new CharLenSeg(963, 970, 2), new CharLenSeg(970, 1025, 1), new CharLenSeg(1025, 1026, 2), new CharLenSeg(1026, 1040, 1), new CharLenSeg(1040, 1104, 2), new CharLenSeg(1104, 1105, 1), new CharLenSeg(1105, 1106, 2), new CharLenSeg(1106, 8208, 1), new CharLenSeg(8208, 8209, 2), new CharLenSeg(8209, 8211, 1), new CharLenSeg(8211, 8215, 2), new CharLenSeg(8215, 8216, 1), new CharLenSeg(8216, 8218, 2), new CharLenSeg(8218, 8220, 1), new CharLenSeg(8220, 8222, 2), new CharLenSeg(8222, 8229, 1), new CharLenSeg(8229, 8231, 2), new CharLenSeg(8231, 8240, 1), new CharLenSeg(8240, 8241, 2), new CharLenSeg(8241, 8242, 1), new CharLenSeg(8242, 8244, 2), new CharLenSeg(8244, 8245, 1), new CharLenSeg(8245, 8246, 2), new CharLenSeg(8246, 8251, 1), new CharLenSeg(8251, 8252, 2), new CharLenSeg(8252, 8254, 1), new CharLenSeg(8254, 8255, 2), new CharLenSeg(8255, 8364, 1), new CharLenSeg(8364, 8365, 2), new CharLenSeg(8365, 8451, 1), new CharLenSeg(8451, 8452, 2), new CharLenSeg(8452, 8453, 1), new CharLenSeg(8453, 8454, 2), new CharLenSeg(8454, 8457, 1), new CharLenSeg(8457, 8458, 2), new CharLenSeg(8458, 8470, 1), new CharLenSeg(8470, 8471, 2), new CharLenSeg(8471, 8481, 1), new CharLenSeg(8481, 8482, 2), new CharLenSeg(8482, 8544, 1), new CharLenSeg(8544, 8556, 2), new CharLenSeg(8556, 8560, 1), new CharLenSeg(8560, 8570, 2), new CharLenSeg(8570, 8592, 1), new CharLenSeg(8592, 8596, 2), new CharLenSeg(8596, 8598, 1), new CharLenSeg(8598, 8602, 2), new CharLenSeg(8602, 8712, 1), new CharLenSeg(8712, 8713, 2), new CharLenSeg(8713, 8719, 1), new CharLenSeg(8719, 8720, 2), new CharLenSeg(8720, 8721, 1), new CharLenSeg(8721, 8722, 2), new CharLenSeg(8722, 8725, 1), new CharLenSeg(8725, 8726, 2), new CharLenSeg(8726, 8728, 1), new CharLenSeg(8728, 8729, 2), new CharLenSeg(8729, 8730, 1), new CharLenSeg(8730, 8731, 2), new CharLenSeg(8731, 8733, 1), new CharLenSeg(8733, 8737, 2), new CharLenSeg(8737, 8739, 1), new CharLenSeg(8739, 8740, 2), new CharLenSeg(8740, 8741, 1), new CharLenSeg(8741, 8742, 2), new CharLenSeg(8742, 8743, 1), new CharLenSeg(8743, 8748, 2), new CharLenSeg(8748, 8750, 1), new CharLenSeg(8750, 8751, 2), new CharLenSeg(8751, 8756, 1), new CharLenSeg(8756, 8760, 2), new CharLenSeg(8760, 8764, 1), new CharLenSeg(8764, 8766, 2), new CharLenSeg(8766, 8776, 1), new CharLenSeg(8776, 8777, 2), new CharLenSeg(8777, 8780, 1), new CharLenSeg(8780, 8781, 2), new CharLenSeg(8781, 8786, 1), new CharLenSeg(8786, 8787, 2), new CharLenSeg(8787, 8800, 1), new CharLenSeg(8800, 8802, 2), new CharLenSeg(8802, 8804, 1), new CharLenSeg(8804, 8808, 2), new CharLenSeg(8808, 8814, 1), new CharLenSeg(8814, 8816, 2), new CharLenSeg(8816, 8853, 1), new CharLenSeg(8853, 8854, 2), new CharLenSeg(8854, 8857, 1), new CharLenSeg(8857, 8858, 2), new CharLenSeg(8858, 8869, 1), new CharLenSeg(8869, 8870, 2), new CharLenSeg(8870, 8895, 1), new CharLenSeg(8895, 8896, 2), new CharLenSeg(8896, 8978, 1), new CharLenSeg(8978, 8979, 2), new CharLenSeg(8979, 9312, 1), new CharLenSeg(9312, 9322, 2), new CharLenSeg(9322, 9332, 1), new CharLenSeg(9332, 9372, 2), new CharLenSeg(9372, 9632, 1), new CharLenSeg(9632, 9634, 2), new CharLenSeg(9634, 9650, 1), new CharLenSeg(9650, 9652, 2), new CharLenSeg(9652, 9660, 1), new CharLenSeg(9660, 9662, 2), new CharLenSeg(9662, 9670, 1), new CharLenSeg(9670, 9672, 2), new CharLenSeg(9672, 9675, 1), new CharLenSeg(9675, 9676, 2), new CharLenSeg(9676, 9678, 1), new CharLenSeg(9678, 9680, 2), new CharLenSeg(9680, 9698, 1), new CharLenSeg(9698, 9702, 2), new CharLenSeg(9702, 9733, 1), new CharLenSeg(9733, 9735, 2), new CharLenSeg(9735, 9737, 1), new CharLenSeg(9737, 9738, 2), new CharLenSeg(9738, 9792, 1), new CharLenSeg(9792, 9793, 2), new CharLenSeg(9793, 9794, 1), new CharLenSeg(9794, 9795, 2), new CharLenSeg(9795, 12288, 1), new CharLenSeg(12288, 12292, 2), new CharLenSeg(12292, 12293, 1), new CharLenSeg(12293, 12312, 2), new CharLenSeg(12312, 12317, 1), new CharLenSeg(12317, 12319, 2), new CharLenSeg(12319, 12321, 1), new CharLenSeg(12321, 12330, 2), new CharLenSeg(12330, 12353, 1), new CharLenSeg(12353, 12436, 2), new CharLenSeg(12436, 12443, 1), new CharLenSeg(12443, 12447, 2), new CharLenSeg(12447, 12449, 1), new CharLenSeg(12449, 12535, 2), new CharLenSeg(12535, 12540, 1), new CharLenSeg(12540, 12543, 2), new CharLenSeg(12543, 12549, 1), new CharLenSeg(12549, 12586, 2), new CharLenSeg(12586, 12690, 1), new CharLenSeg(12690, 12704, 2), new CharLenSeg(12704, 12832, 1), new CharLenSeg(12832, 12868, 2), new CharLenSeg(12868, 12928, 1), new CharLenSeg(12928, 12958, 2), new CharLenSeg(12958, 12959, 1), new CharLenSeg(12959, 12964, 2), new CharLenSeg(12964, 12969, 1), new CharLenSeg(12969, 12977, 2), new CharLenSeg(12977, 13198, 1), new CharLenSeg(13198, 13200, 2), new CharLenSeg(13200, 13212, 1), new CharLenSeg(13212, 13215, 2), new CharLenSeg(13215, 13217, 1), new CharLenSeg(13217, 13218, 2), new CharLenSeg(13218, 13252, 1), new CharLenSeg(13252, 13253, 2), new CharLenSeg(13253, 13262, 1), new CharLenSeg(13262, 13263, 2), new CharLenSeg(13263, 13265, 1), new CharLenSeg(13265, 13267, 2), new CharLenSeg(13267, 13269, 1), new CharLenSeg(13269, 13270, 2), new CharLenSeg(13270, 19968, 1), new CharLenSeg(19968, 40870, 2), new CharLenSeg(40870, 55296, 1), new CharLenSeg(55296, 55297, 0), new CharLenSeg(55297, 56320, 1), new CharLenSeg(56320, 56321, 2), new CharLenSeg(56321, 57344, 1), new CharLenSeg(57344, 59335, 2), new CharLenSeg(59335, 59337, 1), new CharLenSeg(59337, 59493, 2), new CharLenSeg(59493, 63733, 1), new CharLenSeg(63733, 63734, 2), new CharLenSeg(63734, 63744, 1), new CharLenSeg(63744, 64046, 2), new CharLenSeg(64046, 65072, 1), new CharLenSeg(65072, 65074, 2), new CharLenSeg(65074, 65075, 1), new CharLenSeg(65075, 65093, 2), new CharLenSeg(65093, 65097, 1), new CharLenSeg(65097, 65107, 2), new CharLenSeg(65107, 65108, 1), new CharLenSeg(65108, 65112, 2), new CharLenSeg(65112, 65113, 1), new CharLenSeg(65113, 65127, 2), new CharLenSeg(65127, 65128, 1), new CharLenSeg(65128, 65132, 2), new CharLenSeg(65132, 65281, 1), new CharLenSeg(65281, 65375, 2), new CharLenSeg(65375, 65504, 1), new CharLenSeg(65504, 65510, 2), new CharLenSeg(65510, 65536, 1), } ); public static bool IsWideChar(char c) { return CalcCharLength(c) > 1; } public static int CalcCharLength(char c) { return AllCharLenSegs.BinarySearch(c).Length; } public static int CalcStringLength(string str) { int total = 0; foreach (char c in str) total += CalcCharLength(c); return total; } } }</content></entry><entry><title>[C#] 循环所有可能的字符</title><url>https://slimenull.top/post/csharp-enumallchars/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag></tags><content type="html"> 通过 char.MaxValue 来作为循环结尾, 将int强制转换为char, 即可
之前自己搜索这个内容, 发现国内没有, 所以写了这个文章供参考
for (int i = 0; i &lt;= char.MaxValue; i++) { // 此处放处理语句, (char)i 即为当前字符 }</content></entry><entry><title>[C#] 各种关于类型与反射的常用操作.</title><url>https://slimenull.top/post/csharp-commonlyusedreflection/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag><tag>参考</tag></tags><content type="html"> 类型操作, 根据Type进行类型转换, 接口获取与比较, 泛型接口获取与比较, 类的字段获取与设置.
本文章是面向初学者的一些资料 注意: 存在即合理, 可能某些初学者认为这些东西并无必要, 但实际上它们有很大的用处
获取类型(Type)对象 object obj; Type objType = obj.GetType(); 判断类型是否可以转换 这个方法同样可以判断B是否继承于A(可以是类和接口), 但是如果你要判断一个类是否继承了一个泛型接口, 不指定相同的泛型参数, 是无法判断成功的, 比如一个继承了 Demo&lt;string, string> 接口的类在使用下面的方法来判断是否继承 Demo&lt;> 接口时, 就无法获得正确的结果. 这种方法是严谨的.
例子表示了A是否派生B, 也就是B是否继承于A, 或者说B是否可以强制转换为A
bool result = typeof(B).IsAssignableFrom(typeof(B)); 获取类型继承的的接口 (包含泛型接口) 获取的接口, 都是接口原型, 比如获取到的会是IDicrionary&lt;,>, 而不是IDictionary&lt;TKey, TValue>. 利用这个特性, 我们可以判断一个类型是否继承某个泛型接口, 而不需要指定详细的泛型参数. 下面的原始接口指IDictionary&lt;string,string>与IDictionary&lt;,>之间的关系, IDictionary即原始接口 (这个概念并不是公认概念, 但是没有已经规定的概念来描述"原始接口", 所以在这里提出了这个概念) Type[] interfaces = typeof(A).GetInterfaces(); 参考: 判断是否继承某个泛型接口并获取泛型参数:
// 在这个方法中, 会比对targetType的原始接口是否与interfaceType一致 private static bool CheckInterface(Type targetType, Type interfaceType, out Type[] geneticTypes) { foreach(Type i in targetType.GetInterfaces()) { if (i.GetGenericTypeDefinition().Equals(interfaceType)) // GetGenericTypeDefinition() 即获取原始接口类型. 如果去除这个方法, 则是严谨的比较类型 { geneticTypes = i.GetGenericArguments(); return true; } } geneticTypes = null; return false; } 类的字段获取与设置 以类型A为例:
A obj = new A(); Type objType = typeof(A); FieldInfo[] fieldInfos = objType.GetFields(); // 获取字段信息 object fieldValue = fieldInfos[0].GetValue(obj); // 获取字段值 fieldInfos[0].SetValue(obj, "这是一个值"); // 设置字段的值 根据Type对象进行类型转换 例如, 将A转换为B
A objA = new A(); object objB = Convert.ChangeType(objA, typeof(B)); // 返回了转换为B类型的对象的引用</content></entry><entry><title>[踩坑记录] Image.Save 遇到 A generic error occurred in GDI+ 异常</title><url>https://slimenull.top/post/csharp-gdigenericerror/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>图像</tag><tag>踩坑记录</tag></tags><content type="html"> 先看自己路径是不是错了 然后看自己的路径表达是不是不符合标准, 例如这样的"/ewq_00010.png", 它指向C:\根目录下的一个文件! 而.NET中一般不允许对那里进行写操作 然后, 我就是在上述内容的情况上犯了错&hellip; &ldquo;/ewq_00010.png"应该是&rdquo;./ewq_00010.png", 使用这个点来表示, 它是一个相对路径
我的解决过程 Image 保存的Path是"/ewq_00010.png" 在发现这个问题后, 我首先是检查了一下, 我写的路径是否是正确的, 比如, 目录是否存在, 我使用VS的调试功能, 测试了一下, Directory.Exists(Path.GetDirectoryName("/ewq_00010.png")) 结果是true, 初步判断不是路径问题 后来查资料, 发现可能是这个Image是FromFile生成的而报错, 但我的不是, 它完完全全是一个new出来的, 我又尝试性地指定ImageFormat.Png, 果然, 问题没有解决 继续查资料, 发现有人使用FileStream解决了问题, 我也尝试, 然后失败了&hellip; 写入被拒绝, 查了查资料, 为什么FileStream写入被拒绝, 一堆乱七八糟的东西, 看都看不懂, 大概就是讲ASP.NET不能在C:\写入, 但是我又不是ASP.NET 然后我尝试转个弯子, 用MemoryStream, 然后最后用File.WriteAllBytes写入试试, 最后, 我突然发现, 它提示我, 对C:/的写入被拒绝, 蛤??? 我的路径不是"/ewq_0010.png"吗??? 我脑子跟Linux联想了起来, 总不会&hellip; 单个斜杠指C:/吧? 这个输出路径, 其实是经过我的一个PathCombine函数拼合而成的路径, 它很简单, 但也因为它的判断很简单而嗝屁了
public static string CombinePath(string path1, string path2) // 简单粗暴路径拼合 { if (path2.Contains(':')) { throw new ArgumentException("第二个路径不可是绝对路径"); } return path1.TrimEnd(new char[] { '/', '\\' }).Replace('\\', '/') + "/" + path2.TrimStart(new char[] { '/', '\\' }).Replace('\\', '/'); } 然后我把这个函数改成了这样: public static string CombinePath(string path1, string path2) { if (path2.Contains(':')) { throw new ArgumentException("第二个路径不可是绝对路径"); } string result = path1.TrimEnd(new char[] { '/', '\\' }).Replace('\\', '/') + "/" + path2.TrimStart(new char[] { '/', '\\' }).Replace('\\', '/'); if (result.Contains(':')) // 简单粗暴判断你是否是绝对路径 { return result; // 如果是绝对路径就直接返回, 也不管他是否是对的 } else { return "./" + result.Trim('/'); // 如果不是, 则加一个"./"来强调, '我这是相对路径' } } 然后&hellip; 程序成功跑起来了&hellip; 最后, 这个程序是用于根据atlas图像索引表分解图像的, 如果你觉得有参考价值, 可以私信我</content></entry><entry><title>[C#] 实现鼠标拖动控件移动和大小调整</title><url>https://slimenull.top/post/csharp-controldragmoveandresize/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>WinForm</tag><tag>笔记</tag><tag>轮子</tag></tags><content type="html"> 之前我做了一个类来实现拖拽移动控件或窗体嘛, 现在又弄了一个调整大小的, 功能相似, 所以我就直接把这个调整大小的跟之前的功能整合到了一起. (可以提到的是, 期间因为特殊需求, 还做了一个映射拖拽移动控件窗体, 就是拖拽控件1, 移动控件2)
最近闲来无事, 倒是借助 WebAPI 实现翻译器, 本想设计一个炫酷的界面(模仿VS), 却没想到, 难度大大超出我的想象, 拖拽, 调整大小, 如果要实现VS的边框, 还需要想办法做到过渡透明! 这对于 WinForm 来说实在是太难了, 如果不过渡透明, 就是全透明, 那鼠标就直接穿窗体了! 不过还是有些成果的, 比如, 造了两个轮子 (我真是一个热衷于造轮子的憨憨)
所说的轮子就是文章标题咯
下面的代码就是程序主体了, 它是应该被封装到一个类库里的, 所以, 不要直接把这些代码添加到你的文件中, 而是新建一个类库(不是新建项目, 而是添加到你的项目中), 然后把这些代码覆盖到新的文件中, 在你的程序中using EleCho.DragOperation即可使用代码所包含的3个功能(DragMove,MapDragMove,DragResize)
using System; using System.Collections.Generic; using System.Drawing; using System.Windows.Forms; namespace EleCho { namespace DragOperation { public class DragMove { public DragMove(MouseButtons MouseButton, DragMoveMode FollowMode = DragMoveMode.All, bool OutParent = false) { this.MouseButton = MouseButton; this.FollowMode = FollowMode; this.OutParent = OutParent; } public DragMove(DragMoveMode FollowMode = DragMoveMode.All, bool OutParent = false) { AllMouseButton = true; this.FollowMode = FollowMode; this.OutParent = OutParent; } object AboutControl; // 表示当前移动控件操作是针对哪个控件的 bool Moving = false; // 表示是否正在移动控件 bool AllMouseButton = false; // 表示是否处理所有按钮 bool OutParent; // 表示是否允许脱离父容器的显示区域 Point ControlStartLocation; // 表示移动操作时, 控件的初始位置 Point MouseFirstLocationAboutParent; // 表示移动操作时, 鼠标的初始位置 DragMoveMode FollowMode; // 跟随模式 MouseButtons MouseButton; // 判定按钮 List&lt;Control> AddedControls = new List&lt;Control>(); // 已添加控件 void MouseDownEvent(object sender, MouseEventArgs e) { if ((e.Button == MouseButton) || AllMouseButton) { AboutControl = sender; Moving = true; ControlStartLocation = (sender as Control).Location; if (sender is Form) { MouseFirstLocationAboutParent = Control.MousePosition; } else { MouseFirstLocationAboutParent = (sender as Control).Parent.PointToClient(Control.MousePosition); } } } void MouseMoveEvent(object sender, MouseEventArgs e) { if (sender == AboutControl) { if (Moving) { Point MouseLocationNow; if (sender is Form) { MouseLocationNow = Control.MousePosition; } else { MouseLocationNow = (sender as Control).Parent.PointToClient(Control.MousePosition); } int NewX = MouseLocationNow.X - MouseFirstLocationAboutParent.X + ControlStartLocation.X; int NewY = MouseLocationNow.Y - MouseFirstLocationAboutParent.Y + ControlStartLocation.Y; if (!OutParent) { if (!(sender is Form)) { if (NewX &lt; 0) { NewX = 0; } else if (NewX + (sender as Control).Width > (sender as Control).Parent.Width) { NewX = (sender as Control).Parent.Width - (sender as Control).Width; } if (NewY &lt; 0) { NewY = 0; } else if (NewY + (sender as Control).Height > (sender as Control).Parent.Height) { NewY = (sender as Control).Parent.Height - (sender as Control).Height; } } } if (FollowMode == DragMoveMode.X) { NewY = ControlStartLocation.Y; } if (FollowMode == DragMoveMode.Y) { NewX = ControlStartLocation.X; } (sender as Control).Location = new Point(NewX, NewY); } } else { if (Moving) { Moving = false; (AboutControl as Control).Location = ControlStartLocation; } } } void MouseUpEvent(object sender, MouseEventArgs e) { if (sender != AboutControl) { if (Moving) { (AboutControl as Control).Location = ControlStartLocation; } } Moving = false; } public bool AddControl(Control control) { if (AddedControls.Contains(control)) { return false; } else { control.MouseDown += MouseDownEvent; control.MouseMove += MouseMoveEvent; control.MouseUp += MouseUpEvent; AddedControls.Add(control); return true; } } public bool RemoveControl(Control control) { if (AddedControls.Contains(control)) { control.MouseDown -= MouseDownEvent; control.MouseMove -= MouseMoveEvent; control.MouseUp -= MouseUpEvent; AddedControls.Remove(control); return true; } else { return false; } } } public class MapDragMove { public MapDragMove(MouseButtons MouseButton, DragMoveMode FollowMode = DragMoveMode.All) { this.MouseButton = MouseButton; this.FollowMode = FollowMode; } public MapDragMove(DragMoveMode FollowMode = DragMoveMode.All) { AllMouseButton = true; this.FollowMode = FollowMode; } object AboutControl; // 表示当前移动控件操作是针对哪个控件的 bool Moving = false; // 表示是否正在移动控件 bool AllMouseButton = false; // 表示是否处理所有按钮 Point ControlStartLocation; // 表示移动操作时, 控件的初始位置 Point MouseFirstLocation; // 表示移动操作时, 鼠标的初始位置 DragMoveMode FollowMode; // 跟随模式 MouseButtons MouseButton; // 判定按钮 Dictionary&lt;Control, Control> AddedControls = new Dictionary&lt;Control, Control>(); // 已添加控件 void MouseDownEvent(object sender, MouseEventArgs e) { if ((e.Button == MouseButton) || AllMouseButton) { AboutControl = sender; Moving = true; ControlStartLocation = (sender as Control).Location; MouseFirstLocation = Control.MousePosition; } } void MouseMoveEvent(object sender, MouseEventArgs e) { if (sender == AboutControl) { if (Moving) { Point MouseLocationNow = Control.MousePosition; if (FollowMode == DragMoveMode.X) { AddedControls[sender as Control].Left += MouseLocationNow.X - MouseFirstLocation.X; } else if (FollowMode == DragMoveMode.Y) { AddedControls[sender as Control].Top += MouseLocationNow.Y - MouseFirstLocation.Y; } else { AddedControls[sender as Control].Location = new Point(AddedControls[sender as Control].Location.X + (MouseLocationNow.X - MouseFirstLocation.X), AddedControls[sender as Control].Location.Y + (MouseLocationNow.Y - MouseFirstLocation.Y)); } MouseFirstLocation = MouseLocationNow; } } else { if (Moving) { Moving = false; (AboutControl as Control).Location = ControlStartLocation; } } } void MouseUpEvent(object sender, MouseEventArgs e) { if (sender != AboutControl) { if (Moving) { (AboutControl as Control).Location = ControlStartLocation; } } Moving = false; } public bool AddControl(Control dragControl, Control moveControl) { if (AddedControls.ContainsKey(dragControl)) { return false; } else { dragControl.MouseDown += MouseDownEvent; dragControl.MouseMove += MouseMoveEvent; dragControl.MouseUp += MouseUpEvent; AddedControls.Add(dragControl, moveControl); return true; } } public bool RemoveControl(Control control) { if (AddedControls.ContainsKey(control)) { control.MouseDown -= MouseDownEvent; control.MouseMove -= MouseMoveEvent; control.MouseUp -= MouseUpEvent; AddedControls.Remove(control); return true; } else { return false; } } } /// &lt;summary> /// 控件跟随鼠标的移动模式 /// &lt;/summary> public enum DragMoveMode { /// &lt;summary> /// 表示只跟随横坐标 /// &lt;/summary> X, /// &lt;summary> /// 表示只跟随纵坐标 /// &lt;/summary> Y, /// &lt;summary> /// 跟随横坐标与纵坐标 /// &lt;/summary> All } public class DragResize { public DragResize(MouseButtons MouseButton, int BorderSize = 5) { this.MouseButton = MouseButton; this.BorderSize = BorderSize; } public DragResize(int BorderSize = 5) { this.AllMouseButton = true; this.BorderSize = BorderSize; } int BorderSize = 10; // 边框判断大小 object AboutControl; // 表示当前调整控件操作是针对哪个控件的 bool Resizing = false; // 表示是否正在调整控件 bool AllMouseButton = false; // 表示是否处理所有按钮 bool MouseDownING = false; bool LeftResize; bool RightResize; bool TopResize; bool BottomResize; private Point MouseFirstLocation; // 表示调整操作时, 鼠标的初始位置 MouseButtons MouseButton; // 判定按钮 List&lt;Control> AddedControls = new List&lt;Control>(); // 已添加控件 void CheckMouse(object sender) { Point mousePosition; if (sender is Form) { mousePosition = Control.MousePosition; } else { mousePosition = (sender as Control).Parent.PointToClient(Control.MousePosition); } if (mousePosition.X >= (sender as Form).Left &amp;&amp; mousePosition.X &lt;= (sender as Form).Left + BorderSize) { LeftResize = true; } else if (mousePosition.X >= (sender as Form).Left + (sender as Form).Width - BorderSize &amp;&amp; mousePosition.X &lt;= (sender as Form).Left + (sender as Form).Width) { RightResize = true; } else { LeftResize = false; RightResize = false; } if (mousePosition.Y &lt;= (sender as Form).Top + BorderSize &amp;&amp; mousePosition.Y >= (sender as Form).Top) { TopResize = true; } else if (mousePosition.Y >= (sender as Form).Top + (sender as Form).Height - BorderSize &amp;&amp; mousePosition.Y &lt;= (sender as Form).Top + (sender as Form).Height) { BottomResize = true; } else { TopResize = false; BottomResize = false; } if ((LeftResize || RightResize || TopResize || BottomResize) &amp;&amp; MouseDownING) { Resizing = true; AboutControl = sender; } else { Resizing = false; } } void MouseDownEvent(object sender, MouseEventArgs e) { if (AllMouseButton || e.Button == MouseButton) { MouseDownING = true; CheckMouse(sender); if (Resizing) { MouseFirstLocation = Control.MousePosition; } } } void MouseMoveEvent(object sender, MouseEventArgs e) { if (Resizing &amp;&amp; sender == AboutControl) { Point mousePosition = Control.MousePosition; (sender as Control).Invalidate(false); if (LeftResize) { (sender as Control).Width += MouseFirstLocation.X - mousePosition.X; (sender as Control).Left -= MouseFirstLocation.X - mousePosition.X; } else if (RightResize) { (sender as Control).Width += mousePosition.X - MouseFirstLocation.X; } if (TopResize) { (sender as Control).Height += MouseFirstLocation.Y - mousePosition.Y; (sender as Control).Top -= MouseFirstLocation.Y - mousePosition.Y; } else if (BottomResize) { (sender as Control).Height += mousePosition.Y - MouseFirstLocation.Y; } (sender as Control).Invalidate(true); MouseFirstLocation = mousePosition; } else { CheckMouse(sender); if (TopResize) { if (LeftResize) { (sender as Control).Cursor = Cursors.SizeNWSE; } else if (RightResize) { (sender as Control).Cursor = Cursors.SizeNESW; } else { (sender as Control).Cursor = Cursors.SizeNS; } } else if (BottomResize) { if (LeftResize) { (sender as Control).Cursor = Cursors.SizeNESW; } else if (RightResize) { (sender as Control).Cursor = Cursors.SizeNWSE; } else { (sender as Control).Cursor = Cursors.SizeNS; } } else if (LeftResize) { (sender as Control).Cursor = Cursors.SizeWE; } else if (RightResize) { (sender as Control).Cursor = Cursors.SizeWE; } else { (sender as Control).Cursor = Cursors.Default; } } } void MouseUpEvent(object sender, MouseEventArgs e) { MouseDownING = false; if (Resizing) { Resizing = false; } } void MouseLeaveEvent(object sender, EventArgs e) { (sender as Control).Cursor = Cursors.Default; } public bool AddControl(Control control) { if (AddedControls.Contains(control)) { return false; } else { control.MouseLeave += MouseLeaveEvent; control.MouseDown += MouseDownEvent; control.MouseMove += MouseMoveEvent; control.MouseUp += MouseUpEvent; AddedControls.Add(control); return true; } } public bool RemoveControl(Control control) { if (AddedControls.Contains(control)) { control.MouseDown -= MouseDownEvent; control.MouseMove -= MouseMoveEvent; control.MouseUp -= MouseUpEvent; AddedControls.Remove(control); return true; } else { return false; } } } } }</content></entry><entry><title>[C#] 实现鼠标拖动控件移动</title><url>https://slimenull.top/post/csharp-controldragmove/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>WinForm</tag><tag>笔记</tag><tag>轮子</tag></tags><content type="html"> 对鼠标拖动实现控件移动的原理详解, 以及使用类将功能封装, 实现一个类管理多个控件的拖动.
原理: 每当鼠标移动时, 根据鼠标坐标计算出控件应处于的位置并将控件移动到计算出的位置, 另外, 为了标识是否正在拖动控件, 还需要订阅控件的MouseDown和MouseUp事件. 当MouseDown事件触发时, 标识是否正在拖动控件的布尔变量设置为true, 当MouseUp事件触发时, 标识是否正在拖动控件的布尔变量设置为false; 在鼠标移动时, 会判断这个变量的值以决定是否应该移动控件. 为了保证鼠标相对控件的位置是不变的, 所以还需要一个Point类型的变量来标识鼠标按下控件时, 鼠标相对控件的相对位置. 一些资料: 获取鼠标相对屏幕的坐标 : Control.MousePosition; 获取一个 相对于屏幕的坐标 相对某个控件的相对坐标 : 控件.PointToClient(一个相对于屏幕的坐标); 下面是方便初学者的:
as运算符, 将某个实例作为某种类型使用, 例如: // obj是一个Button转换为object类型的按钮 // 那么, (obj as Button).Text = "新的文本"; 是可用的, 它将为控件指定一个新的文本 (obj as Button).Text = "新的文本"; // 注意, as运算符的优先级低于.运算符, 所以括号不可以省去 单控件实现: 新建项目, 项目类型是WinForm. 添加控件 (我这里将控件的Name设置为了ExempleButton) 浓浓的Chinglish味道, 哈哈哈
3. 添加相关事件(MouseDown, MouseMove, MouseUp): 4. 转到代码, 添加相关变量. 5. 添加关键代码: bool Moving = false; // 标识是否在拖动控件 Point MouseFirstLocation; // 鼠标按下时, 相对于控件的坐标 private void ExempleButton_MouseDown(object sender, MouseEventArgs e) { Moving = true; // 表示进入拖动控件的状态 Point MousePoint = Control.MousePosition; // 获取鼠标相对屏幕的坐标 MouseFirstLocation = ExempleButton.PointToClient(MousePoint); // 获取坐标相对于控件的相对坐标并赋值给MouseFirstLocation } private void ExempleButton_MouseMove(object sender, MouseEventArgs e) { if (Moving) { Point MousePoint = Control.MousePosition; // 获取鼠标相对屏幕的坐标 Point MousePointToContainer = ExempleButton.Parent.PointToClient(MousePoint); // 获取鼠标相对控件父容器的坐标 Point ControlNewLocation = new Point(MousePointToContainer.X - MouseFirstLocation.X, MousePointToContainer.Y - MouseFirstLocation.Y); // 计算控件应处于的, 新的坐标 ExempleButton.Location = ControlNewLocation; // 移动控件 } } private void ExempleButton_MouseUp(object sender, MouseEventArgs e) { Moving = false; // 脱离拖动控件的状态 } 可以使用了~ 多控件实现: 使用类封装功能, 类的AddControl(Control control)方法来快捷使某个控件支持鼠标拖动移动位置. 这里的原理与前面的单控件实现有些出入, 但也是通过初始鼠标坐标(这里是相对父容器而不是移动的控件)与初始坐标计算出的 这个类不仅支持窗体内的控件, 而且还支持窗体 (没有直接使用WindowsAPI) class DragMove { public DragMove(MouseButtons MouseButton) { this.MouseButton = MouseButton; } public DragMove() { AllMouseButton = true; } object AboutControl; // 表示当前移动控件操作是针对哪个控件的 bool Moving = false; // 表示是否正在移动控件 bool AllMouseButton = false; // 表示是否处理所有按钮 Point ControlStartLocation; // 表示移动操作时, 控件的初始位置 Point MouseFirstLocationAboutParent; // 表示移动操作时, 鼠标的初始位置 MouseButtons MouseButton; List&lt;Control> AddedControls = new List&lt;Control>(); void MouseDownEvent(object sender, MouseEventArgs e) { if ((e.Button == MouseButton) || AllMouseButton) { AboutControl = sender; Moving = true; ControlStartLocation = (sender as Control).Location; if (sender is Form) { MouseFirstLocationAboutParent = Control.MousePosition; } else { MouseFirstLocationAboutParent = (sender as Control).Parent.PointToClient(Control.MousePosition); } } } void MouseMoveEvent(object sender, MouseEventArgs e) { if (sender == AboutControl) { if (Moving) { Point MouseLocationNow; if (sender is Form) { MouseLocationNow = Control.MousePosition; } else { MouseLocationNow = (sender as Control).Parent.PointToClient(Control.MousePosition); } Point ControlNewLocation = new Point(MouseLocationNow.X - MouseFirstLocationAboutParent.X + ControlStartLocation.X, MouseLocationNow.Y - MouseFirstLocationAboutParent.Y + ControlStartLocation.Y); (sender as Control).Location = ControlNewLocation; } } else { if (Moving) { Moving = false; (AboutControl as Control).Location = ControlStartLocation; } } } void MouseUpEvent(object sender, MouseEventArgs e) { if (sender != AboutControl) { if (Moving) { (AboutControl as Control).Location = ControlStartLocation; } } Moving = false; } public bool AddControl(Control control) { if (AddedControls.Contains(control)) { return false; } else { control.MouseDown += MouseDownEvent; control.MouseMove += MouseMoveEvent; control.MouseUp += MouseUpEvent; AddedControls.Add(control); return true; } } public bool RemoveControl(Control control) { if (AddedControls.Contains(control)) { control.MouseDown -= MouseDownEvent; control.MouseMove -= MouseMoveEvent; control.MouseUp -= MouseUpEvent; AddedControls.Remove(control); return true; } else { return false; } } } 这个类包含了判断鼠标按键的功能, 比如只允许右键拖动控件, 也有一些预防措施, 保证类能够正常工作的一些措施(判断控件), 也支持添加与移除控件</content></entry><entry><title>[C#] 如何创建DLL并在项目中使用</title><url>https://slimenull.top/post/csharp-createdynamiclinklibrary/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag><tag>参考</tag></tags><content type="html"> 适合初学者的, 从 0 开始的 .NET C# 动态链接库(dll)创建教程
关于DLL: 在C#中, DLL可以说是类库, 创建一个类库类型的项目后, 生成时生成的文件时一个DLL文件 一个类库中, 包含一个或多个类, 这些类处于某个命名空间下, 当引用这个DLL文件后, using 相应的命名空间后即可直接使用类库中所包含的类 一般的, 创建DLL文件为的是将自己定义的一个类, 直接制作成DLL文件以方便别人使用, 这样不需要复制代码也可以使用你定义的类. (对于不了解引用是什么的初学者, 你需要知道, 一个C#程序, 会使用不少的类库, 比如System.dll, System.Windows.Forms.dll, 但是这些.NET框架含有的类库, C#程序可以直接使用, 而不需要将DLL文件置于程序所在目录下, 项目的&rsquo;引用&rsquo;说明了这个程序使用了什么类库, 而且在你编程的时候, VS也会根据你引用的类库来给你代码提示) 创建DLL文件: 创建一个 类库(.NET Framework) 项目, 如下图, 不过, 因为我已经有创建过了, 所以我就直接使用之前创建的项目了. 创建完成后, 你就可以写代码了, 要清楚, C#的类库包含的其实就是一个个的类, 或者其他成员(不能是字段).
下图, 就是我之前的项目, 注意, 这些供使用者访问的成员别忘了使用public修饰.
我的这个项目, 是一个用来操作Json的类库, 之后将使用它来尝试操作DLL 生成项目, 并找到生成的DLL文件. 2022 补充: 创建类库, 其实也可以针对不同的目标, .NET Framework 的类库只可以被 .NET Framework 项目所使用, .NET Core 的类库只可以被 .NET Core 项目所使用, .NET Standard 是都可以使用, 但是一般不推荐(依赖问题) 详见: [.NET] 关于动态链接库目标与依赖问题
引用生成的DLL: 首先, 转到另外一个项目, 我们将在这个项目中使用之前生成的DLL. 添加引用, 在解决方案管理器中右击项目, 添加, 引用, 添加引用, 在弹出的窗口中点击浏览, 然后在选择文件窗口中选择之前生成的DLL文件, 点击添加, 最后在引用管理器中点击确定. 于是, 我们就成功的引用了之前生成的DLL文件. 使用DLL中包含的成员: 在创建DLL时, 可以看到, 成员均处于 CHO.Json 命名空间下, 所以我们using它, 如下图, 并没有出现错误. 准备一个Json文本来使程序读取.
{ "姓名": "小明", "性别": "男", "年龄": 16, "自述": null, "是否患新冠肺炎": false, "学习的编程语言": ["C#", "Python", "C"] } 将其转换为字符串表达式. (这里使用了我自己的小程序, 文章末尾会附上下载链接) 将代码写好. 运行程序. 可以看到, 成功使用了类库中的JsonData类,和JsonDataType枚举类型.
附. 将文本转换为字符串表达式的小工具 (蓝奏云下载
) 关于我写的这个Json操作类库(CSDN文章
)</content></entry><entry><title>[C#] 无需实体类, 解析读写Json</title><url>https://slimenull.top/post/csharp-operatejsonwithoutmodel/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag><tag>轮子</tag><tag>旧的</tag></tags><content type="html"> (旧的) 自己实现的一个 Json 解析, 操作类, 可以使你像 Python 那样弱类型般操作 Json 数据
2022/3/26 补充: 该文章已过时, 你可以看新的文章: EleCho.Json
关于: 这是我自己写的一个类库, 已经封装到了一个dll中, 暂且命名为CHO.Json, 它能够使你像Python那样操作Json数据, 非常适合新手 虽然在操作较大的Json数据时, 需要实体类会更方便, 但是这个类库, 可以让你实时判断Json数据的类型. 当然, 以后也会考虑加入需实体类的序列化与反序列化. 它具有较大的容差值, 所以允许一些Json不允许的操作, 例如将Bool值作为Object中的键, CHO.Json支持这样, 由CHO.Json生成的Json文本, CHO.Json完全可以读取. 因为其特殊性, 所以可能别的Json读写模块无法识别, 所以, 为了保证正常使用, 即便CHO.Json支持这些操作, 但务必遵守标准Json的规则. 新版的某些函数已经与介绍有些出入, 请查看新文章 CHO.Json 操作
已经添加了关于实体类的序列化与反序列化功能, 详见 Github仓库
原理: 由一个JsonData类来表示任何Json数据, 包括Object, Array, String, ==Integer, Float, Double, Boolean==, Null, 其中由枚举属性DataType来表示该JsonData属于何种数据类型. 分析Json文本, 这个就无需多言了, 如果感兴趣, 可以联系我, 获取它的源代码. 当然, 你也可以直接将dll反编译. 命名空间: 该Json解析方式所需的成员位于dll中 CHO.Json 命名空间下 命名空间下包含了一些异常类型: JsonDataTypeException, InvalidCharParseException, NotClosedParseException, ParseCallError, ParseUnknownError, JsonFormatParseException这些继承于Exception的类, 它们分别表示了 Json数据类型异常, 分析Json文本时的非法字符异常, 分析Json文本时的数据未结束异常, 分析Json文本时的调用错误, 分析Json文本时的未知错误(该错误在正常使用时不会出现, 除非用户自定义的类继承JsonData, 并写了一些奇怪的代码), 分析Json文本时的Json数据格式错误. 命名空间下包含了枚举类型 JsonDataType, 它的成员有这些: Object, Array, String, Number, Bool, Null. 这些表示了JsonData中所包含的Json数据的类型. 命名空间下包含的JsonData是CHO.Json的核心, 它提供了对所有Json数据的操作方法, 例如Array的Add方法, 提供了分析Json文本的Parse方法, 将JsonData示例转换为Json文本的ToJsonTest方法, 注意, 在使用一种操作Json数据的方法前, 请确保, 实例所包含的Json数据是方法支持的, 否则将抛出JsonDataTypeException异常. 使用: CHO.Json的使用基本上是对JsonData的操作, 下面给出一个实例, 以了解CHO.Json的基本使用方法.
这是一个Json文本, 接下来将使用程序来读取它并输出一些值
{ &ldquo;姓名&rdquo;: &ldquo;小明&rdquo;, &ldquo;性别&rdquo;: &ldquo;男&rdquo;, &ldquo;年龄&rdquo;: 16, &ldquo;境内&rdquo;: true, &ldquo;自述&rdquo;: null, &ldquo;学习科目&rdquo;: [ &ldquo;语文&rdquo;, &ldquo;数学&rdquo;, &ldquo;英语&rdquo;, &ldquo;信息技术&rdquo; ] }
将其转换为字符串表达式后: ==注意, 在新版本中, 将JsonData实例转换为Json文本你需要使用JsonData的静态方法: ConvertToText== &ldquo;{\n "姓名": "小明",\n "性别": "男",\n "年龄": 16,\n "境内": true,\n "自述": null,\n "学习科目": [\n "语文",\n "数学",\n "英语",\n "信息技术"\n ]\n}&rdquo;
using System; using CHO.Json; namespace CSharpJson { class Program { static void Main(string[] args) { JsonData json = JsonData.Parse("{\n \"姓名\": \"小明\",\n \"性别\": \"男\",\n \"年龄\": 16,\n \"境内\": true,\n \"自述\": null,\n \"学习科目\": [\n \"语文\",\n \"数学\",\n \"英语\",\n \"信息技术\"\n ]\n}"); if (json.DataType == JsonDataType.Object) { foreach(JsonData key in json.GetKeys()) { Console.WriteLine(string.Format("{0}: {1}", key.ToJsonText(), json[key].ToJsonText())); } } else { Console.WriteLine("读取出现了错误"); } Console.ReadKey(); } } } 输出结果是: &ldquo;姓名&rdquo;: &ldquo;小明&rdquo; &ldquo;性别&rdquo;: &ldquo;男&rdquo; &ldquo;年龄&rdquo;: 16 &ldquo;境内&rdquo;: true &ldquo;自述&rdquo;: null &ldquo;学习科目&rdquo;: [&ldquo;语文&rdquo;, &ldquo;数学&rdquo;, &ldquo;英语&rdquo;, &ldquo;信息技术&rdquo;]
从结果来看, 正常分析了Json文本并且成功将Json数据转换为了Json文本. 下载: Github: Github仓库
. . . . .
补充: . . .查看元数据时并不能看到方法注释, 所以, 推荐查看源代码, 那里有完整的注释. . . .自述 : 自学C#的一只小辣鸡~ (欢迎与我交流~ []~ (￣▽￣)~*)</content></entry><entry><title>[C#] 数组去重: 超高速字符串去重 (可保留原顺序)</title><url>https://slimenull.top/post/csharp-removeduplicatestring/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag><tag>算法</tag></tags><content type="html"> 数组去重, 如果使用遍历并检查 Contains 的方法, 那么在处理大量数据的时候未免太慢, 另一种方法是先进行排序(例如桶排序), 那么只需要遍历一次就可以去除重复
代码适用于: 将字符串数组中的重复元素去除, 仅留下一个 应用场景: 你有一个超级长的文本文件, 这里面每一行都是一条数据, 例如这些数据是用爬虫获取的搜索关键字, 但可能含有重复, 你现在需要将它们去重. 这个算法可以帮助你快速完成去重的工作 局限性: 下面将介绍两种算法 一种是先进行排序, 这时, 相同的元素都在一起了, 然后再进行一次遍历去重, 那么除了排序的时间, 仅进行一次遍历就可以去重, 速度很快, 但原有顺序改变了. 第二种算法是较为特殊的算法, 借助了引用类型这个特性, 可以保证原有顺序不变, 但需要定义字典和列表, 也就是说要多需要一些内存. 2. 算法的主要内容 主要原理 通过排序, 将相同的元素凑到一起, 那么只需要比对当前元素和一个相邻元素就可以得出该元素是否是重复的. 那么只需要遍历一次就可以做到去重. 在此基础上, 用Dictionary的根据键可以快速访问值得特性, 将原字符串数组的元素索引与元素引用保存到Dictionary中, 就可以通过索引将字符串数组还原到原来的顺序, 详细还请看代码 实例代码 string[] RemoveSameElement(string[] source) { List&lt;string> result = source.ToList(); result.Sort(); for(int i = 1; i &lt; source.Length;) { if (result[i] == result[i - 1]) { result.RemoveAt(i); } else { i++; } } return result.ToArray(); } string[] RemoveSameElement(string[] source) { Dictionary&lt;int, StringInfo> d = new Dictionary&lt;int, StringInfo>(); List&lt;StringInfo> temp = new List&lt;StringInfo>(); List&lt;string> result = new List&lt;string>(); for (int i = 0; i &lt; source.Length; i++) { d.Add(i, new StringInfo(source[i])); temp.Add(d[i]); } temp.Sort(); for (int i = 0; i &lt; temp.Count;) { if (temp[i] != null) { temp.RemoveAt(i); } else { i++; } } foreach(StringInfo i in temp) { result.Add(i.Value); } return result.ToArray(); } // 通过这个StringInfo类来实现对string的引用 class StringInfo : IComparable { public StringInfo(string value) { Value = value; } public string Value; public int CompareTo(object obj) { if (obj.GetType() == GetType()) { return Value.CompareTo((obj as StringInfo).Value); } else { throw new ArgumentException("参数必须为StringInfo类型"); } } } 这个算法只是偶然间想到的, 不喜勿喷</content></entry><entry><title>[C#] 排序算法: 超高速根据字符串长度排序的算法</title><url>https://slimenull.top/post/csharp-fastsortbylength/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag><tag>算法</tag></tags><content type="html"> 使用 Dictionary 和 List, 桶排序实现超高速根据字符串长度排序字符串数组
1. 你需要知道这些: 代码适用于: 适用于字符串数组的元素长度变化量较小的, 比如字符串的长度普遍在1~2000, 那么此时, 这个算法将有超高的性能, 测试结果是 10万条数据排序所需时间为91ms(你没看错). 应用场景: 你有一个超级长的文本文件, 这里面每一行都是一条数据, 例如这些数据是用爬虫获取的搜索关键字, 你现在需要将它们排序, 别犹豫, 我认为这个算法非常适合你. 局限性 字符串数组的元素长度变化量越大, 该算法效率可能会越低,因为里面包含了对字符串长度变化量排序的过程,这个过程是使用的选择排序法。（选择排序法的所需时间与数据长度不成正比,不多赘述） 2.算法的主要内容 主要原理: 定义一个字典, 键是int, 值是可变的字符串列表, 定义一个可变的字符串列表作为存储结果的容器 循环源字符串数组, 将一切可能的长度作为int, 一个新的字符串列表作为值, 添加到上面所说的字典里面 第二次循环源字符串数组, 将迭代到的字符串的长度作为键, 在字典中键所对应的字符串列表中添加这个字符串 排序字典的键, 循环排序后的所有键, 将键对应的字符串列表的每一个字符串添加到结果中 排序结束 示例代码: // 这是C#代码 // Dictionary 与 List 位于 System.Collections.Generic 命名空间下 string[] StringSort(string[] source) { int[] sortKeys(int[] src) // 这里是用于排序字典的键的 { int most; int mostIndex = 0; int temp; if (src.Length > 1) { for (int i = 1; i &lt; src.Length; i++) { most = src[i]; for (int j = i; j &lt; src.Length; j++) { if (src[j] &lt; most) { most = src[j]; mostIndex = j; } } if (most &lt; src[i - 1]) { src[mostIndex] = src[i - 1]; src[i - 1] = most; } } } return src; } Dictionary&lt;int, List&lt;string>> firstSortedString = new Dictionary&lt;int, List&lt;string>>(); List&lt;string> result = new List&lt;string>(); foreach (string i in source) { if (!firstSortedString.ContainsKey(i.Length)) { firstSortedString.Add(i.Length, new List&lt;string>()); } } foreach (string i in source) { firstSortedString[i.Length].Add(i); } foreach (int i in sortKeys(firstSortedString.Keys.ToArray())) { foreach (string j in firstSortedString[i]) { result.Add(j); } } return result.ToArray(); } 这个算法只是偶然间想到的, 不喜勿喷</content></entry><entry><title>[C#] Image的Image.GetThumbnailImage(获取缩略图)方法实际是缩放与拉伸</title><url>https://slimenull.top/post/csharp-aboutthumbimage/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag><tag>图像</tag></tags><content type="html"> 经过测试,Image.GetThumbnailImage 方法并不只是获取缩略图,你甚至可以拿它来放大图片, 以及更多骚操作
稍微包装一下,就得到了下面的函数,这可真是令人愉悦呀 /// &lt;summary> /// 缩放图片 /// &lt;/summary> /// &lt;param name="source">处理源&lt;/param> /// &lt;param name="output">输出&lt;/param> /// &lt;param name="times">倍数&lt;/param> /// &lt;returns>表示操作是否成功&lt;/returns> private bool GetMicroImage(Image source, out Image output, int times) { try { output = source.GetThumbnailImage(source.Width * times, source.Height * times , () => false, IntPtr.Zero); return true; } catch { output = source; return false; } } 需要注意的是(GetThumbnailImage方法): 1.缩放时,如果指定的宽高比例与原图宽高比例不同,则输出的图片较原图还进行了拉伸 也就是说,GetThumbnailImage 方法对原图处理时,并不是等比例缩放</content></entry><entry><title>[C#] 实现简单聊天气泡</title><url>https://slimenull.top/post/csharp-chatbubble/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>WinForm</tag><tag>轮子</tag></tags><content type="html"> 在 WinForm 中借助 Panel 来实现简单的聊天气泡, 用户昵称, 头像, 以及消息的左右侧放置, 直接在项目中引用代码即可.
效果图 能满足我自己的需求了
直接看代码吧 真的很简单&hellip;
这是一个类,直接复制粘贴过去就好,不需要什么额外引用
class ChatBubble { public ChatBubble(Panel panel, Font font) { if (panel.Controls.Count != 0) throw new Exception("指定Panel控件不为空!"); ChatPlace = panel; BubbleFont = font; MsgMaxLength = panel.Width - (6 * 4 + 35 * 2); // 其中, 四个6为 图片与(容器以及消息文本框)的距离 ,两个35为两侧图片的大小. } readonly Panel ChatPlace; readonly Font BubbleFont; int NowY = 7; readonly int MsgMaxLength; public enum MsgPlace { Left, Right } // 气泡创建的位置 public void AddMsg(Image Photo, string Text, MsgPlace Place, string Name) { if (ChatPlace.Controls.Count != 0) NowY = ChatPlace.Controls[ChatPlace.Controls.Count - 2].Location.Y + ChatPlace.Controls[ChatPlace.Controls.Count - 1].Height + 7; PictureBox photo = new PictureBox(); // 头像 Label nickname = new Label(); // 昵称 Label msg = new Label(); // 消息内容 photo.Size = new Size(35, 35); photo.SizeMode = PictureBoxSizeMode.StretchImage; photo.Image = Photo; nickname.AutoSize = true; nickname.MaximumSize = new Size(0, 0); nickname.Font = BubbleFont; nickname.Text = Name; msg.AutoSize = true; msg.Font = BubbleFont; msg.MaximumSize = new Size(MsgMaxLength, 0); msg.Text = Text; msg.BorderStyle = BorderStyle.FixedSingle; ChatPlace.Controls.Add(nickname); ChatPlace.Controls.Add(photo); ChatPlace.Controls.Add(msg); if (Place == MsgPlace.Left) { photo.Location = new Point(7, NowY); nickname.Location = new Point(photo.Location.X + photo.Width + 6, NowY); msg.Location = new Point(nickname.Location.X, NowY + nickname.Size.Height); } else { photo.Location = new Point(ChatPlace.Width - 7 - 35 - 17, NowY); nickname.Location = new Point(photo.Location.X - 7 - nickname.Width - 17, NowY); msg.Location = new Point(photo.Location.X - 7 - msg.Width - 17, NowY + nickname.Size.Height); // 这里的减去17是除去滚动条的宽度 } } } // 简易聊天气泡 使用这个类时,是需要提供一个Panel控件对象作为气泡创建的位置.
可以添加两种消息,左侧或者右侧.
最重要的原理就是Label的AutoSize,通过这个,我们就可以省去很多麻烦,然后再计算一个气泡最大的宽度可以是多少,设置Label的最大宽度,于是又实现了自动换行.
使用方式: 在自己的项目中添加这个类,之后实例化 实例化时需要提供一个panel控件实例来作为气泡创建的容器 之后要添加消息的时候直接使用实例的方法 AddMsg即可,参数中已经包含了用户头像(Photo),消息内容(Text),消息位置(Place),发消息的用户(Name).
你可能也需要这个 不一定与上面的代码有关,但与聊天气泡有关
TestBox textBox1 = new TextBox(); int Lines = textBox1.GetLineFromCharIndex(textBox1.Text.Length) - 1; //Lines即为textBox1中文本的行数(包括自动换行)</content></entry><entry><title>[C#] 从网络上下载文件</title><url>https://slimenull.top/post/csharp-downloadfile/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>笔记</tag></tags><content type="html"> 之前一直不理解如何是从网络上下载文件的&hellip;自己试了试懂了, 使用 WebRerequest, 然后获取响应, 拷贝到文件流中即可.
FileStream file = File.CreatWrite(filePath); // 创建文件 WebRequest.Creat(url).GetResponse().GetResponseStream().CopyTo(file); // 创建WebRequest对象,获取响应,获取响应流,将响应流写入到文件流 file.Close(); //关闭文件 嗯,这种简洁的代码最喜欢了 (虽然简洁&hellip;但是没人愿意看的hhh)
或者也可以写成函数
bool DownloadFile(string url, string toDirectory, string fileName, int timeout = 2000) //返回值是是否下载成功 { string PathCombine(string path1,string path2) //合成路径 { if (path1.EndsWith("\\")) { path1 = path1.Substring(0, path1.Length - 1); } if (path2.StartsWith("\\")) { path2 = path2.Substring(1); } return path1 + "\\" + path2; } if(!Directory.Exists(toDirectory)) { Directory.CreatDirectory(toDirectory); } FileStream file = File.OpenWrite(fileName); WebRequest request = WebRequest.Creat(url); request.Timeout = timeout; //设置请求超时为函数参数 try { request.GetResponse().GetResponseStream().CopyTo(file); } catch { return false; } file.Close(); return true; } 嗯,这样好了一些,因为设置了请求超时</content></entry><entry><title>[C#] 动态输入</title><url>https://slimenull.top/post/csharp-dynamicinput/</url><categories/><tags><tag>.NET</tag><tag>C#</tag><tag>轮子</tag><tag>旧的</tag></tags><content type="html"> (旧的) 在使用 Console.ReadLine 的时候, 用户不按回车确认, 你就无法获取用户输入了什么内容, 于是我封装了一个类实现获取用户输入内容
注意，这里是在我刚学C#时写的，但我不想删除任何我的足迹. ==这个类库不是完善的，如果需要完整功能(真的很好用)，请去我的新文章==: [C#] 控制台动态输入 - 增强版ReadLine()
代码: 主要就是能够实现在输入的同时,子线程可以通过该实例的Text属性来访问已经输入了的内容,别的倒也懒得实现了awa
刚学不久,不喜勿喷
//其实代码不怎么好,做做参考就可以了,注意:没有普通Console.ReadLine()的上下键功能 class DynamicInput { class CharInfo { public CharInfo(int position,char chr) { this.position = position; this.chr = chr; } int position; char chr; public int Position { get { return position; } } public char Char { get { return chr; } } } delegate void Add_historyEventHandler(object sender,EventArgs e); private int default_left; private string text = ""; private List&lt;string> input_history = new List&lt;string>(); private List&lt;CharInfo> input_list = new List&lt;CharInfo>(); public string Text { get { return text; } } public string Start() { default_left = Console.CursorLeft; ConsoleKeyInfo key; while (true) { key = Console.ReadKey(); if (key.Key.Equals(ConsoleKey.Enter)) { return text; } //回车确认 if (key.Key.Equals(ConsoleKey.Backspace)) { Console.Write(" "); if (Console.CursorLeft > input_list.Count) { if (input_list.Count >1 ) { for (int i = 0; i &lt;= Console.CursorLeft - input_list[input_list.Count-2].Position; i ++) { Console.Write("\b \b"); } } else { for (int i = 0; i &lt;= Console.CursorLeft - default_left; i++) { Console.Write("\b \b"); } } } else { if (input_list.Count > 1) { for (int i = 0; i &lt;= Console.CursorLeft + Console.WindowLeft - input_list[input_list.Count - 2].Position; i++) { Console.Write("\b \b"); } } else { for (int i = 0; i &lt;= Console.CursorLeft + Console.WindowLeft - default_left; i++) { Console.Write("\b \b"); } } } if(input_list.Count > 0) { text = text.Substring(0, text.Length - 1); input_list.RemoveAt(input_list.Count - 1); } continue; } //BackSpace退格 if (!key.Key.Equals(ConsoleKey.Spacebar) &amp; (key.KeyChar == ' '|key.KeyChar == '\0')) { Console.Write("\b"); continue; } text += key.KeyChar; //更新Text input_list.Add(new CharInfo(Console.CursorLeft, key.KeyChar)); //记录字符与位置 } } }</content></entry><entry><title>FFmpeg 使用概述</title><url>https://slimenull.top/post/tool-ffmpeg/</url><categories/><tags><tag>参考</tag><tag>笔记</tag><tag>杂</tag></tags><content type="html"> 通过简单的格式转换以及视频压缩示例讲解 FFmpeg 基本使用
命令格式 使用 ffmpeg --help 可以查看 ffmpeg 的详细帮助手册, 其中包含对于视频, 音频, 以及其他的选项, 使用这些, 可以做到对多媒体文件进行压缩, 剪切, 裁切等操作
ffmpeg 的标准命令格式是:
ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile} ffmpeg [选项] [[输入文件选项] -i 输入文件]... {[输出文件选项] 输出文件}... 其中, options, infile 是可选项, outfile 是必选项, 当指定定了 infile, 则可以指定 infile options; outfile options 也是可选项. infile 可以指定多个, 对应的, outfile 也可以指定多个, 但是 infile 和 outfile 一定是对应的. infile options 和 outfile options 分别位于 infile 和 outfile 的前方, 如果位置指定错误, 那么运行起来也是不同的.
格式转换 使用 ffmpeg -i 输入文件 输出文件 可以直接将一个文件转换为另一个文件, ffmpeg 会自动识别文件后缀, 并应用对应的格式.
ffmpeg 可转换的格式非常多, 视频, 音频, 以及常用的图片格式, 例如我们想要讲一个 test.png 转为 webp 格式, 那么可以使用以下的代码
ffmpeg -i test.png test.webp 压缩内容 对于视频, 如果要压缩, 那么可操作的方式是非常多的, 例如减小帧率, 减小分辨率, 减小比特率, 这些都是可以通过 ffmpeg 的参数直接达到的.
-r rate 设置帧率 (赫兹值, 分数或简写) -s size 设置帧尺寸 (宽x高, 或缩写) -ab bitrate 音频比特率 (请使用 -b:a) -b bitrate 视频比特率 (请使用 -b:v) 例如将一个 test.mp4 视频压缩至 30hz刷新率, 1280x720分辨率, 1mb视频比特率, 128kb音频比特率, 可以使用以下指令
ffmpeg -i test.mp4 -r 30 -s 1280x720 -b:v 1m -b:a 128k test_compressed.mp4</content></entry></search>